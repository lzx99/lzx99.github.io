<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础语法糖</title>
    <link href="/2023/09/06/Java/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2023/09/06/Java/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常是Java的一个类，当然你也可以继承某些异常基类自定义异常，反正异常抛出来，代码表示代码出现了“错误”。</p><p>Java中有2大类异常：</p><ol><li><strong>运行时异常</strong>（非受检异常），IDE不需要不捕获的异常。这种异常一般就意味着代码有问题，出现了不应该出现的一些错误，比如空指针异常、数组越界异常，我们应该去修改代码的问题。当我们自定义异常不想要IDE在编译阶段强制我们处理异常时，也可以继承运行时异常作为基类</li><li><strong>检查性异常</strong>（编译时异常），IDE会要求必须捕获也就是必须try-catch的异常。这种异常意味着你对这部分API应该进行容错处理，try-catch就是为了容错处理，万一没有按照要求执行，我们应该如何继续处理，比如IOException、SQLException等，这些操作非常容易没有按照要求继续。</li></ol><p>异常的产生，都是你在调用这些Java API的时候，源码的方法throws了异常，对于运行时异常，IDE不会在编译阶段，让抛出的异常进行try-catch或者throws，但对于检查性异常，这要求我们在编译前必须捕获，如果不捕获，那就必须方法签名再throws给上层调用方。一般来说，如果是执行层面的代码，就一般会try-catch，如果是封装层面的API，throw异常并方法签名throws是一种常规操作，表示你调用我API失败后，必须容错处理。</p><p>对于try-catch，try块捕捉异常对象，catch块决定捕捉异常后的处理方式，要注意try代码块中，抛出异常，后面的代码不再可达。自己去裁定try的范围，需要明细打印问题，可以精细化try-catch处理，自己结合工作实践合理的去划定try的范围，使代码更清晰，可读性更高。然后在try执行代码块中主动throw一个Exception，然后在catch，这是<strong>异常用于流程控制</strong>的一种使用，有些情况相比于if-else，可能更加清晰的标注了“错误”的代码处理逻辑，保持代码的清晰性。</p><p>抛出异常后，在catch中使用e.printStackTrace()，只会在控制台打印堆栈信息，如果要记录在日志中，则需要利用日志工具将堆栈信息印在日志中，大部分日志工具都会提供<code>log.error(&quot;&quot;,e)</code>的方法打印堆栈信息至日志。</p><h2 id="变量和方法的设计"><a href="#变量和方法的设计" class="headerlink" title="变量和方法的设计"></a>变量和方法的设计</h2><p>Java类由成员变量和方法组成，任何的代码都是从方法内部开始的。</p><p>传入参数到方法时，或者说变量赋值是，基本数据类型是<strong>值传递</strong>，引用类型数据时<strong>引用传递</strong>，此时方法内对参数进行修改，也会影响原始值，这是Java的设计，如果不想改变引用类型数据的值，在方法内部使用clone或者其他方式创造副本再进行操作。</p><p>对于成员变量的设计，除了类标志性的属性可以设置为成员变量，试情况也可以将一些需要外部传入的业务流水号等，设置为成员变量，不需要将所有外部传入的值，全部通过方法参数传入。很多纯逻辑处理的工具类，是没有成员变量的，里边可能就全是static方法。注意成员变量设置的时候一般就全部设置为private访问控制符，很少设置成其他访问控制符。</p><ol><li><p>（类）成员变量：定义在方法外的变量，<strong>有默认值</strong>，引用类型的变量默认值是null（**String初始化建议写””**），布尔类型默认值为false，加载在堆内存中，随着对象产生或消亡。</p></li><li><p>（方法）局部变量：定义在方法中的变量，<strong>局部变量无默认值，使用前必须要初始化</strong>。局部变量的创建在栈内存中，随着方法产生和消亡，即随线程产生或消亡。</p></li><li><p>静态变量（类变量）：是一种特殊的成员变量，成员变量基础上加用static关键字修饰属性，类加载时产生（class文件读取到内存中）</p></li></ol><h2 id="流程语法"><a href="#流程语法" class="headerlink" title="流程语法"></a>流程语法</h2><p>break跳出控制语句（switch，for，while等），continue跳出本次循环（用于for循环），return跳出整个函数</p><p>在判断语句中，<strong>单纯判断、char、byte、short、int和String（JDK 7 ）的值情况</strong>可以用switch代替if-else<br>switch效率比if-else高，但是灵活度非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    System.out.println(<span class="hljs-string">&quot;this is one.&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    System.out.println(<span class="hljs-string">&quot;Others.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resource和try-catch-finally"><a href="#try-with-resource和try-catch-finally" class="headerlink" title="try-with-resource和try-catch-finally"></a>try-with-resource和try-catch-finally</h4><p>Java 7以后，数据库连接和流，可以使用try-with-resource代替try-catch-finally，让代码变得更简单，资源会自动关闭，不再需要在finally里调用close方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 读取文件数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-comment">// 处理异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包与访问权限"><a href="#包与访问权限" class="headerlink" title="包与访问权限"></a>包与访问权限</h2><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>当我们需要使用<strong>非本包中的类</strong>时，用import关键字导入包的具体类或所有类；或者直接在代码中写类。只有lang包下的类和同一个包下的类不需要导包，可以直接使用类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.zhuxin.*  <span class="hljs-comment">//通配符导入com.zhuxin包中所有的类</span><br><span class="hljs-keyword">import</span> com.zhuxin.Demo<span class="hljs-comment">//导入com.zhuxin包中的Demo类</span><br><span class="hljs-comment">//JDK5后，支持导入静态属性，称静态导入，导入System类中的out属性</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.out<br></code></pre></td></tr></table></figure><h4 id="访问权限控制符"><a href="#访问权限控制符" class="headerlink" title="访问权限控制符"></a>访问权限控制符</h4><ul><li><p><strong>类的属性与方法的访问控制</strong></p><p>当你对类有访问权限后（同包类，或者导包后），访问权限控制符，约束了调用类中成员变量和成员方法能否被直接调用，下面访问权限越来越大</p><ol><li><p><strong>private</strong>：除了在本类，均不能被直接访问，即使是继承了父类的子类，这也是最常使用的权限控制符</p></li><li><p>不加修饰符：可以被<strong>同包</strong>的类直接访问，又称为包级访问权限。特殊的是，对于接口，他不是类，所有方法和属性只能是public权限，所以接口不加修饰符，方法和属性就是public，而不是default的同包权限</p></li><li><p><strong>protected</strong>：可以被<strong>同包和子类</strong>直接访问，一般来说子类通常可以允许</p></li><li><p>public：可被所有包的类访问。</p></li></ol></li><li><p>类的访问权限，比较少使用</p><ol><li>public：修饰的类在导包后，能在所有包中使用，</li><li>不加权限（包私有类）：修饰的类只能在本包中使用，就算导包也无法访问到类</li></ol></li></ul><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this关键字是JVM在创建对象后产生的一个<strong>指向对象本身的一个引用</strong>，根据这个原理，得出this的作用</p><ol><li><p>this.属性&#x2F;方法：<strong>强调本类的成员属性或成员方法</strong>，内部类中的this强调内部类本身的成员属性和方法</p><p>重写方法后不仅使用方法默人会指向子类重写方法，原父类方法中的this调用的方法也会指向子类重写方法。</p><p>属性不存在重写，就算子类有一个父类同名属性，父类方法加与不加this都是永远调用的是父类属性，子类方法永远调用的是子类的属性。</p></li><li><p>this()：<strong>在构造方法中调用本类的其他构造方法，注意必须写在构造方法第一行。</strong></p><p>场景举例：写一个包含所有字段的构造函数，然后其他部分字段构造函数去调用这个全字段构造函数</p></li><li><p>this：单纯<strong>代指当前对象</strong>，</p><p>比如父类方法中存在return this，父类对象调用这个方法返回父类对象；子类对象调用这个父类方法，虽然是父类中的this，但是会返回子类对象，这是Java多态性的体现。</p></li></ol><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ol><li><p>super.属性&#x2F;方法：当<strong>子父类存在相同的属性或方法时</strong>，super强调当前对象父类中的属性和方法，如果不存在，子类可直接使用父类的属性方法（private修饰除外）</p></li><li><p>super()：在子类构造方法中调用父类构造方法。super方法必须写在构造方法的首行，不能和this()一同使用</p><p>子类构造方法默认在首行使用了super()调用了父类中的无参构造方法，要注意的是，如果父类不存在无参构造方法将会报错，<strong>注意给父类编写带参构造方法后需要注意再编写一个无参构造方法</strong>。</p></li></ol><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ol><li>被final<strong>修饰的类不能被继承</strong>，为了安全考虑明确禁止继承，一般很少将类设计为final类。</li><li>修饰的变量为不可更改的常量，当修饰基本数据类型值不能改变，<strong>修饰引用类型不能更改指向的对象</strong></li><li>被final<strong>修饰的方法不能被子类重写</strong>，明确禁止子类重写此方法时才用final修饰方法，父类的private方法其实是一种隐式地指定为final方法。</li></ol><h4 id="static关键字（类方法，类属性）"><a href="#static关键字（类方法，类属性）" class="headerlink" title="static关键字（类方法，类属性）"></a>static关键字（类方法，类属性）</h4><p>static修饰的属性（不能修饰局部变量）和方法，成为静态属性或静态方法，静态方法和静态属性属于类，不依赖与某个对象，可以直接<strong>通过类名调用静态属性和静态方法</strong>，但遵循访问权限控制。<strong>静态方法只能直接调用静态变量和静态方法</strong>，所以在Main方法调用的其他方法，要么是静态方法，要么是通过对象调用的普通方法。</p><p>static方法可以重写，但是不支持多态，也可以说<strong>static方法的重写不算重写</strong>，父类引用调用的还是父类中的方法，而不是子类中的同名静态方法，当然这种编写方式也没什么意义。</p><p>static还有一个地方用法就是静态内部类，基本很少用。</p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h4 id="重载-overloadding"><a href="#重载-overloadding" class="headerlink" title="重载(overloadding)"></a>重载(overloadding)</h4><p>重载是方法名不变，<strong>返回类型和形参变化形成新的方法，而且形参必须变化</strong>，也就是说相同的方法名实际代表不同的方法。</p><p>当没有对构造方法进行重载时，默认带一个无参构造方法，当对构造方法重载了一个有参数构造方法后，无参构造方法消失。</p><p>可变长度参数（如String… args）：0个或多个参数。方法的参数列表内可以传入不定长度的参数，只能有一个可变长参数且放于所有参数后面，在要实现不定长度参数的类型后加 **…**。Java的可变参数在编译为字节码后，在方法签名中就是以数组形态出现的（将几个参数打包成数组），所以二者同时不可重载</p><h4 id="重写-override-，也称覆写"><a href="#重写-override-，也称覆写" class="headerlink" title="重写(override)，也称覆写"></a>重写(override)，也称覆写</h4><p>重写方法是继承性的重要性质，子类的重写方法的<strong>行参和返回类型不能改变</strong>，JDK5后子类返回值可以是父类的派生类，子类重写方法<strong>访问权限不能比父类方法严格</strong>。</p><p>重写方法后，调用方法默认会指向子类重写方法，比如父类引用也会调用子类方法（提现Java的多态），同时原父类this调用的方法也会指向子类重写方法。当子类想调用父类方法不调用子类重写方法，使用super关键字调用原父类方法。</p><p>属性不存在重写，就算子类有一个父类同名属性，父类方法加与不加this都是永远调用的是父类属性，子类方法永远调用的是子类的属性。</p><h2 id="Java的几种特殊类"><a href="#Java的几种特殊类" class="headerlink" title="Java的几种特殊类"></a>Java的几种特殊类</h2><p>Java中存在3种类，普通类，抽象类和接口。抽象类在继承方面的特性和普通类一样，单继承类，多继承接口；接口可以多继承接口，当普通类实现子接口时，强制实现类重写子接口和父接口中的所有抽象方法。</p><p>抽象方法：即abstract方法，用abstract修饰且无方法体的方法</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口定义了规范或者说协议，他是一组抽象方法的集合，可以省略。我们使用interface声明定义一个接口，然后类使用implement实现接口。</p><p>接口的属性只能是静态常量并很少使用，默认可以不写public static final。Java8以后，接口方法可以是default方法和static方法，这使得接口和抽象类很像，default一般用于老接口的拓展，他们都可以实现类来调用，一般不推荐在接口中使用这两种方法。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>用abstract修饰class即为抽象类，<strong>唯一特征是不能被实例化</strong>，必须被继承才能实例化。抽象类可以有属性，甚至可以没有抽象方法，有抽象方法的抽象类被继承时，子类必须实现抽象方法，要注意<strong>与接口不同，抽象类的抽象方法必须要用abstract声明</strong>；抽象类可以像普通类一样单继承类，多继承接口，继承接口也可以选择不实例化，留给继承抽象类的类实例化。</p><h4 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h4><p>内部类是一个编译时的概念，编译完成以后成为两个不同类。内部类中的this关键字指的内部类成员属性和方法，外部类名.this才是强调外部内的成员属性和方法，</p><p>内部类特性：可以直接调用外部类的private属性。</p><p>成员内部类、<strong>匿名内部类</strong>、静态内部类。Runnale接口就常用匿名内部类，这是内部类最重要的部分，其他比较少使用，参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409">廖雪峰内部类</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部类实例化依赖于外部类实例化</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><h4 id="1-封装性"><a href="#1-封装性" class="headerlink" title="1. 封装性"></a>1. 封装性</h4><p>面向对象的核心思想之一就是封装性（Encapsulation），封装就是将属性和方法这些具像的东西“装”到一个类中，私有化属性，<strong>提高安全性</strong>，<strong>隐藏实现细节</strong>。</p><p>我们使用API或者各种框架时，封装性使得我们忽略实现细节，只要去使用即可。</p><h4 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h4><p>子类extents父类，获得父类的属性和方法（除private属性和方法），并<strong>通过重写方法和增加新方法，形成新的类，复用父类的代码</strong>，这就是OOP中的继承性的作用。C++使用多继承，Java支持单继承（Single inheritance）。</p><p>实际证明，继承关系（class-based）确实会带来一些代码量的减少，但是带来了子父类的强耦合，所以更现代的流派更推荐使用组合关系（prototype-based），也就是像Java的接口一样，Go语言已经完全采用prototype-based关系。</p><h4 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3. 多态性"></a>3. 多态性</h4><p>Java中的多态是一个父类类型对不同子类对象同一方法的不同响应，代码解耦合，例如工厂模式，service接口等就是多态的运用。</p><p>实现多态，最基础依赖于继承或者实现（extends&#x2F;implement），当子类方法重写，这是动态多态的基础（运行时多态），后续可以进行向上转型或者向下转型，另外方法的重载也是一种多态，这是静态的多态（编译时多态）。<a href="https://blog.csdn.net/SEU_Calvin/article/details/52191321">多态原理</a></p><ul><li>向上转型（upcast）：父类引用指向子类对象。也可以解释成子类对象转化成了父类，也就是所谓的“向上”</li><li>向下转型（downcast）：父类引用重新强转回子类，当父类对象要调用子类的独有方法时需要向下转型，相当于我们多态父类引用转回原子类。向下转型比较少用，用也搭配<code>instanceof</code>，防止出现类型转化异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCasting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Upcasting</span><br><br>        <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) animal; <span class="hljs-comment">// Downcasting</span><br>            dog.bark(); <span class="hljs-comment">// Outputs: Dog barks</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Java所有类都继承自Object类，同时也会继承到Object类中的方法，如hashcode()、equals()、clone()、notify()、wait()、finalize()，除了equals()和finalize()，其他方法都是native方法（JNI调用），此处重点摘记一下浅拷贝和深拷贝。</p><p>实现浅拷贝：需要类implements Cloneable接口，重写clone方法，然后对象调用clone()实现浅拷贝，浅拷贝只会复制基本数据类型，复制的属性是引用型数据时，例如类和数组，只会复制内存地址，而不会完全复制一份对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>而深拷贝就是所有属性都会完全复制一份，自己去实现对象复制，任何可以达到的方式都可以，比较常用的是使用对象序列化和反序列化，整体使用简单，用流先写入再读取，特别是属性较多时，不需要一个个赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 将对象写入字节流</span><br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>    oos.writeObject(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// 从字节流中读取对象</span><br>    <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>    <span class="hljs-keyword">return</span> ois.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些方式实现深拷贝，就是clone()方法先拷贝基本数据类型，再逐步实现引用型数据的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>  <span class="hljs-type">int</span> number;<br>  String name;<br>  <span class="hljs-type">int</span>[] arr;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepCopy</span><span class="hljs-params">(<span class="hljs-type">int</span> number, String name)</span> &#123;<br>      <span class="hljs-built_in">this</span>.number = number;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>      <span class="hljs-type">DeepCopy</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> (DeepCopy) <span class="hljs-built_in">super</span>.clone();<br>      copy.arr = arr.clone(); <span class="hljs-comment">// Deep copy of the array</span><br>      <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁和事务</title>
    <link href="/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/2.%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/2.%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>事务是一组原子性的SQL语句，MySQL中只有Innodb引擎才支持事务，锁是针对事务来说的，比如，在执行当前事务时，拿到了锁，才能进行update，事务提交。就释放了记录的锁。</p><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><p>InnoDB基本不使用表级锁，除了在Alter table时，会自动加上表锁，我们在SQL层面操作主要还是下面<strong>两种行锁</strong>，要注意的是，select默认情况下不加锁，update和delete默认加X排他锁。数据库锁以事务为单位，同一个事务下锁可重入，也就是说数据锁是可重入锁，主要有两种显示的悲观锁。</p><ol><li><strong>排他锁</strong>（X锁，Exclusive Lock）：for update。</li><li><strong>共享锁</strong>（S锁，Shared Lock）：lock in share mode</li></ol><p>除了常规行锁，还有两种隐藏的锁，一种是<strong>GAP间隙锁</strong>，例如对一个索引字段使用范围查询（如BETWEEN、&lt;、&gt;等），如SELECT … WHERE … FOR UPDATE ，会在索引区间上加上GAP间隙锁，不允许其他事务新插入或删除索引区间内的数据。</p><p>另一种是RR级别下独有的Next-Key锁，在以索引字段为条件，进行当前读&#x2F;update&#x2F;delete时，当前记录加入行锁，两边区间加入GAP间隙锁，统一形成叫Next-Key锁。你可以理解为在RR中，用索引进行update&#x2F;delete，会比RC级别形成更多GAP锁，RC级别只在用索引进行范围操作时产生GAP锁。</p><p>GAP间隙锁和Next-Key锁，都能降低当前事务出现“<strong>幻读</strong>”的几率，幻读是值指同一个事务内多次查询返回的结果集不一样，比如事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录。</p><p>对于数据库悲观锁，基于数据库版本号的乐观锁其实就是CAS乐观锁</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>由于MySQL事务是默认自动提交的，注意使用<code>SET AUTOCOMMIT=0</code>关闭MySQL事务自动提交。</p><p>另外MySQL DML可以像Oracle数据库一样隐式开启事务，但是更推荐使用BEGIN或者START TRANSCATION显式开启事务，保持更好的可读性，并使用COMMIT提交事务。</p><p>不同隔离级别下的加锁方式是不同的。<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">mysql事务下的锁机制(美团)</a></p><p>数据库事务遵循ACID的设计原则，即原子性（要么都执行，失败回滚）、隔离性（并发事务隔离）、一致性（一个状态转化另一个状态，但数据完整性一致）、持久性（事务完整，数据库改动是永久的）。</p><p>MySQL存在4中事务隔离级别，可以说是4种类型的事务等级，其中<strong>Innodb默认事务隔离级别是可重复度</strong>，实际上，数据库并发的优化，或者说这些隔离级别之间的差异，就是针对“读”。</p><ol><li><p>READ-UNCOMMITTED（未提交读）：任何情况都不加锁，也就意味着，事务没有提交，新值就可以被其他事务所读取，这就叫出现“<strong>脏读</strong>”。</p></li><li><p>READ-COMMITTED（提交读）：读不加锁，增删改加排他锁；不会再出现脏读，其他事务如果提交，当前事务就可能够读取最新的版本，这就是所谓的RC会出现“<strong>不可重复读</strong>”，也就是指“在一个事务内，多次读取同一数据可能会结果”。因为RC的MVCC（多版本并发控制），在每次<strong>快照读</strong>，都会生成一个基于当前已提交的生成新一致性视图，可能其他人进行了update或delete并提交了，造成两次读取不一致。</p></li><li><p>REPEATABLE-READ（可重复读）：<strong>读不加锁，增删改加排他锁</strong>；RC的MVCC在快照读在第一次读，就生成了一个全局的一致性视图，这就不会再出现“不可重复读”。</p></li><li><p>SERIALIZABLE（串行化）：完全使用悲观锁，读用读锁，写用写锁。解决了幻读的问题</p></li></ol><p>为了防止数据库死锁有几种措施，比如事务之间保持数据更新的顺序；业务允许的情况下，尽量降低事务的粒度，或者降低事务级别到RC级别，防止gap锁造成死锁；添加合理的索引，不走索引会全表加GAP锁，更容易死锁。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几种常见查找日志命令的比较</title>
    <link href="/2023/02/23/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/7.%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/"/>
    <url>/2023/02/23/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/7.%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>推荐使用：</p><ol><li><p><code>tail -f -n 20 file</code>，-f实时查看，-n 20是查看末尾20行，不加-n默认是只看10行</p></li><li><p><code>less -N file</code>，分页打开文件，-N表示显示行号，然后使用<code>/keyword</code>匹配关键字。less也支持像tail命令一样实时查看日志<code>less +F file</code></p><ul><li>匹配关键字后，n查找下一个匹配，N查找上一个匹配。</li><li>分页操作：space下翻一页、b上翻一页、上翻一行(↑) 下翻一行（↓）、跳转末尾G、跳转开头g</li></ul></li><li><p><code>grep -C 10 &quot;keyword&quot; file</code>，大日志查看时，效率最高的，而且支持递归查找文件，如果要打印行号，可以加-n参数，注意tail和grep是-n，less是-N</p></li></ol><p>低频率使用:</p><ol><li><code>cat file ｜ grep &quot;keyword&quot;</code>，打印文件在控制台。只适合直观查看小文件，用管道搭配grep效率低，且无法利用grep的多个参数精确查找，直接用grep就可以。</li><li>vi&#x2F;vim打开日志文件，然后使用<code>/keyword</code>匹配关键字，匹配后n查找下一个匹配的关键字，N查找上一个匹配，使用与less类似，但要加载整个文件，less翻页更方便。</li><li>head file 头10行，more和less类似，但不支持往前看，也基本不用于查找日志</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库加索引</title>
    <link href="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>数据库有3种方式创建索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 这种方式建立索引最简单，但是表中需要有数据，否则索引建立失败<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> lmt_crdt_app <span class="hljs-keyword">ADD</span> INDEX idx_cust_name(cust_name);<br># 通过<span class="hljs-keyword">create</span> INDEX<br><span class="hljs-keyword">CREATE</span> INDEX idx_cust_name <span class="hljs-keyword">ON</span> lmt_crdt_app(cust_name);<br># 可以在建表时，在所有字段的最后，加上索引 INDEX idx_cust_name(cust_name);<br></code></pre></td></tr></table></figure><p>最常见的是普通索引（<strong>INDEX</strong>），上面代码中创建的就全是普通索引</p><p>还有一种索引是唯一索引（<strong>UNIQUE INDEX</strong>），创建唯一索引在普通索引的INDEX前加一个UNIQUE标识就行了。他的值必须要唯一，如给“电子邮件”这个字段加上唯一索引，那么每一个电子邮件都不能够重复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用brew去管理一些后台进程</title>
    <link href="/2022/03/24/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/6.brew/"/>
    <url>/2022/03/24/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/6.brew/</url>
    
    <content type="html"><![CDATA[<p>brew对于命令行的程序，起到一个打包编译的作用，ARM版的brew通常只能安装ARM版的程序。</p><p>brew常用的命令brew list&#x2F;search&#x2F;info&#x2F;intall&#x2F;unintall&#x2F;deps&#x2F;outdated&#x2F;update&#x2F;upgrade等。</p><p>在命令前加入<code>arch -x86_64</code>模拟x86环境运行。</p><p>建议brew安装mysql&#x2F;redis，且推荐安装以后使用<code>brew services</code>来管理服务的启动和关闭。以mysql为例，<code>brew services start mysql</code>和<code>mysql.server start</code>同样可以启动mysql，要注意brew的启动在重启后不会失效，使用brew有利于统一多服务的管理。</p><h3 id="macOS多版本-node"><a href="#macOS多版本-node" class="headerlink" title="macOS多版本 node"></a>macOS多版本 node</h3><p>可以使用nvm和n这样常用的node管理工具来管理安装，也可以使用node link&#x2F;unlink不同的node版本</p>]]></content>
    
    
    <categories>
      
      <category>Mac相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GIT要注意的几个问题</title>
    <link href="/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/4.GIT/"/>
    <url>/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/4.GIT/</url>
    
    <content type="html"><![CDATA[<p>Git的commit版本是整个库的版本，不是单独具体到某个文件的版本，处于不同commit的文件，可能就是相同的。</p><p>Git有三大分区，工作区、暂存区和版本库。文件add后，存在于stage区中（暂存区），通过commit到版本库。</p><h4 id="关于切换分支的问题"><a href="#关于切换分支的问题" class="headerlink" title="关于切换分支的问题"></a>关于切换分支的问题</h4><p>切换分支时，如果暂存区中有文件在修改，会有两个情况。第一种是两个分支里的文件内容相同时，checkout切换分支会将暂存区中的修改内容保留；第二种情况是两个分支里的文件就不同时，会提示禁止checkout（-f 强制切换时，会丢失修改内容），此时不想commit，可以使用<code>git stash push</code>，临时存储暂存区修改，push通常省略，使用<code>git stash pop</code>恢复最后一次stash的暂存区。</p><h4 id="pull、push"><a href="#pull、push" class="headerlink" title="pull、push"></a>pull、push</h4><p>pull相当于fetch+merge操作。</p><p>本地和远程的相同分支，本质上是两个分支，pull相当于现将远程分支merge到本地merge，合并规则和本地之间的不同分支是相同的。</p><p><strong>与远程分支同步时</strong>，如果本地有暂存区修改，一定要<strong>先commit，再pull，再push</strong>。</p><p>merge过程中，暂存区不会修改，IDEA的merge过程，远程分支别人已经修改过一版，此时pull正常merge到本地，再commit，可能会将别人的代码覆盖而Git不会出现任何提示，而先commit，再pull，过程中Git会提示解决冲突。本地解决完冲突后，最好再次pull，再push。</p>]]></content>
    
    
    <categories>
      
      <category>GIT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/5.HTTP/"/>
    <url>/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/5.HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP报文由起始行、头部、正文三部分组成，请求报文的起始行教请求行，响应报文的起始行叫状态行，然后头部和正文之间有空行。</p><p>请求报文：</p><p>响应报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Server: nginx<br>Date: Mon, <span class="hljs-number">20</span> Feb <span class="hljs-number">2017</span> 09:<span class="hljs-number">13</span>:<span class="hljs-number">59</span> GMT<br>Content-Type: text/plain;charset=UTF-<span class="hljs-number">8</span><br>Vary: Accept-Encoding<br>Cache-Control: no-store<br><br>&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>无连接</strong>；即请求时连接，返回响应就释放连接。多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消。</p></li><li><p><strong>无状态</strong>：每个HTTP请求是独立的，服务器不会记住之前的请求和响应的状态。所以用<strong>Cookie和Session</strong>来模拟状态信息。</p></li></ol><p>Cookie：会话保存在客户端，Cookie只能保存是字符串（4KB），切勿保存重要数据，<strong>默认浏览器关闭时清除session</strong>，除非服务端设置setMaxAge。一个cookie对象中最重要的成员变量就是name和value，在Javaweb中，使用request.getCookies()获得一个cookie数组，request.getName()获得cookie的name，getValue获得cookie的value</p><p>Session：会话保存在服务器，在调用getSession时创建，判断cookie中有无sessionid，无就生成sessionID，定义一个会话状态，并将sessionid通过Cookie发送给浏览器。</p><p>restful的前后端分离项目中一般会使用 access_token，因为前后端分离项目跨域，使用cookie里的sessionID不方便认证状态，这个token和session_id是一个意思。<a href="https://juejin.im/entry/5bd921fce51d45686d40b2d6">分离Cookie参考</a></p><p><a href="https://blog.csdn.net/hxfghgh/article/details/82840613">关于Cookie</a></p><h4 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1. HTTP 请求报文"></a>1. HTTP 请求报文</h4><p>请求行–HTTP头字段–空行–正文</p><ol><li>**GET请求：放在请求行(URL)**，会暴露在地址栏，有长度限制，会被主动Cache，只有默认编码。</li><li><strong>POST请求：放在报文体</strong>，无长度限制，可以传输中文。POST请求也可以在请求行中写入数据，这时候类似GET请求，但一般没人会在form action或ajax url中加入这种处理</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html?name=kelvin&amp;password=123456</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,en;q=0.6<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br><span class="language-ini"></span><br></code></pre></td></tr></table></figure><h4 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2. HTTP 响应报文"></a>2. HTTP 响应报文</h4><p>状态行–HTTP响应头–空行–正文（body）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-HTTP-Header"><a href="#3-HTTP-Header" class="headerlink" title="3. HTTP Header"></a>3. HTTP Header</h3><p>HTTP Header中有四种Header Filed：</p><p>通用头：请求头和响应头都可使用字段</p><p><strong>Cache-Control</strong>、Pragma、Date、Via</p><p>Connection：keep-alive&#x2F;close</p><p>实体头：用于定义Entity Body（数据）的一些信息的头字段</p><p>Location（重定向跳转就设置了这个）、</p><p><strong>Content-Type</strong>、Conetent-Encoding（响应内容的压缩）、</p><p>Expire、Allow、Etag（资源标识符）、Last-Modify</p><p><strong>请求头：</strong></p><p>User-Agent、Host、Referer、<strong>Accept</strong>（希望接收的类型）</p><p><strong>响应头：</strong></p><p>Age（在代理服务器中缓存秒数）、Server（提供服务器信息）、Vary</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP缓存也称为Web缓存，主要就是客户端本身的<strong>浏览器本地缓存</strong>和代理服务器缓存（正向代理和反向代理）。<strong>只能缓存GET请求</strong>的内容，缓存css、js、HTML等静态资源</p><p><a href="https://juejin.im/post/5c417993f265da61285a6075">缓存Cache-Control参考</a></p><p>在HTTP1.0时代，pragma和Expires两个头字段可以设置缓存策略。</p><p>到了HTTP1.1以后，又有<strong>Cache-Control</strong>设置缓存策略，HTML meta、动态网页中可以设置。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span>：允许客户端和代理服务器缓存<br><br>private（<span class="hljs-keyword">GET</span>请求默认）：允许客户端缓存<br><br>**<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>**：允许客户端缓存，但每次快取需要由服务器请求缓存是否过期，未过期返回<span class="hljs-number">304</span>。协商缓存<br><br>**<span class="hljs-keyword">no</span>-store：不允许缓存。**<br><br>**max-age=<span class="hljs-number">60</span>**：允许缓存保留<span class="hljs-number">60</span>秒（自带<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>），没有这个属性就会去查找expire。强缓存<br><br>must-revalidate<br></code></pre></td></tr></table></figure><p>这些设置缓存的头字段时通用头字段，当request和response都设置时，Apache或nginx等服务器可以设置听哪个request还是response的。</p><p><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/">浅谈在代理环境中的 DNS 解析行为</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/</url>
    
    <content type="html"><![CDATA[<p>mybatis是一个简单工具根据项目调整编写风格。如何写resultmap也是一个比较简单的，模仿性很强的，学习更好的代码。</p><p>mybatis的作用，我认为最关键的就是结果集映射，将数据库结果集，映射到实体类。两种形式resultType和resultMap。mybatis能算得上是最好的方式吗？</p><h4 id="一对一关联association"><a href="#一对一关联association" class="headerlink" title="一对一关联association"></a>一对一关联association</h4><p>对象一对一依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.Emp&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1. 通过左外连接，连接子表的结果返回到这个association的resultMap里。</span><br><span class="hljs-comment">  如果返回的结果用association中用自定义的映射代替resultMap，association要带一个javaType属性，代表属性类型--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Departments.deptMap&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 2. 通过嵌套查询，将查询的结果返回到这个里面来 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;department_id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;Departments.selectById&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="一对多关联Collection"><a href="#一对多关联Collection" class="headerlink" title="一对多关联Collection"></a>一对多关联Collection</h4><p>对象一对多依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1. 需要在collection里指定resultMap（可以自定义）和ofType，接受左外连接传来的数据</span><br><span class="hljs-comment">使用连接查询，里面不能使用分页，否则collection里数据截断。</span><br><span class="hljs-comment">默认javatype是List，可省略List</span><br><span class="hljs-comment">如果ResultMap的type写util.Map(很少)的话，此时必须指定collection的JavaType--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.mybatis.model.RoleInfo&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;entity.Menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createdate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modifydate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifydate&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select <br>  ram.roleid as id,<br>  ro.name as name,<br>  me.id as menuid,<br>  me.name as menuname,<br>  me.description,<br>  me.parent,<br>  me.createdate,<br>  me.modifydate <br>  from roleandmenu ram<br>  left outer join role ro on ram.roleid=ro.id<br>  left outer join menu me on ram.menuid=me.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 使用嵌套查询，会用column指定的列，作为第二次查询的参数，在这个查询里指定resultType或者ResultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;entity.Role&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select id,name from role<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.mybatis.model.Menu&quot;</span>&gt;</span><br>  select m.id,m.name<br>  from menu m join roleandmenu ram on m.id=ram.menuId<br>  where ram.roleId=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mahoking/article/details/46811865">批量增删改</a></p><h4 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h4><p>mysql<a href="https://blog.csdn.net/mytt_10566/article/details/74279105">主键自增长</a>生成：使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”Employee_id”**，在SQL语句中不写自增长字段。</p><p>可以不用<a href="https://blog.csdn.net/death05/article/details/53098328?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">trim</a>，插入为空就不插入了，但是要指定jdbcType。用trim+if判断空值，不需要指定jdbcType。批量插入parameterType依然写类（类地址？）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;department_id&quot;</span>&gt;</span> <br>  insert into departments(default, department_name) values (#&#123;department_id&#125;,#&#123;department_name&#125;) <br>  // 或者insert into departments(department_name) values (#&#123;department_name, jdbcType=varchar&#125;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="update元素"><a href="#update元素" class="headerlink" title="update元素"></a>update元素</h4><p>不修改的值保持原值，传入一个对象。字符串写判断是否为空字符串或null，传入对象时要带其id</p><p><strong>基本数据类型和对象等数据只需要判断是否为null</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Employee&quot;</span>&gt;</span><br>update employee <br>  //set同样会帮我们忽略最后的“，”<br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    //注意if中的first_name是对象中，不是数据库中<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt;</span><br>      first_name = #&#123;first_name&#125;,<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary!=null &quot;</span>&gt;</span> <br>      salary = #&#123;salary&#125;, <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span> <br>  where employee_id = #&#123;employee_id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="元素"><a href="#元素" class="headerlink" title="&lt;delete&gt;元素"></a>&lt;delete&gt;元素</h4><p>一般使用单ID删除，可以在service层循环ID，带调用单删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parametertyep</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>delete from employee where employee_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int[]&quot;</span>&gt;</span> <br>  delete from employee where employee_id in <br>  <span class="hljs-comment">&lt;!-- collection只能写array或者list，即数组或集合，但是orderIDs --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="元素-1"><a href="#元素-1" class="headerlink" title="&lt;select&gt;元素"></a>&lt;select&gt;元素</h4><p>条件查询，用Map&lt;String, Object&gt;作为传入参数，可以不写parameter</p><p>where 1&#x3D;1？</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;mapper namespace=<span class="hljs-string">&quot;com.lee.Mapper.Employee&quot;</span>&gt;<br>  &lt;select id=<span class="hljs-string">&quot;select&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;Employee&quot;</span>&gt; <br>    select * from employee e left outer join Dept d on e.deptno=d.deptno<br>    <span class="hljs-comment">// 可以用where，mybatis会自动帮我们忽略</span><br>    &lt;trim prefix=<span class="hljs-string">&quot;where&quot;</span> prefixOverrides=<span class="hljs-string">&quot;and | or&quot;</span>&gt; <br>      &lt;!-- first_name是Map中的Key，用#&#123;first_name&#125;获取到value --&gt; <br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> #&#123;first_name&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;job_id!=null and job_id!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">job_id</span> <span class="hljs-operator">=</span> #&#123;job_id&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt; <br>    &lt;/trim&gt; <br>&lt;<span class="hljs-type">if</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;index!=null&quot;</span>&gt;<br>      limit #&#123;index&#125;,#&#123;pageSize&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt; <br>  &lt;/select&gt;<br>  &lt;!-- 计数--&gt;<br>  &lt;select id=<span class="hljs-string">&quot;count&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>    select <span class="hljs-title function_">count</span><span class="hljs-params">(*)</span> from employee<br>    &lt;where&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;firstName !=null and firstname!=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> # &#123;firstName&#125;<br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>  &lt;/select&gt;<br>  <br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h4 id="SQL块"><a href="#SQL块" class="headerlink" title="SQL块"></a>SQL块</h4><p>用SQL块代替常用于字段，一个表中的字段可能很多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empSql&quot;</span>&gt;</span><br>  first_name,job_id,salary,department_id <br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--字段用include动态SQL块代替，类似于alias --&gt;</span><br>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empSql&quot;</span>/&gt;</span> from employe<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js的函数和方法的区别</title>
    <link href="/2021/04/12/front/3.js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/12/front/3.js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天偶尔看到，JS中的函数和方法这两个概念竟然有些许差别😅，在我印象中，大部分编程语言里，函数和方法没有任何区别，大概的意思就是通过名字调用的一段代码，只是C&#x2F;C++中，习惯称为函数（function），Java中习惯称方法（method），而在JS中，我们知道也习惯称function，即函数。</p><p>在vue.js中，经常的一种写法就是，将函数绑定到对象上，大概就是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-attr">getMessage</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>getMessage</code>就是对象hua的一个函数，更确切的，这种<strong>绑定到对象上的函数就是方法</strong>，需要通过<code>hua.getMessage</code>或者<code>hua.getMessage()</code>去调用。ES6对于书写这种函数，推荐写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>今日学习随机</title>
    <link href="/2021/03/30/front/2.js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/03/30/front/2.js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>声明变量作用域方面，var定义的变量作用域是函数级，但是代码块里声明的var变量，代码块外又允许访问（所以var有很多不合理的地方）。let是升级版的var，用来代替var，作用域为标准的代码块级。const是代码块级作用域的常量。</li><li>var能够重复声明变量，而let和const不允许被重复声明。</li><li>并且var声明的变量存在<strong>变量提升</strong>，即在用var声明变量代码之前，函数就可以调用这个变量，默认值为undefined，而let&#x2F;const声明的变量，则会提示变量not defined（let）或者error（const）。</li></ol><h2 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h2><p>在模块化出现之前，js通过script标签直接引入另一个js，引入顺序必须固定，而维护成本高，现在主要的两种js模块化规范。</p><ul><li><p>Common JS模块化规范（nodejs）：require&#x2F;exports</p></li><li><p>ES6模块化规范：<a href="https://www.jianshu.com/p/541256d8abb3">import&#x2F;export</a>。</p></li></ul><p>export你需要导出的变量或者函数，import时需要带{}，而export default导出的变量不需要带{}。export可以导出未声明变量或者函数，export default只能导出已声明的变量、函数、或者匿名模块，一个文件中只能使用一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> name;<br><span class="hljs-keyword">export</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  data : &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br>---<br>b.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">import</span> random,&#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(random.<span class="hljs-property">data</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>在学习vue或者初次看到vue项目时，有一些疑问，比如vue组件、实例、vue文件之间的区别是什么new Vue()操作产生vue实例，组件类似于是可被Vue实例反复引用的。</p><p>vue组件是可复用的vue实例。类似于自定义标签，template属性为编写组件的必须项，props和data属性也较为常用。</p><p>注意编写vue组件时，因为html的自定义属性不能大写，会自动转化成小写，所以注册组件props中的变量，要用小写。</p><p>Vue.component()方法用于全局注册的vue组件，全局组件可以用于所有文件中的new Vue()创建的Vue根实例</p><h3 id="JS驱动vue-js"><a href="#JS驱动vue-js" class="headerlink" title="JS驱动vue.js"></a>JS驱动vue.js</h3><p>此时Vue实例用el元素直接绑定HTML。引入vue.js文件，通过js去直接驱动。用component注册全局组件，组件包含template。</p><p>template中的内容是需要有根节点的</p><h5 id="模块化驱动vue-js"><a href="#模块化驱动vue-js" class="headerlink" title="模块化驱动vue.js"></a>模块化驱动vue.js</h5><p>在js文件中可以import单Vue文件，将Vue文件渲染到的Vue实例上，挂载到指定的HTML上。一般模块化开发中我们只写一个vue根实例。</p><h5 id="单文件组件的优势"><a href="#单文件组件的优势" class="headerlink" title="单文件组件的优势"></a>单文件组件的优势</h5><p>模版语法高亮、全局定义命名不能重复、不支持CSS，而单文件的设置stype的scope属性，css只对单文件生效</p><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><ul><li>默认插槽和具名插槽</li></ul><p>将内容分发权限放到调用的父级，将复杂内容放到父级。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">--- vue 2.6之前:<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>--- vue 2.6后:<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:pre-icon</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中预设位置<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>作用域插槽</li></ul><p>让父组件访问子组件的值的一种插槽，弥补父组件无法获取到子组件变量值的情况。</p><p>（具名&#x2F;默认插槽）和（作用域插槽）是并列关系，是同时可以使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">--- 父组件从子组件中取数据，vue 2.6之前<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>--- vue 2.6后<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中slot绑定变量<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="compute、method、watch"><a href="#compute、method、watch" class="headerlink" title="compute、method、watch"></a>compute、method、watch</h5><p>计算属性能做的，watch都能做。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用npm和yarn遇到的问题</title>
    <link href="/2021/03/29/front/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/29/front/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="使用npm和yarn遇到的问题"><a href="#使用npm和yarn遇到的问题" class="headerlink" title="使用npm和yarn遇到的问题"></a>使用npm和yarn遇到的问题</h4><ol><li><p>关于包管理器npm和yarn</p><p>yarn是在npm的基础之上的包管理器，根据情况选用一个工具即可，都是去读取package.json文件，在一个项目中两者可以同时存在，但是每次构建项目后（初次npm install后），需要固定使用yarn，或者或者npm，当要切换包管理器管理项目时，需要删除node_modules文件夹。</p><p>不同版本的npm管理同一个项目，一般不会出现太大的问题，但是遇到构建问题时，也可以选择删除node_module文件夹和package-lock.json文件。</p><p>遇到一个问题，npm 7构建node旧项目时，会出现构建依赖树冲突问题。</p></li><li><p>node-sass在离线机器上的安装问题</p><p>node-sass还会绕过设置的本地仓库去GitHub去获取，获取不到时会在本地编译，本地编译在win下又依赖python和C++环境，这个问题给我整吐了，怎么也不好解决，尝试过多种方法也无济于事后，找同事在能运行的机器上，拷贝了整个项目先启动看看，后期再去解决npm install安装的问题。</p></li><li><p>vue-cli工具：vue-cli、@vue&#x2F;cli。</p><ul><li>vue init webpack demo。npm run dev</li><li>vue create demo。@vue&#x2F;cli构建的项目，会在本地加入vue-cli-serivice这样的依赖npm serve</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传下载</title>
    <link href="/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>表单上传：type为file类型的input标签<strong>和enctype&#x3D;multipart&#x2F;form-data</strong>上传数据，不做处理，是同步上传。</p></li><li><p>ajax上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#myinput&quot;</span>).<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-comment">// 这两个必写</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>($(<span class="hljs-string">&#x27;#uploadForm&#x27;</span>)[<span class="hljs-number">0</span>]),<br><span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-Servlet纯流方式-SmartUpload或Apache-FileUpload"><a href="#1-Servlet纯流方式-SmartUpload或Apache-FileUpload" class="headerlink" title="1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload"></a>1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload</h4><p>Servlet直接读区获取字节流存储在文件夹，但是无法同时区分普通控件和上传文件</p><p>在Servlet中都能实现上传文件功能简化，实现业务数据和上传的文件同时获取，并且直接write（不需要手动outputStream）</p><p><a href="https://www.jianshu.com/p/e7837435bf4c">FileUpload文件上传参考</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">// 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isMultipart</span> <span class="hljs-operator">=</span> ServletFileUpload.isMultipartContent(req);<br>  <span class="hljs-comment">// 如果不满足要求就立即结束对该请求的处理</span><br>  <span class="hljs-keyword">if</span> (!isMultipart) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// FileItem 是表单中的每一个元素的封装</span><br>    <span class="hljs-comment">// 创建一个 FileItem 的工厂类</span><br>    <span class="hljs-type">FileItemFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskFileItemFactory</span>();<br>    <span class="hljs-comment">// 创建一个文件上传处理器（装饰设计模式）</span><br>    <span class="hljs-type">ServletFileUpload</span> <span class="hljs-variable">upload</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletFileUpload</span>(factory);<br>    <span class="hljs-comment">// 解析请求</span><br>    List&lt;FileItem&gt; items = upload.parseRequest(req);<br>    <span class="hljs-keyword">for</span> (FileItem fileItem : items) &#123;<br>      <span class="hljs-comment">// 判断空间是否是普通控件</span><br>      <span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;<br>        <span class="hljs-comment">// 普通控件</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 上传控件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> fileItem.getContentType();<br>        <span class="hljs-keyword">if</span> (!contentType.startsWith(<span class="hljs-string">&quot;image/&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 实现简单的错误提示</span><br>          req.setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;亲，您上传的文件格式不正确，请重新上传！&quot;</span>);<br>          req.getRequestDispatcher(<span class="hljs-string">&quot;upload.jsp&quot;</span>).forward(req, resp);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果不是图片类型则不再对请求进行处理</span><br>        &#125;<br>        <span class="hljs-comment">// 随机命名文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + <span class="hljs-string">&quot;.&quot;</span> + FilenameUtils.getExtension(fileItem.getName());<br>        <span class="hljs-comment">// 将上传的文件保存到服务器</span><br>        fileItem.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:/&quot;</span>, fileName));<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件上传"><a href="#2-SpringMVC文件上传" class="headerlink" title="2. SpringMVC文件上传"></a>2. SpringMVC文件上传</h4><p>SpringMVC的上传功能封装了FileUpload组件的功能</p><ol><li>配置FileUpload和common-io的依赖、在SpringMVC配置文件中配置MultipartResover（上传解析器）</li><li>SpringMVC Controller：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span><br><span class="hljs-comment">// 使用MultipartFile类，String ename是其他控件信息，request用于获取绝对路径</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile img, Emp emp ,String ename, HttpServletRequest request)</span>&#123;<br><span class="hljs-comment">// img存储到文件夹相对路径(Web程序的部署路径)</span><br><span class="hljs-comment">//1. 获得上传文件的名字,方便在下载时还原这个名字（3.jpg）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> img.getOriginalFilename(); <br><span class="hljs-comment">//.当前应用程序的部署绝对路径下的upload文件夹</span><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-comment">// 判断文件夹是否存在</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br><span class="hljs-keyword">if</span>(!file.exists())&#123;<br>file.mkdir(); <br>  &#125;<br> <br>  <span class="hljs-comment">//3.应付存储文件的名字重复，为文件重命名</span><br>  <span class="hljs-comment">// 先获得文件的后缀名</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">extendsName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>); <br>  <span class="hljs-keyword">if</span>(index!=-<span class="hljs-number">1</span>)&#123;<br>  extendsName = name.substring(index); <br>  &#125;<br>  <span class="hljs-comment">// 生成唯一的名字</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extendsName; <br>  <br>  <span class="hljs-comment">//4.MultipartFile.transferTo方法代替流输入</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file,fileName);<br>  <span class="hljs-keyword">try</span> &#123;<br>    img.transferTo(savePath); <br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(); <br>  &#125;<br><span class="hljs-comment">// 5 存储数据库，这个照片是员工的属性</span><br>  <span class="hljs-comment">// 保存到相对路径</span><br>  emp.setFilePath(<span class="hljs-string">&quot;/upload/&quot;</span>+fileName); <br>  emp.setFileName(name);<br>empService.save(emp);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件下载："><a href="#文件下载：" class="headerlink" title="文件下载："></a>文件下载：</h2><p>a标签在h5的download属性可以通过URL访问到，单独的用控制器下载其实比价少用，真的用的时候可以用流下载</p><p>FormData两种方式定义，append(“myimage”, $(“#myfile”).get(0).files[0]) ）<a href="https://harttle.land/2016/07/04/jquery-file-upload.html">异步上传</a></p><p>cache、processData和contentType为false，防止JQ转码</p><h4 id="1-Servlet纯流方式"><a href="#1-Servlet纯流方式" class="headerlink" title="1. Servlet纯流方式"></a>1. Servlet纯流方式</h4><p><a href="https://www.jianshu.com/p/f450da30f594">纯流文件下载参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">String dataDirectory=req.getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/data&quot;</span>);<br><span class="hljs-comment">// 通过service查询到</span><br>File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dataDirectory, <span class="hljs-string">&quot;secret.pdf&quot;</span>);<br><span class="hljs-keyword">if</span>(file.exists())&#123;<br>  resp.setContentType(<span class="hljs-string">&quot;application/pdf&quot;</span>);<br>  resp.addHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=secret.pdf&quot;</span>);<br>  <span class="hljs-type">byte</span>[] buffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>  FileInputStream fis=<span class="hljs-literal">null</span>;<br>  BufferedInputStream bis=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span>&#123;  <br>    <span class="hljs-comment">// BufferInputStream每次读一块字节相比读一个字节对于文件速度更快。</span><br>    fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>    bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    <span class="hljs-type">int</span> i=bis.read(buffer);<br>    <span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>      os.write(buffer,<span class="hljs-number">0</span>,i);<br>      i=bis.read(buffer);<br>    &#125;<br>  &#125;<span class="hljs-keyword">catch</span>(IOException ioe)&#123;<br>    System.out.println(ioe.toString());<br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-keyword">if</span>(bis!=<span class="hljs-literal">null</span>)&#123;<br>      bis.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fis!=<span class="hljs-literal">null</span>)&#123;<br>      fis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件下载"><a href="#2-SpringMVC文件下载" class="headerlink" title="2. SpringMVC文件下载"></a>2. SpringMVC文件下载</h4><p> 使用spirng 自带的<strong>ResponseEntity</strong>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException&#123;<br>  <span class="hljs-comment">//获取你文件的文件夹，一般从数据库读区，这里模拟service已经取到路径</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getSession().getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1168701023208865792.jpg&quot;</span>; <br>  <span class="hljs-comment">// 1. 获取文件路径</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path,filename); <br>  <span class="hljs-comment">//设置header里的ContentDisposition字段，以attachment(下载框方式)打开图</span><br>  <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>(); <br>  headers.setContentDispositionFormData(<span class="hljs-string">&quot;attachment&quot;</span>, downloadFielName);<br>  <span class="hljs-comment">// 2. ResponseEntity返回，返回application/octet-stream : 二进制流数据(最常见的文件下载)。</span><br>  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-type">byte</span>[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/10/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/2.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/10/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/2.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>^a以a开始</p><p>a$以a结束</p><h4 id="字符代表符号（匹配符）"><a href="#字符代表符号（匹配符）" class="headerlink" title="字符代表符号（匹配符）"></a>字符代表符号（匹配符）</h4><p>[a-z]小写字母、[a-zA-Z0-9]字母和数字</p><p>. 除换行符以外的任意单字符</p><p>\d数字。</p><p>\D非数字</p><p>\w数字，字母或下划线</p><p>\s特殊字符</p><h4 id="数量限定符"><a href="#数量限定符" class="headerlink" title="数量限定符"></a>数量限定符</h4><p>{5}： 前面的一个字符出现5次{1,}：1次以上。{1,3}：1次到3次</p><p>*前面的一个字符出现0次以上</p><p>+前面的一个字符出现1次以上</p><p>？前面的一个字符出现0次或1次</p><h3 id="前瞻和后顾"><a href="#前瞻和后顾" class="headerlink" title="前瞻和后顾"></a>前瞻和后顾</h3><p>正则表达的前后，还未解析字符的称为前面，解析过的称为后面</p><p>a(?&#x3D;b)前瞻，匹配a，且a必须在b的前面</p><p>a(?!b)负前瞻，匹配a，且a的前面不是b</p><p>(?&lt;&#x3D;b)a后顾，匹配a，且a的后面b</p><p>(?&lt;!b)a负后顾，匹配a，且a的后面不是b</p><p>|分成两段，或者</p><p>()圈定一个子串</p><h2 id="JS使用正则表达式"><a href="#JS使用正则表达式" class="headerlink" title="JS使用正则表达式"></a>JS使用正则表达式</h2><p><strong>var regexp &#x3D; &#x2F;正则表达式&#x2F;修饰符</strong>，</p><p>修饰符有i（不区分大小写）和g（全局匹配）</p><p><strong>匹配：regexp.test(str)</strong></p><h2 id="Java使用正则表达式"><a href="#Java使用正则表达式" class="headerlink" title="Java使用正则表达式"></a>Java使用正则表达式</h2><p>Pattern.complile(“”)创建正则对象</p><ul><li><p>匹配验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^[0-9a-zA-Z]\\.&#123;5,10&#125;@[0-9a-zA-z]&#123;2,7&#125;(\\.com|.cn)&quot;</span>)<br>p.matcher(str).matches() <span class="hljs-comment">//Match对象</span><br></code></pre></td></tr></table></figure></li><li><p>以一个正则表达式拆分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br>String[ ] s = p.split(str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>  System.out.print(s[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>  结果为ABCDEF<br></code></pre></td></tr></table></figure></li><li><p>替换里面的字符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(str);<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> m.replaceAll(<span class="hljs-string">&quot;-&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本编码</title>
    <link href="/2020/10/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/1.%E7%BC%96%E7%A0%81/"/>
    <url>/2020/10/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/1.%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>通常所说的乱码问题，是指文本文件乱码（非二进制文件），文本乱码的本质是解析的字符编码与文本本身字符编码不匹配导致的。</p><h2 id="1-字符集和字符编码"><a href="#1-字符集和字符编码" class="headerlink" title="1. 字符集和字符编码"></a>1. 字符集和字符编码</h2><ol><li><p>文本文件：通过字符编码（如UTF-8）保存的文件，如数字64，文本文件会将64解析成’6’和’4’两个字符，再根据字符集编码，再存储到硬盘中</p></li><li><p>二进制文件（狭义上的非文本文件）：保留数据本身二进制的文件，数字64，如Java的int型数字64，直接储存64的二进制到硬盘中</p></li></ol><p>字符集规定了字符在字符表的位置，在文本文件的存储过程中，文本会依靠字符集规则转化成字符，其中最著名的就是ASCII字符集和Unicode字符集。</p><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>ASCII既是世界上第一个字符集（charset），同时又规定了字符编码（encoding）。</p><p>ASCII字符编码用一个字节（7位容器）来表示一个字符，ASCII中一共有127个字符（0-126）。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>地球上字符太多，ASCII字符集的单字节无法表示，所以出现了Unicode字符集。最初时UTF-16编码来实现Unicode字符集，用2个或4个字节来保存。</p><ul><li><p>UTF-16：用两个或者四个字节（<strong>Java char类型用的2字节的UTF-16 LE</strong>），四字节称为UTF-16 BE</p></li><li><p>UTF-32：用四个字节</p></li><li><p>UTF-8：1～4个字节，1个字节时与ASCII编码相同，常见<strong>汉字一般3字节</strong></p></li></ul><h3 id="ISO-8859-1-（Latin-1）"><a href="#ISO-8859-1-（Latin-1）" class="headerlink" title="ISO-8859-1 （Latin 1）"></a>ISO-8859-1 （Latin 1）</h3><p>同样是ASCII码的超集，用一个字节（8位容器）实现255节。在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。mysql默认就采用他</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>一般汉字2字节。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html">Java中存在的编码问题</a></p><h2 id="2-Content-Type与前后编解码"><a href="#2-Content-Type与前后编解码" class="headerlink" title="2. Content-Type与前后编解码"></a>2. Content-Type与前后编解码</h2><p>开发过程中，设定HTTP请求和返回报文中的Content-Type是保证文本不乱码正常解析的最重要保障。</p><h3 id="浏览器解码顺序："><a href="#浏览器解码顺序：" class="headerlink" title="浏览器解码顺序："></a>浏览器解码顺序：</h3><ol><li><p>根据服务器返回的Content-Type中指定的编码解码。</p></li><li><p>根据meta标签的charset。</p></li><li><p>根据浏览器设定的编码解码（跟随浏览器设定，一般中文系统为GBK）</p></li></ol><h3 id="浏览器编码顺序和Content-Type："><a href="#浏览器编码顺序和Content-Type：" class="headerlink" title="浏览器编码顺序和Content-Type："></a>浏览器编码顺序和Content-Type：</h3><ul><li><p>POST请求的编码：默认UTF-8，<strong>ajax请求强制数据为UTF-8编码，即使在contentType中设置的编码也不生效</strong>，所以对于发送ajax请求，直接写application&#x2F;json，然后设置服务器对所有请求数据使用UTF-8解析：request.setCharactorEncoding(“UTF-8”)。</p><ul><li><p>Ajax POST默认contentType: application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8。</p></li><li><p>form POST默认的contentType: application&#x2F;x-www-form-urlencoded</p><p><strong>form POST的编码也是UTF-8，但是不会在Content-Type中声明</strong></p></li></ul></li><li><p>GET请求的编码：默认UTF-8（不指定Content-Type，一般传输不了中文）</p></li></ul><h3 id="服务器解码顺序："><a href="#服务器解码顺序：" class="headerlink" title="服务器解码顺序："></a>服务器解码顺序：</h3><ol><li><p>使用requst.setCharactorEncoding( )指定的编码解码。</p></li><li><p>根据客户端发送的Content-Type中的编码解码。</p></li><li><p>使用默认的UTF-8解码</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 设置Content-Type作用与于GET请求<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">useBodyEncodingForURI</span> = <span class="hljs-string">&quot;true&quot;</span> &gt;</span> <br> // 设置GET请求使用UTF-8解码, Tomcat 8以后这个默认值已经是UTF-8，<br> // 注意：request.setCharactorEncoding对GET请求不生效。<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">URIEncoding</span> =<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span> <br></code></pre></td></tr></table></figure><h3 id="服务器编码顺序和Content-Type："><a href="#服务器编码顺序和Content-Type：" class="headerlink" title="服务器编码顺序和Content-Type："></a>服务器编码顺序和Content-Type：</h3><ol><li><p>response.setContentType(“application&#x2F;json; charset&#x3D;UTF-8”)，respnse.setCharactorEncoding()</p></li><li><p>Servlet response的默认编码是UTF-8</p></li><li><p>JSP会默认Content-Type：</p><p>JSP的编码只受到Page指令的contentType&#x2F;pageEncoding命令约束，而且这两个命令对于JSP生成的Content-Type决定权最高。</p><p>response.setCharactorEncoding方法：设置返回数据的编码</p><p>response.setContentType方法：设置Servlet返回数据的编码和返回数据的Content-Type。<strong>setContentType方法优先级最高</strong>，在此方法前后出现setCharactorEncoding()，数据会按照Content-Type编码。</p></li></ol><ul><li>注解设置注解设置：@RequestMapping(value &#x3D; “”, <strong>produces&#x3D;”application&#x2F;json;charset&#x3D;UTF-8”</strong>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乱码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
