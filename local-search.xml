<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库加索引</title>
    <link href="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>数据库有3种方式创建索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 这种方式建立索引最简单，但是表中需要有数据，否则索引建立失败<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> lmt_crdt_app <span class="hljs-keyword">ADD</span> INDEX idx_cust_name(cust_name);<br># 通过<span class="hljs-keyword">create</span> INDEX<br><span class="hljs-keyword">CREATE</span> INDEX idx_cust_name <span class="hljs-keyword">ON</span> lmt_crdt_app(cust_name);<br># 可以在建表时，在所有字段的最后，加上索引 INDEX idx_cust_name(cust_name);<br></code></pre></td></tr></table></figure><p>最常见的是普通索引（<strong>INDEX</strong>），上面代码中创建的就全是普通索引</p><p>还有一种索引是唯一索引（<strong>UNIQUE INDEX</strong>），创建唯一索引在普通索引的INDEX前加一个UNIQUE标识就行了。他的值必须要唯一，如给“电子邮件”这个字段加上唯一索引，那么每一个电子邮件都不能够重复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用brew去管理一些后台进程</title>
    <link href="/2022/03/24/%E5%85%B6%E4%BB%96/8.%20Mac%E7%9A%84%E5%B0%8F%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/03/24/%E5%85%B6%E4%BB%96/8.%20Mac%E7%9A%84%E5%B0%8F%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>brew对于命令行的程序，起到一个打包编译的作用，ARM版的brew通常只能安装ARM版的程序。</p><p>brew常用的命令brew list&#x2F;search&#x2F;info&#x2F;intall&#x2F;unintall&#x2F;deps&#x2F;outdated&#x2F;update&#x2F;upgrade等。</p><p>在命令前加入<code>arch -x86_64</code>模拟x86环境运行。</p><p>建议brew安装mysql&#x2F;redis，且推荐安装以后使用<code>brew services</code>来管理服务的启动和关闭。以mysql为例，<code>brew services start mysql</code>和<code>mysql.server start</code>同样可以启动mysql，要注意brew的启动在重启后不会失效，使用brew有利于统一多服务的管理。</p><h3 id="macOS多版本-node"><a href="#macOS多版本-node" class="headerlink" title="macOS多版本 node"></a>macOS多版本 node</h3><p>可以使用nvm和n这样常用的node管理工具来管理安装，也可以使用node link&#x2F;unlink不同的node版本</p>]]></content>
    
    
    <categories>
      
      <category>Mac相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GIT要注意的几个问题</title>
    <link href="/2022/03/09/%E5%85%B6%E4%BB%96/5.%20GIT/"/>
    <url>/2022/03/09/%E5%85%B6%E4%BB%96/5.%20GIT/</url>
    
    <content type="html"><![CDATA[<p>Git的commit版本是整个库的版本，不是单独具体到某个文件的版本，处于不同commit的文件，可能就是相同的。</p><p>Git有三大分区，工作区、暂存区和版本库。文件add后，存在于stage区中（暂存区），通过commit到版本库。</p><h4 id="关于切换分支的问题"><a href="#关于切换分支的问题" class="headerlink" title="关于切换分支的问题"></a>关于切换分支的问题</h4><p>切换分支时，如果暂存区中有文件在修改，会有两个情况。第一种是两个分支里的文件内容相同时，checkout切换分支会将暂存区中的修改内容保留；第二种情况是两个分支里的文件就不同时，会提示禁止checkout（-f 强制切换时，会丢失修改内容），此时不想commit，可以使用<code>git stash push</code>，临时存储暂存区修改，push通常省略，使用<code>git stash pop</code>恢复最后一次stash的暂存区。</p><h4 id="pull、push"><a href="#pull、push" class="headerlink" title="pull、push"></a>pull、push</h4><p>pull相当于fetch+merge操作。</p><p>本地和远程的相同分支，本质上是两个分支，pull相当于现将远程分支merge到本地merge，合并规则和本地之间的不同分支是相同的。</p><p><strong>与远程分支同步时</strong>，如果本地有暂存区修改，一定要<strong>先commit，再pull，再push</strong>。</p><p>merge过程中，暂存区不会修改，IDEA的merge过程，远程分支别人已经修改过一版，此时pull正常merge到本地，再commit，可能会将别人的代码覆盖而Git不会出现任何提示，而先commit，再pull，过程中Git会提示解决冲突。本地解决完冲突后，最好再次pull，再push。</p>]]></content>
    
    
    <categories>
      
      <category>GIT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA出现</title>
    <link href="/2022/03/09/%E5%85%B6%E4%BB%96/7.IDEA%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/09/%E5%85%B6%E4%BB%96/7.IDEA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>出现找不到常量符号的报错，本次做的是删除target下的文件夹，更改编译版本到7</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/03/09/%E5%85%B6%E4%BB%96/6.%20HTTP/"/>
    <url>/2022/03/09/%E5%85%B6%E4%BB%96/6.%20HTTP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>HTTP协议</p><p>在<strong>TCP&#x2F;IP四层网络结构（应用层，传输层TCP&#x2F;UDP，网络层IP，网络接口层）</strong>中。OSI七层</p><p>发送端在层与层间传输数据时，每经过一层都会被加上网络层的首部信息，接收端每经过一层都会删除一条当前网络层的首部信息。</p><p>HTTP1&#x2F;2是<strong>基于TCP&#x2F;IP</strong>应用层的协议（<a href="https://zhuanlan.zhihu.com/p/68012355">HTTP3基于UDP</a>），最初只用来传输HTML且只有GET方法，97年的1.1版本用了将近20年，2015年诞生了HTTP 2。</p><ul><li><p><strong>无连接</strong>；<strong>即请求时连接，请求完释放连接</strong>，服务器收到请求，返回响应，服务器收到应答，断开连接。</p><p>无连接设计之初目的是为了不占用网络资源，如果一个网页有包含许多请求（如很多图片），多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消</p></li><li><p><strong>无状态</strong>：<strong>每个HTTP报文是独立的</strong>，服务器对于前面请求处理的信息，后面请求不能直接获取到前面请求中的信息。</p><p>设计之初降低了服务器的压力，但是在动态Web时代，无状态特性阻碍了应用程序的实现。于是产生了记录状态的<strong>Cookie和Session</strong>。</p><p><strong>Cookie</strong>：会话保存在客户端，Cookie只能保存是字符串（4KB），切勿保存重要数据，<strong>默认浏览器关闭时清除session</strong>，除非服务端设置setMaxAge。一个cookie就是一个（String，String），使用request.getCookies()获得一个cookie数组，getName()获得cookie的name，getValue获得cookie的value</p><p><strong>Session</strong>：会话保存在服务器，在调用getSession时创建，判断cookie中有无sessionid，无就生成sessionID，定义一个会话状态，并将sessionid通过Cookie发送给浏览器。</p><p>restful的前后端分离项目中一般会使用 access_token，因为前后端分离项目跨域，使用cookie里的sessionID不方便认证状态，这个token和session_id是一个意思。<a href="https://juejin.im/entry/5bd921fce51d45686d40b2d6">分离Cookie参考</a></p><p><a href="https://blog.csdn.net/hxfghgh/article/details/82840613">关于Cookie</a></p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/24860273">TCP和UDP</a></p><h2 id="HTTP报文解析"><a href="#HTTP报文解析" class="headerlink" title="HTTP报文解析"></a>HTTP报文解析</h2><p><strong>Start line 起始行 — Header Filed 头部字段 — 空行 — Entity Body 实体主体</strong></p><p>起始行和头部字段构成HTTP报文头部（Headers）</p><h3 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1. HTTP 请求报文"></a>1. HTTP 请求报文</h3><p><strong>请求行–HTTP头字段–空行–请求体</strong></p><p>浏览器只支持POST和GET这两种请求方法，实际上还有HEAD，TRACE，PATCH，PUSH等请求方法。一般纯查询请求可以使用GET，其他请求用POST。由于只能是ASCII编码，所以GET不能传输中文</p><ol><li>**GET请求：放在请求行(URL)**，会暴露在地址栏，有长度限制，会被主动Cache，只有默认编码。</li><li><strong>POST请求：放在报文体</strong>，无长度限制，可以传输中文。POST请求也可以在请求行中写入数据，这时候类似GET请求，但一般没人会在form action或ajax url中加入这种处理</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html?name=kelvin&amp;password=123456</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,en;q=0.6<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br><span class="language-ini"></span><br></code></pre></td></tr></table></figure><h3 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2. HTTP 响应报文"></a>2. HTTP 响应报文</h3><p><strong>状态行–HTTP头–空行–响应体</strong></p><p>这个http响应的响应正文时纯文本，可以时html等等</p><p>Etag，Vary: User-Agent，Cache-Control等都是常用的响应头设置</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><span class="hljs-attribute">Pragrma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Thu, 01 Jan 1970 00:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Proxy-Connection</span><span class="hljs-punctuation">: </span>Keep-alive<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br><span class="language-css"></span><br></code></pre></td></tr></table></figure><h3 id="3-HTTP-Header"><a href="#3-HTTP-Header" class="headerlink" title="3. HTTP Header"></a>3. HTTP Header</h3><p>HTTP Header中有四种Header Filed：</p><p>通用头：请求头和响应头都可使用字段</p><p><strong>Cache-Control</strong>、Pragma、Date、Via</p><p>Connection：keep-alive&#x2F;close</p><p>实体头：用于定义Entity Body（数据）的一些信息的头字段</p><p>Location（重定向跳转就设置了这个）、</p><p><strong>Content-Type</strong>、Conetent-Encoding（响应内容的压缩）、</p><p>Expire、Allow、Etag（资源标识符）、Last-Modify</p><p><strong>请求头：</strong></p><p>User-Agent、Host、Referer、<strong>Accept</strong>（希望接收的类型）</p><p><strong>响应头：</strong></p><p>Age（在代理服务器中缓存秒数）、Server（提供服务器信息）、Vary</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP缓存也称为Web缓存，主要就是客户端本身的<strong>浏览器本地缓存</strong>和代理服务器缓存（正向代理和反向代理）。<strong>只能缓存GET请求</strong>的内容，缓存css、js、HTML等静态资源</p><p><a href="https://juejin.im/post/5c417993f265da61285a6075">缓存Cache-Control参考</a></p><p>在HTTP1.0时代，pragma和Expires两个头字段可以设置缓存策略。</p><p>到了HTTP1.1以后，又有<strong>Cache-Control</strong>设置缓存策略，HTML meta、动态网页中可以设置。</p><pre><code class="hljs">public：允许客户端和代理服务器缓存private（GET请求默认）：允许客户端缓存**no-cache**：允许客户端缓存，但每次快取需要由服务器请求缓存是否过期，未过期返回304。协商缓存**no-store：不允许缓存。****max-age=60**：允许缓存保留60秒（自带no-cache），没有这个属性就会去查找expire。强缓存must-revalidate</code></pre><p>这些设置缓存的头字段时通用头字段，当request和response都设置时，Apache或nginx等服务器可以设置听哪个request还是response的。</p><p><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/">浅谈在代理环境中的 DNS 解析行为</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础整理</title>
    <link href="/2022/03/07/Java/1.%20Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/07/Java/1.%20Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="流程语法"><a href="#流程语法" class="headerlink" title="流程语法"></a>流程语法</h2><ul><li><p>break跳出控制语句（switch，for等），continue跳出本次循环（用于for循环），return跳出整个函数</p></li><li><p>在判断语句中，<strong>单纯判断、char、byte、short、int和String（JDK 7 ）的值情况</strong>可以用switch代替if-else<br>switch效率比if-else高，但是灵活度非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    System.out.println(<span class="hljs-string">&quot;this is one.&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    System.out.println(<span class="hljs-string">&quot;Others.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="包与访问权限"><a href="#包与访问权限" class="headerlink" title="包与访问权限"></a>包与访问权限</h2><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>包是为了管理类而存在，不同包可以存在相同的类名，包的逻辑结构代表class文件的文件夹逻辑结构。当我们需要使用非本包中的类时，用<strong>import关键字</strong>导入包中的类，导包<strong>可以导入包中的具体类或者用通配符导入所有类</strong></p><ul><li><p>普通导入</p><p>import com.zhuxin.*导入com.zhuxin包中所有的类<br>import com.zhuxin.Demo导入com.zhuxin包中的Demo类</p></li><li><p><strong>静态导入</strong>（JDK5），导入后直接可使用静态属性，而不用使用System.out这样调用属性</p><p>import static java.lang.System.out 导入System类中的out属性</p><p>import static java.lang.Integer.* 导入Integer类中的所有静态属性</p></li></ul><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ul><li><p><strong>类的访问权限</strong>，比较少使用，default权限的类，导包后也无法使用</p><ol><li>不加权限（default）：修饰的类只能在本包中使用</li><li>public：修饰的类在导包后，能在所有包中使用</li></ol></li><li><p><strong>属性与方法的访问权限</strong></p><p>约束成员在其他类中建立对象以后，对象能否调用其方法和属性看其属性和方法的访问权限，方法定义的局部变量是不能被访问权限控制的。</p><ol><li><p>private：除了在本类中，均不能被访问(即使是继承了父类的子类)</p></li><li><p>不加权限（default&#x2F;friendly）：可以被同包的类访问，又称为包级访问权限</p><p>普通类&#x2F;抽象类的方法和属性不写时默认都是包级访问权限</p></li><li><p>protected：可以被同包类和不同包子类访问</p></li><li><p>public：可被所有包的类访问</p><p>接口中的所有方法（抽象，default，static）和属性只能是public权限，默认不写</p></li></ol></li></ul><h2 id="Java常用关键字"><a href="#Java常用关键字" class="headerlink" title="Java常用关键字"></a>Java常用关键字</h2><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this关键字是JVM在创建对象后产生的一个指向对象本身的一个指针，根据这个原理，得出this的作用</p><ol><li><p>this.属性&#x2F;方法：<strong>强调本类的成员属性或成员方法</strong>，内部类中的this强调内部类本身的成员属性和方法</p><p>子类重写父类方法后，父类的this.方法会指向子类重写过的方法（不加this也是）。</p><p>子类覆盖父类属性后，父类的this.属性始终指向父类属性（不加this也是）</p></li><li><p>this()：<strong>在构造方法中调用本类的其他构造方法，注意必须写在构造方法第一行。</strong></p><p>场景举例：写一个包含所有字段的构造函数，然后其他部分字段构造函数去调用这个全字段构造函数</p></li><li><p>this：<strong>代指当前对象</strong>，返回调用this的实例对象</p><p>比如父类方法中存在return this，父类对象调用这个方法返回父类对象，子类对象调用这个方法，返回子类对象</p></li></ol><h3 id="Super关键字"><a href="#Super关键字" class="headerlink" title="Super关键字"></a>Super关键字</h3><ol><li><p>super.属性&#x2F;方法：当子类和父类中存在<strong>相同的属性或方法</strong>时，<strong>强调当前对象父类中的属性和方法</strong></p></li><li><p>super()：<strong>在子类构造方法中，调用父类构造方法。super方法必须写在构造方法的首行，不能和this()一同使用</strong></p><p>子类构造方法默认在第一行使用了super()调用了父类中的无参构造方法。如果父类不存在无参构造方法将会报错，注意给父类编写带参构造方法后需要注意再编写一个无参构造方法。</p></li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol><li>被final<strong>修饰的类不能被继承</strong>，一般很少将类设计为final类，除非真的不需要继承或者为了安全考虑。</li><li>修饰的变量为不可更改的常量（修饰基本数据类型值不能改变，修饰引用类型不能更改指向的对象，引用不是对象，String对象值不能改变说的就是这个理）</li><li>被final<strong>修饰的方法不能被子类重写</strong>，明确禁止子类重写此方法时才用final修饰方法，类的private方法会隐式地被指定为final方法。</li></ol><h3 id="static关键字（类方法，类属性）"><a href="#static关键字（类方法，类属性）" class="headerlink" title="static关键字（类方法，类属性）"></a>static关键字（类方法，类属性）</h3><p>static修饰的属性（不能修饰局部变量）和方法，成为静态属性或静态方法，静态方法和静态属性属于类，不依赖与某个对象，可以直接<strong>通过类名调用静态属性和静态方法</strong>，但遵循访问权限控制。<strong>静态方法只能直接调用静态变量和静态方法</strong>，所以在Main使用方法，要么是静态方法，要么是通过对象调用的普通方法。</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ol><li><p><strong>全局变量：定义在方法外的变量，有默认值</strong>，分为成员变量和静态变量：</p><ul><li>*成员变量（实例变量）**定义在类的所有方法外。加载在堆内存中，随着对象产生或消亡；</li><li><strong>静态变量（类变量）</strong>，成员变量基础上加用static关键字修饰属性，类加载（class文件读取到内存中）时产生，存在时间比所在对象本身还要久。</li></ul></li><li><p><strong>局部变量：定义在方法中的变量，如main方法中定义的变量就是局部变量，无默认值，使用前必须要初始化。</strong></p><p>局部变量的创建在栈内存中，随着方法产生和消亡，即随线程产生或消亡</p></li></ol><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><h4 id="重载-overloadding"><a href="#重载-overloadding" class="headerlink" title="重载(overloadding)"></a>重载(overloadding)</h4><p><strong>返回值和方法名不变，参数变化形成新的方法。</strong></p><p>当没有对构造方法进行重载时，默认带一个无参构造方法，当对构造方法重载了一个有参数构造方法后，无参构造方法小时，</p><p>可变长度参数（如String… args）：0个或多个参数</p><p>使方法的参数列表内可以传入不定长度的参数，只能有一个可变长参数且放于所有参数后面，在要实现不定长度参数的类型后加 **…**。Java的可变参数在编译为字节码后，在方法签名中就是以数组形态出现的（将几个参数打包成数组），所以二者同时不可重载</p><h4 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h4><p>重写方法是继承性的重要性质，重写的方法<strong>返回值，方法名和形参都不能改变，子类重写方法访问权限不能比父类方法严格</strong>。</p><p>重写方法后不仅使用方法时会指向子类重写方法，而且子类和父类的方法（加不加this都是）调用都指向子类的重写方法，即使在父类方法中使用this.方法。</p><p>属性不存在重写，一般说覆盖，覆盖后父类方法（加与不加this都是）永远调用的是父类属性，子类方法调用的是子类的属性。</p><h1 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h1><h2 id="1-封装性"><a href="#1-封装性" class="headerlink" title="1. 封装性"></a>1. 封装性</h2><p>面向对象的核心思想之一就是封装性（Encapsulation），封装就是将属性和方法这些具像的东西“装”到一个类中，私有化属性，<strong>提高安全性</strong>，<strong>隐藏实现细节</strong>。</p><p>我们使用API或者各种框架时，封装性使得我们忽略实现细节，只要去使用即可。</p><h2 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h2><p>子类extents父类，获得父类的属性和方法（除private属性和方法），并<strong>通过重写方法和增加新方法，形成新的类，复用父类的代码</strong>，这就是OOP中的继承性的作用。C++使用多继承，Java支持单继承（Single inheritance）。</p><p>静态方法没有重写，类似于属性写了一个同名属性</p><p>实用证明，继承关系（class-based）确实会带来一些代码量的减少，但是带来了子父类的强耦合，所以更现代的流派更推荐使用组合关系（prototype-based），也就是像Java的接口一样，Go语言已经完全采用prototype-based关系。</p><h4 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h4><p>内部类是一个编译时的概念，<strong>编译完成以后成为两个不同类</strong>。内部类增强了Java多重继承功能。内部类中的this关键字指的内部类成员属性和方法，外部类名.this才是强调外部内的成员属性和方法。<strong>内部类可以直接调用外部类的private属性。</strong></p><p><strong>成员内部类</strong>、局部内部类（写在方法中）、<strong>匿名内部类（创建的时候，只能用外部的final属性）</strong>、</p><p><strong>静态内部类（static关键字，只能访问外部类static属性，可以脱离外部类创建）</strong>。</p><p>当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现（）。</p><p>在外部类方法中使用new关键字创建内部类对象。</p><p>外部类.内部类 对象名 &#x3D; new 外部类( ).new 内部类( )</p><p>内部类 对象名 &#x3D; 外部类对象.new 内部类( )</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是特殊的类，用abstract声明，<strong>至少含一个抽象方法</strong>。由于没有足够的信息来构造一个具体的对象时，所以与普通类的区别是<strong>不能被直接实例化</strong>，<strong>必须被继承才能实例化</strong>，但是可以像普通类一样<strong>单继承类，多继承接口</strong>。</p><p><strong>抽象方法：用abstract修饰方法且无方法体的方法（可以为protect和public）</strong>，抽象类可以没有抽象方法，有抽象方法的抽象类被继承时，子类必须实现抽象方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口也是一种特殊的类，用interface声明接口类，用implement来声明实现接口。</p><p>接口是功能的集合，<strong>接口的设计是主要为了多态性</strong>，应该选择接口来实现多态性，。</p><p><strong>接口的属性只能静态全局常量</strong>（默认不写public static final），接口方法<strong>一般是公有抽象方法</strong>（默认可写public abstract）。</p><p>Java8以后，接口方法可以是<strong>default method和static method</strong>，这使得接口和抽象类很像，default一般用于老接口的拓展。static方法一般通过接口类来调用。一般不推荐再方法中使用这两种方法</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>Java中存在3种类，普通类，抽象类和接口。抽象类在继承方面的特性和普通类一样。</p><ul><li><p>普通类&#x2F;抽象类只能继承一个普通类&#x2F;抽象类（单继承），但可以实现多个接口（多继承）</p><p>抽象类实现接口时，<strong>不强制抽象类实现接口中的抽象方法</strong>，留给继承这个抽象类普通类去实现。</p></li><li><p>接口可以多继承接口，<strong>当普通类实现子接口时，强制实现类重写子接口和父接口中的所有抽象方法</strong></p><p>Java接口继承层级越多，功能就越多。</p></li></ul><p>实例化子类时，会先初始化父类（非实例化创建对象，那调用的时什么方法），继承的父类的属性和方法是相对独立存在的</p><h2 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3. 多态性"></a>3. 多态性</h2><p>Java中的多态是一个父类类型对不同子类对象同一方法的不同响应，解耦合</p><ul><li><strong>对象 instanceof 类</strong>：返回布尔值 对象是这个类或者类的子类时，返回true</li><li>各种地方（工厂、IO、Service）多态父类或者父接口接受子类对象，就实现了去耦合。只需要改他的实现</li><li>向下转型（downcast）：父类引用重新强转回子类。当父类对象要调用子类的独有方法时需要向下转型</li></ul><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52191321">多态原理</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务</title>
    <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>事务是一组原子性的SQL语句，在 MySQL 中只有使用了Innodb 数据库引擎才支持事务。Java中编程式事务connection&#x2F;sqlsession来操作事务</p><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p>一次增删改，加排他锁（一般行锁）和GAP锁（间隙锁，innodb_locks_unsafe_for_binlog），并且会自动提交事务，事务完毕，才会释放锁给其他拿到。</p><p>乐观锁和悲观锁是一种思想，乐观锁适合读多写少，悲观锁适合写多读少。<a href="https://juejin.im/entry/5b63d9056fb9a04fcb5b7ff9">mysql悲观锁</a>：</p><ul><li><p>行锁，拿行锁之前，数据库会自动拿到<a href="https://www.zhihu.com/question/51513268">意象锁</a>，表级锁</p><p>共享锁&#x2F;读锁（S锁，Shared Lock）：lock in share mode</p><p>排他锁&#x2F;写锁（X锁，Exclusive Lock）：for update</p></li></ul><p>禁止&#x2F;开启自动提交：<strong>SET AUTOCOMMIT&#x3D;0&#x2F;1</strong></p><p>显式的开启事务：<strong>BEGIN</strong>或者<strong>START TRANSCATION</strong>；写SQL；<strong>COMMIT</strong></p><p>设置保存点：<strong>SAVEPOINT 保存点名</strong>：</p><p>回滚：<strong>ROLLBACK</strong>：未commit前使用，回滚到事务最开始的地方。ROLLBACK TO 保存点名：可以回退到位置</p><p>设置隔离级别：SET session&#x2F;global <strong>TRANSCATION ISSOLATION LEVEL</strong> ，</p><p>查看事务隔离级别：SELECT @@tx_isolation;</p><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><p>不同隔离级别下的加锁方式是不同的。<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">mysql事务下的锁机制(美团)</a>、<a href="https://blog.csdn.net/lemon89/article/details/51477497">参考文2</a>、<a href="https://dbaplus.cn/news-11-2518-1.html">数据库的锁机制</a></p><ul><li><p>READ-UNCOMMITTED：最低隔离级别</p><p>任何情况都不加锁，并且其他事务没有提交前就可以被读到值</p></li><li><p>READ-COMMITTED：</p><p>读不加锁，但其他事务增删改需要commit以后才能读到值；增删改加排他锁（条件有索引加行级锁，无索引加表级锁）</p></li><li><p>REPEATABLE-READ：Innodb默认级别，可重复读取本次事务中多次读同一个数据时，</p><p>普通读（MVVC快照读）不加锁，如果事务内没有增删改操作，则不会刷新读的版本</p><p>update &#x2F;select …… for update（当前读）&#x2F;delete 这些操作，进行的是当前读，然后加锁。</p><p>三种锁（默认都X锁）：Record行级锁、GAP间隙锁、Next-Key锁</p><p>唯一索引，只对记录加行锁；非唯一索引加三种锁；where &lt;、&gt;和between，只会加GAP锁；</p></li><li><p>SERIALIZABLE：串行级别</p><p>数据库完全使用悲观锁，读用读锁，写用写锁。</p></li></ul><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据可能会不同，因为其他人提交。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h3 id="ACID事务"><a href="#ACID事务" class="headerlink" title="ACID事务"></a>ACID事务</h3><p>原子性（要么都执行，失败回滚）、隔离性（并发事务隔离）、一致性（一个状态转化另一个状态，但数据完整性一致）、持久性（事务完整，数据库改动是永久的）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库复杂查询</title>
    <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>数据库查询最常用的是连接查询，格式上类似<code>select * from A left join B on A.no=B.no</code>，连接的A表和B表也常为子查询</p><p>本金、利息、罚息（逾期后，本金*罚息利率）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/</url>
    
    <content type="html"><![CDATA[<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><h4 id="resultType和resultMap："><a href="#resultType和resultMap：" class="headerlink" title="resultType和resultMap："></a>resultType和resultMap：</h4><p>select方法取到的结果集可以直接被映射，两种形式resultType和resultMap。</p><h4 id="一对一关联association"><a href="#一对一关联association" class="headerlink" title="一对一关联association"></a>一对一关联association</h4><p>对象一对一依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.Emp&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1. 通过左外连接，连接子表的结果返回到这个association的resultMap里。</span><br><span class="hljs-comment">  如果返回的结果用association中用自定义的映射代替resultMap，association要带一个javaType属性，代表属性类型--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Departments.deptMap&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 2. 通过嵌套查询，将查询的结果返回到这个里面来 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;department_id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;Departments.selectById&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="一对多关联Collection"><a href="#一对多关联Collection" class="headerlink" title="一对多关联Collection"></a>一对多关联Collection</h4><p> 对象一对多依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1. 需要在collection里指定resultMap（可以自定义）和ofType，接受左外连接传来的数据</span><br><span class="hljs-comment">使用连接查询，里面不能使用分页，否则collection里数据截断。</span><br><span class="hljs-comment">默认javatype是List，可省略List</span><br><span class="hljs-comment">如果ResultMap的type写util.Map(很少)的话，此时必须指定collection的JavaType--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.mybatis.model.RoleInfo&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;entity.Menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createdate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modifydate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifydate&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select <br>  ram.roleid as id,<br>  ro.name as name,<br>  me.id as menuid,<br>  me.name as menuname,<br>  me.description,<br>  me.parent,<br>  me.createdate,<br>  me.modifydate <br>  from roleandmenu ram<br>  left outer join role ro on ram.roleid=ro.id<br>  left outer join menu me on ram.menuid=me.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 使用嵌套查询，会用column指定的列，作为第二次查询的参数，在这个查询里指定resultType或者ResultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;entity.Role&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select id,name from role<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.mybatis.model.Menu&quot;</span>&gt;</span><br>  select m.id,m.name<br>  from menu m join roleandmenu ram on m.id=ram.menuId<br>  where ram.roleId=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mahoking/article/details/46811865">批量增删改</a></p><h4 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h4><p>mysql<a href="https://blog.csdn.net/mytt_10566/article/details/74279105">主键自增长</a>生成：使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”Employee_id”**，在SQL语句中不写自增长字段。</p><p>可以不用<a href="https://blog.csdn.net/death05/article/details/53098328?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">trim</a>，插入为空就不插入了，但是要指定jdbcType。用trim+if判断空值，不需要指定jdbcType。批量插入parameterType依然写类（类地址？）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;department_id&quot;</span>&gt;</span> <br>  insert into departments(default, department_name) values (#&#123;department_id&#125;,#&#123;department_name&#125;) <br>  // 或者insert into departments(department_name) values (#&#123;department_name, jdbcType=varchar&#125;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="update元素"><a href="#update元素" class="headerlink" title="update元素"></a>update元素</h4><p>不修改的值保持原值，传入一个对象。字符串写判断是否为空字符串或null，传入对象时要带其id</p><p><strong>基本数据类型和对象等数据只需要判断是否为null</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Employee&quot;</span>&gt;</span><br>update employee <br>  //set同样会帮我们忽略最后的“，”<br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    //注意if中的first_name是对象中，不是数据库中<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt;</span><br>      first_name = #&#123;first_name&#125;,<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary!=null &quot;</span>&gt;</span> <br>      salary = #&#123;salary&#125;, <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span> <br>  where employee_id = #&#123;employee_id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="lt-delete-gt-元素"><a href="#lt-delete-gt-元素" class="headerlink" title="&lt;delete&gt;元素"></a>&lt;delete&gt;元素</h4><p>一般使用单ID删除，可以在service层循环ID，带调用单删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parametertyep</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>delete from employee where employee_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int[]&quot;</span>&gt;</span> <br>  delete from employee where employee_id in <br>  <span class="hljs-comment">&lt;!-- collection只能写array或者list，即数组或集合，但是orderIDs --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="lt-select-gt-元素"><a href="#lt-select-gt-元素" class="headerlink" title="&lt;select&gt;元素"></a>&lt;select&gt;元素</h4><p>条件查询，用Map&lt;String, Object&gt;作为传入参数，可以不写parameter</p><p>where 1&#x3D;1？</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;mapper namespace=<span class="hljs-string">&quot;com.lee.Mapper.Employee&quot;</span>&gt;<br>  &lt;select id=<span class="hljs-string">&quot;select&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;Employee&quot;</span>&gt; <br>    select * from employee e left outer join Dept d on e.deptno=d.deptno<br>    <span class="hljs-comment">// 可以用where，mybatis会自动帮我们忽略</span><br>    &lt;trim prefix=<span class="hljs-string">&quot;where&quot;</span> prefixOverrides=<span class="hljs-string">&quot;and | or&quot;</span>&gt; <br>      &lt;!-- first_name是Map中的Key，用#&#123;first_name&#125;获取到value --&gt; <br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> #&#123;first_name&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;job_id!=null and job_id!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">job_id</span> <span class="hljs-operator">=</span> #&#123;job_id&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt; <br>    &lt;/trim&gt; <br>&lt;<span class="hljs-type">if</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;index!=null&quot;</span>&gt;<br>      limit #&#123;index&#125;,#&#123;pageSize&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt; <br>  &lt;/select&gt;<br>  &lt;!-- 计数--&gt;<br>  &lt;select id=<span class="hljs-string">&quot;count&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>    select <span class="hljs-title function_">count</span><span class="hljs-params">(*)</span> from employee<br>    &lt;where&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;firstName !=null and firstname!=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> # &#123;firstName&#125;<br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>  &lt;/select&gt;<br>  <br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h4 id="SQL块"><a href="#SQL块" class="headerlink" title="SQL块"></a>SQL块</h4><p>用动态SQL块代替常用于字段，一个表中的字段可能很多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empSql&quot;</span>&gt;</span><br>  first_name,job_id,salary,department_id <br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--字段用include动态SQL块代替，类似于alias --&gt;</span><br>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empSql&quot;</span>/&gt;</span> from employe<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js的函数和方法的区别</title>
    <link href="/2021/04/12/front/3.%20js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/12/front/3.%20js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天偶尔看到，JS中的函数和方法这两个概念竟然有些许差别😅，在我印象中，大部分编程语言里，函数和方法没有任何区别，大概的意思就是通过名字调用的一段代码，只是C&#x2F;C++中，习惯称为函数（function），Java中习惯称方法（method），而在JS中，我们知道也习惯称function，即函数。</p><p>在vue.js中，经常的一种写法就是，将函数绑定到对象上，大概就是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-attr">getMessage</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>getMessage</code>就是对象hua的一个函数，更确切的，这种<strong>绑定到对象上的函数就是方法</strong>，需要通过<code>hua.getMessage</code>或者<code>hua.getMessage()</code>去调用。ES6对于书写这种函数，推荐写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈函数式编程</title>
    <link href="/2021/04/12/front/4.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/04/12/front/4.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><code>axios.get(&#39;url&#39;).then(response =&gt; (this.info = response))</code></p><p>箭头函数常用来书写匿名函数</p><p>前端异步。</p>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>今日学习随机</title>
    <link href="/2021/03/30/front/2.%20js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/03/30/front/2.%20js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>声明变量作用域方面，var定义的变量作用域是函数级，但是代码块里声明的var变量，代码块外又允许访问（所以var有很多不合理的地方）。let是升级版的var，用来代替var，作用域为标准的代码块级。const是代码块级作用域的常量。</li><li>var能够重复声明变量，而let和const不允许被重复声明。</li><li>并且var声明的变量存在<strong>变量提升</strong>，即在用var声明变量代码之前，函数就可以调用这个变量，默认值为undefined，而let&#x2F;const声明的变量，则会提示变量not defined（let）或者error（const）。</li></ol><h2 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h2><p>在模块化出现之前，js通过script标签直接引入另一个js，引入顺序必须固定，而维护成本高，现在主要的两种js模块化规范。</p><ul><li><p>Common JS模块化规范（nodejs）：require&#x2F;exports</p></li><li><p>ES6模块化规范：<a href="https://www.jianshu.com/p/541256d8abb3">import&#x2F;export</a>。</p></li></ul><p>export你需要导出的变量或者函数，import时需要带{}，而export default导出的变量不需要带{}。export可以导出未声明变量或者函数，export default只能导出已声明的变量、函数、或者匿名模块，一个文件中只能使用一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> name;<br><span class="hljs-keyword">export</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  data : &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br>---<br>b.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">import</span> random,&#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(random.<span class="hljs-property">data</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>在学习vue或者初次看到vue项目时，有一些疑问，比如vue组件、实例、vue文件之间的区别是什么new Vue()操作产生vue实例，组件类似于是可被Vue实例反复引用的。</p><p>vue组件是可复用的vue实例。类似于自定义标签，template属性为编写组件的必须项，props和data属性也较为常用。</p><p>注意编写vue组件时，因为html的自定义属性不能大写，会自动转化成小写，所以注册组件props中的变量，要用小写。</p><p>Vue.component()方法用于全局注册的vue组件，全局组件可以用于所有文件中的new Vue()创建的Vue根实例</p><h3 id="JS驱动vue-js"><a href="#JS驱动vue-js" class="headerlink" title="JS驱动vue.js"></a>JS驱动vue.js</h3><p>此时Vue实例用el元素直接绑定HTML。引入vue.js文件，通过js去直接驱动。用component注册全局组件，组件包含template。</p><p>template中的内容是需要有根节点的</p><h5 id="模块化驱动vue-js"><a href="#模块化驱动vue-js" class="headerlink" title="模块化驱动vue.js"></a>模块化驱动vue.js</h5><p>在js文件中可以import单Vue文件，将Vue文件渲染到的Vue实例上，挂载到指定的HTML上。一般模块化开发中我们只写一个vue根实例。</p><h5 id="单文件组件的优势"><a href="#单文件组件的优势" class="headerlink" title="单文件组件的优势"></a>单文件组件的优势</h5><p>模版语法高亮、全局定义命名不能重复、不支持CSS，而单文件的设置stype的scope属性，css只对单文件生效</p><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><ul><li>默认插槽和具名插槽</li></ul><p>将内容分发权限放到调用的父级，将复杂内容放到父级。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">--- vue 2.6之前:<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>--- vue 2.6后:<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:pre-icon</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中预设位置<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>作用域插槽</li></ul><p>让父组件访问子组件的值的一种插槽，弥补父组件无法获取到子组件变量值的情况。</p><p>（具名&#x2F;默认插槽）和（作用域插槽）是并列关系，是同时可以使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">--- 父组件从子组件中取数据，vue 2.6之前<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>--- vue 2.6后<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中slot绑定变量<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="compute、method、watch"><a href="#compute、method、watch" class="headerlink" title="compute、method、watch"></a>compute、method、watch</h5><p>计算属性能做的，watch都能做。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用npm和yarn遇到的问题</title>
    <link href="/2021/03/29/front/1.%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/29/front/1.%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="使用npm和yarn遇到的问题"><a href="#使用npm和yarn遇到的问题" class="headerlink" title="使用npm和yarn遇到的问题"></a>使用npm和yarn遇到的问题</h4><ol><li><p>关于包管理器npm和yarn</p><p>yarn是在npm的基础之上的包管理器，根据情况选用一个工具即可，都是去读取package.json文件，在一个项目中两者可以同时存在，但是每次构建项目后（初次npm install后），需要固定使用yarn，或者或者npm，当要切换包管理器管理项目时，需要删除node_modules文件夹。</p><p>不同版本的npm管理同一个项目，一般不会出现太大的问题，但是遇到构建问题时，也可以选择删除node_module文件夹和package-lock.json文件。</p><p>遇到一个问题，npm 7构建node旧项目时，会出现构建依赖树冲突问题。</p></li><li><p>node-sass在离线机器上的安装问题</p><p>node-sass还会绕过设置的本地仓库去GitHub去获取，获取不到时会在本地编译，本地编译在win下又依赖python和C++环境，这个问题给我整吐了，怎么也不好解决，尝试过多种方法也无济于事后，找同事在能运行的机器上，拷贝了整个项目先启动看看，后期再去解决npm install安装的问题。</p></li><li><p>vue-cli工具：vue-cli、@vue&#x2F;cli。</p><ul><li>vue init webpack demo。npm run dev</li><li>vue create demo。@vue&#x2F;cli构建的项目，会在本地加入vue-cli-serivice这样的依赖npm serve</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传下载</title>
    <link href="/2020/10/25/%E5%85%B6%E4%BB%96/4.%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2020/10/25/%E5%85%B6%E4%BB%96/4.%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>表单上传：type为file类型的input标签<strong>和enctype&#x3D;multipart&#x2F;form-data</strong>上传数据，不做处理，是同步上传。</p></li><li><p>ajax上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#myinput&quot;</span>).<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-comment">// 这两个必写</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>($(<span class="hljs-string">&#x27;#uploadForm&#x27;</span>)[<span class="hljs-number">0</span>]),<br><span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-Servlet纯流方式-x2F-SmartUpload或Apache-FileUpload"><a href="#1-Servlet纯流方式-x2F-SmartUpload或Apache-FileUpload" class="headerlink" title="1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload"></a>1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload</h4><p>Servlet直接读区获取字节流存储在文件夹，但是无法同时区分普通控件和上传文件</p><p>在Servlet中都能实现上传文件功能简化，实现业务数据和上传的文件同时获取，并且直接write（不需要手动outputStream）</p><p><a href="https://www.jianshu.com/p/e7837435bf4c">FileUpload文件上传参考</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">// 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isMultipart</span> <span class="hljs-operator">=</span> ServletFileUpload.isMultipartContent(req);<br>  <span class="hljs-comment">// 如果不满足要求就立即结束对该请求的处理</span><br>  <span class="hljs-keyword">if</span> (!isMultipart) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// FileItem 是表单中的每一个元素的封装</span><br>    <span class="hljs-comment">// 创建一个 FileItem 的工厂类</span><br>    <span class="hljs-type">FileItemFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskFileItemFactory</span>();<br>    <span class="hljs-comment">// 创建一个文件上传处理器（装饰设计模式）</span><br>    <span class="hljs-type">ServletFileUpload</span> <span class="hljs-variable">upload</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletFileUpload</span>(factory);<br>    <span class="hljs-comment">// 解析请求</span><br>    List&lt;FileItem&gt; items = upload.parseRequest(req);<br>    <span class="hljs-keyword">for</span> (FileItem fileItem : items) &#123;<br>      <span class="hljs-comment">// 判断空间是否是普通控件</span><br>      <span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;<br>        <span class="hljs-comment">// 普通控件</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 上传控件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> fileItem.getContentType();<br>        <span class="hljs-keyword">if</span> (!contentType.startsWith(<span class="hljs-string">&quot;image/&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 实现简单的错误提示</span><br>          req.setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;亲，您上传的文件格式不正确，请重新上传！&quot;</span>);<br>          req.getRequestDispatcher(<span class="hljs-string">&quot;upload.jsp&quot;</span>).forward(req, resp);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果不是图片类型则不再对请求进行处理</span><br>        &#125;<br>        <span class="hljs-comment">// 随机命名文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + <span class="hljs-string">&quot;.&quot;</span> + FilenameUtils.getExtension(fileItem.getName());<br>        <span class="hljs-comment">// 将上传的文件保存到服务器</span><br>        fileItem.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:/&quot;</span>, fileName));<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件上传"><a href="#2-SpringMVC文件上传" class="headerlink" title="2. SpringMVC文件上传"></a>2. SpringMVC文件上传</h4><p>SpringMVC的上传功能封装了FileUpload组件的功能</p><ol><li>配置FileUpload和common-io的依赖、在SpringMVC配置文件中配置MultipartResover（上传解析器）</li><li>SpringMVC Controller：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span><br><span class="hljs-comment">// 使用MultipartFile类，String ename是其他控件信息，request用于获取绝对路径</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile img, Emp emp ,String ename, HttpServletRequest request)</span>&#123;<br><span class="hljs-comment">// img存储到文件夹相对路径(Web程序的部署路径)</span><br><span class="hljs-comment">//1. 获得上传文件的名字,方便在下载时还原这个名字（3.jpg）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> img.getOriginalFilename(); <br><span class="hljs-comment">//.当前应用程序的部署绝对路径下的upload文件夹</span><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-comment">// 判断文件夹是否存在</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br><span class="hljs-keyword">if</span>(!file.exists())&#123;<br>file.mkdir(); <br>  &#125;<br> <br>  <span class="hljs-comment">//3.应付存储文件的名字重复，为文件重命名</span><br>  <span class="hljs-comment">// 先获得文件的后缀名</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">extendsName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>); <br>  <span class="hljs-keyword">if</span>(index!=-<span class="hljs-number">1</span>)&#123;<br>  extendsName = name.substring(index); <br>  &#125;<br>  <span class="hljs-comment">// 生成唯一的名字</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extendsName; <br>  <br>  <span class="hljs-comment">//4.MultipartFile.transferTo方法代替流输入</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file,fileName);<br>  <span class="hljs-keyword">try</span> &#123;<br>    img.transferTo(savePath); <br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(); <br>  &#125;<br><span class="hljs-comment">// 5 存储数据库，这个照片是员工的属性</span><br>  <span class="hljs-comment">// 保存到相对路径</span><br>  emp.setFilePath(<span class="hljs-string">&quot;/upload/&quot;</span>+fileName); <br>  emp.setFileName(name);<br>empService.save(emp);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件下载："><a href="#文件下载：" class="headerlink" title="文件下载："></a>文件下载：</h2><p>a标签在h5的download属性可以通过URL访问到，单独的用控制器下载其实比价少用，真的用的时候可以用流下载</p><p>FormData两种方式定义，append(“myimage”, $(“#myfile”).get(0).files[0]) ）<a href="https://harttle.land/2016/07/04/jquery-file-upload.html">异步上传</a></p><p>cache、processData和contentType为false，防止JQ转码</p><h4 id="1-Servlet纯流方式"><a href="#1-Servlet纯流方式" class="headerlink" title="1. Servlet纯流方式"></a>1. Servlet纯流方式</h4><p><a href="https://www.jianshu.com/p/f450da30f594">纯流文件下载参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">String dataDirectory=req.getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/data&quot;</span>);<br><span class="hljs-comment">// 通过service查询到</span><br>File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dataDirectory, <span class="hljs-string">&quot;secret.pdf&quot;</span>);<br><span class="hljs-keyword">if</span>(file.exists())&#123;<br>  resp.setContentType(<span class="hljs-string">&quot;application/pdf&quot;</span>);<br>  resp.addHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=secret.pdf&quot;</span>);<br>  <span class="hljs-type">byte</span>[] buffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>  FileInputStream fis=<span class="hljs-literal">null</span>;<br>  BufferedInputStream bis=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span>&#123;  <br>    <span class="hljs-comment">// BufferInputStream每次读一块字节相比读一个字节对于文件速度更快。</span><br>    fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>    bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    <span class="hljs-type">int</span> i=bis.read(buffer);<br>    <span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>      os.write(buffer,<span class="hljs-number">0</span>,i);<br>      i=bis.read(buffer);<br>    &#125;<br>  &#125;<span class="hljs-keyword">catch</span>(IOException ioe)&#123;<br>    System.out.println(ioe.toString());<br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-keyword">if</span>(bis!=<span class="hljs-literal">null</span>)&#123;<br>      bis.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fis!=<span class="hljs-literal">null</span>)&#123;<br>      fis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件下载"><a href="#2-SpringMVC文件下载" class="headerlink" title="2. SpringMVC文件下载"></a>2. SpringMVC文件下载</h4><p> 使用spirng 自带的<strong>ResponseEntity</strong>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException&#123;<br>  <span class="hljs-comment">//获取你文件的文件夹，一般从数据库读区，这里模拟service已经取到路径</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getSession().getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1168701023208865792.jpg&quot;</span>; <br>  <span class="hljs-comment">// 1. 获取文件路径</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path,filename); <br>  <span class="hljs-comment">//设置header里的ContentDisposition字段，以attachment(下载框方式)打开图</span><br>  <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>(); <br>  headers.setContentDispositionFormData(<span class="hljs-string">&quot;attachment&quot;</span>, downloadFielName);<br>  <span class="hljs-comment">// 2. ResponseEntity返回，返回application/octet-stream : 二进制流数据(最常见的文件下载)。</span><br>  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-type">byte</span>[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2020/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>关于数据库中数据值使用单引号和双引号，之前一直认为是单引号和双引号没有任何区别，第一次使用Oracle时，发现不能使用双引号去表示字符串，才明白<strong>标准SQL中，使用单引号去表示字符串</strong>，MySQL也允许双引号表示字符串，但推荐使用标准的单引号。</p><p>对数据库中数据类型加不加引号也一知半解，实际上，数据库中字符类型和日期类型必需加单引号，而数值类型，如int和decimal，可加单引号也可以不加单引号，但是<strong>在实际应用中，数据库的所有数据类型的值推荐都加上单引号</strong>。</p><p>date&#x2F;datetime&#x2F;timestamp&#x2F;varchar类型都可以存储日期数据，date精度到天，datetime和timestamp精度到秒。不需要进行排序和计算时，使用varchar类型就可以。</p><p>#{ }是预编译替换，所有的的变量都会用单引号包围，${ }是字符串替换，不会加上单引号，传入字符串时，需要手动加上引号<code>&#39;$&#123;name&#125;&#39;</code>，用户指定列名时，比如order by一个输入列名，这时候我们不使用#，需要使用$。</p><h2 id="MySQL语句"><a href="#MySQL语句" class="headerlink" title="MySQL语句"></a>MySQL语句</h2><h3 id="database，schema和instance的区别"><a href="#database，schema和instance的区别" class="headerlink" title="database，schema和instance的区别"></a>database，schema和instance的区别</h3><ul><li>mysql中：database&#x3D;schema（子集为数据库对象），两个关键字同义。</li><li>oracle中：一个instance对应一个database，instance指进程，database指后台进程。某个用户下的数据库对象集合称为schema（有）。oracle创建对象必须要对应一个用户，与mysql和SQLserver不一样</li><li>SQLserver：一个instance对应多个database。服务器.数据库.Schema.对象</li></ul><h3 id="三大数据库设计范式"><a href="#三大数据库设计范式" class="headerlink" title="三大数据库设计范式"></a>三大数据库设计范式</h3><p>1NF：列的原子性。</p><p>2NF：主键依赖&#x2F;取消部分依赖，通过主键来确定唯一的一条记录。非主属性依赖主键</p><p>3NF：取消传递依赖。非主属性除了依赖主键，不互相依赖</p><h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><p>数据库字段设置AUTO_INCREMENT，当insert null或者0时，会实现自增长。</p><p>mybatis mapper.xml中配置使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”一般是主键”**这两个属性，在SQL语句中使用default，或者不写这个自增长字段。</p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `m_function` (<br>  `ID` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `ModuleCode` <span class="hljs-type">varchar</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;模块编号&#x27;</span>,<br>  `UpdateUserId` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改人&#x27;</span>,<br>  `UpdateDate` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`ID`)<br>  <span class="hljs-keyword">constraint</span> FK_Name <span class="hljs-keyword">foreign</span> key (user_id) <span class="hljs-keyword">references</span> student(id)<br>  INDEX  index_ModuleCode (ModuleCode)<span class="hljs-comment">-----等于  KEY  index_ModuleCode (ModuleCode)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改表名：alter table emp <code>rename [TO]</code> emp1</p><p>修改表结构：alter table  tb1 add&#x2F;drop&#x2F;<code>modify/change</code></p><p>add&#x2F;drop后面不加column&#x2F;index&#x2F;constraint等修饰时，默认对表的column即列进行操作</p><p>增加索引：alter table tb1 add index idx_score (score)</p><p>添加外键：alter table tb1 add constraint fk_id foreign key(user_id) references tb2(id)</p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>distinct去重：放于select的所有字段前，只有所有列的值一样时，才算重复。</p><p>like模糊查找：<code>%</code>通配符匹配多个字符，<code>_</code>通配符只匹配一个字符。<code>like &#39;li%x_n&#39;</code></p><p><a href="https://blog.csdn.net/qmhball/article/details/7941638">having和where</a>：排先where ，再group，再having，再order by。where是对数据库中的数据筛选，having是对group by聚合后的结果筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">// 查询学生成绩表中两门科目大于80分的同学编号<br>select sno from SC where score&gt;80 group by sno having count(cno) &gt; 2<br></code></pre></td></tr></table></figure><ul><li><p>外连接</p><p>左外链接会显示一个左表的所有数据，右表是辅表，符合条件的右表记录会显示，不符合条件的右表记录将会用null显示。（右外连接相反），左表用第一条记录依次匹配右表记录，如果再右表中匹配到多条记录，则生成有序对。<strong>如果没匹配到一条记录右表记录，这条左表记录依然会显示，右表用null表示，这是外连接和内连接的唯一区别</strong></p></li><li><p>子查询</p><p>子查询条件时时，一个结果匹配用 &#x3D;，多个结果匹配使用 <code>in/exists</code></p><p>子查询大小条件时。一个结果用 &gt;或者&lt;，查询出来多个结果使用<code>&gt; any( 子查询语句 )</code>或者<code>&gt; all ( 子查询语句 )</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/10/02/%E5%85%B6%E4%BB%96/2.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/10/02/%E5%85%B6%E4%BB%96/2.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>^a以a开始</p><p>a$以a结束</p><h4 id="字符代表符号（匹配符）"><a href="#字符代表符号（匹配符）" class="headerlink" title="字符代表符号（匹配符）"></a>字符代表符号（匹配符）</h4><p>[a-z]小写字母、[a-zA-Z0-9]字母和数字</p><p>. 除换行符以外的任意单字符</p><p>\d数字。</p><p>\D非数字</p><p>\w数字，字母或下划线</p><p>\s特殊字符</p><h4 id="数量限定符"><a href="#数量限定符" class="headerlink" title="数量限定符"></a>数量限定符</h4><p>{5}： 前面的一个字符出现5次{1,}：1次以上。{1,3}：1次到3次</p><p>*前面的一个字符出现0次以上</p><p>+前面的一个字符出现1次以上</p><p>？前面的一个字符出现0次或1次</p><h3 id="前瞻和后顾"><a href="#前瞻和后顾" class="headerlink" title="前瞻和后顾"></a>前瞻和后顾</h3><p>正则表达的前后，还未解析字符的称为前面，解析过的称为后面</p><p>a(?&#x3D;b)前瞻，匹配a，且a必须在b的前面</p><p>a(?!b)负前瞻，匹配a，且a的前面不是b</p><p>(?&lt;&#x3D;b)a后顾，匹配a，且a的后面b</p><p>(?&lt;!b)a负后顾，匹配a，且a的后面不是b</p><p>|分成两段，或者</p><p>()圈定一个子串</p><h2 id="JS使用正则表达式"><a href="#JS使用正则表达式" class="headerlink" title="JS使用正则表达式"></a>JS使用正则表达式</h2><p><strong>var regexp &#x3D; &#x2F;正则表达式&#x2F;修饰符</strong>，</p><p>修饰符有i（不区分大小写）和g（全局匹配）</p><p><strong>匹配：regexp.test(str)</strong></p><h2 id="Java使用正则表达式"><a href="#Java使用正则表达式" class="headerlink" title="Java使用正则表达式"></a>Java使用正则表达式</h2><p>Pattern.complile(“”)创建正则对象</p><ul><li><p>匹配验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^[0-9a-zA-Z]\\.&#123;5,10&#125;@[0-9a-zA-z]&#123;2,7&#125;(\\.com|.cn)&quot;</span>)<br>p.matcher(str).matches() <span class="hljs-comment">//Match对象</span><br></code></pre></td></tr></table></figure></li><li><p>以一个正则表达式拆分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br>String[ ] s = p.split(str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>  System.out.print(s[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>  结果为ABCDEF<br></code></pre></td></tr></table></figure></li><li><p>替换里面的字符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(str);<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> m.replaceAll(<span class="hljs-string">&quot;-&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本编码</title>
    <link href="/2020/10/01/%E5%85%B6%E4%BB%96/1.%20%E7%BC%96%E7%A0%81/"/>
    <url>/2020/10/01/%E5%85%B6%E4%BB%96/1.%20%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>通常所说的乱码问题，是指文本文件乱码（非二进制文件），文本乱码的本质是解析的字符编码与文本本身字符编码不匹配导致的。</p><h2 id="1-字符集和字符编码"><a href="#1-字符集和字符编码" class="headerlink" title="1. 字符集和字符编码"></a>1. 字符集和字符编码</h2><ol><li><p>文本文件：通过字符编码（如UTF-8）保存的文件，如数字64，文本文件会将64解析成’6’和’4’两个字符，再根据字符集编码，再存储到硬盘中</p></li><li><p>二进制文件（狭义上的非文本文件）：保留数据本身二进制的文件，数字64，如Java的int型数字64，直接储存64的二进制到硬盘中</p></li></ol><p>字符集规定了字符在字符表的位置，在文本文件的存储过程中，文本会依靠字符集规则转化成字符，其中最著名的就是ASCII字符集和Unicode字符集。</p><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>ASCII既是世界上第一个字符集（charset），同时又规定了字符编码（encoding）。</p><p>ASCII字符编码用一个字节（7位容器）来表示一个字符，ASCII中一共有127个字符（0-126）。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>地球上字符太多，ASCII字符集的单字节无法表示，所以出现了Unicode字符集。最初时UTF-16编码来实现Unicode字符集，用2个或4个字节来保存。</p><ul><li><p>UTF-16：用两个或者四个字节（<strong>Java char类型用的2字节的UTF-16 LE</strong>），四字节称为UTF-16 BE</p></li><li><p>UTF-32：用四个字节</p></li><li><p>UTF-8：1～4个字节，1个字节时与ASCII编码相同，常见<strong>汉字一般3字节</strong></p></li></ul><h3 id="ISO-8859-1-（Latin-1）"><a href="#ISO-8859-1-（Latin-1）" class="headerlink" title="ISO-8859-1 （Latin 1）"></a>ISO-8859-1 （Latin 1）</h3><p>同样是ASCII码的超集，用一个字节（8位容器）实现255节。在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。mysql默认就采用他</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>一般汉字2字节。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html">Java中存在的编码问题</a></p><h2 id="2-Content-Type与前后编解码"><a href="#2-Content-Type与前后编解码" class="headerlink" title="2. Content-Type与前后编解码"></a>2. Content-Type与前后编解码</h2><p>开发过程中，设定HTTP请求和返回报文中的Content-Type是保证文本不乱码正常解析的最重要保障。</p><h3 id="浏览器解码顺序："><a href="#浏览器解码顺序：" class="headerlink" title="浏览器解码顺序："></a>浏览器解码顺序：</h3><ol><li><p>根据服务器返回的Content-Type中指定的编码解码。</p></li><li><p>根据meta标签的charset。</p></li><li><p>根据浏览器设定的编码解码（跟随浏览器设定，一般中文系统为GBK）</p></li></ol><h3 id="浏览器编码顺序和Content-Type："><a href="#浏览器编码顺序和Content-Type：" class="headerlink" title="浏览器编码顺序和Content-Type："></a>浏览器编码顺序和Content-Type：</h3><ul><li><p>POST请求的编码：默认UTF-8，<strong>ajax请求强制数据为UTF-8编码，即使在contentType中设置的编码也不生效</strong>，所以对于发送ajax请求，直接写application&#x2F;json，然后设置服务器对所有请求数据使用UTF-8解析：request.setCharactorEncoding(“UTF-8”)。</p><ul><li><p>Ajax POST默认contentType: application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8。</p></li><li><p>form POST默认的contentType: application&#x2F;x-www-form-urlencoded</p><p><strong>form POST的编码也是UTF-8，但是不会在Content-Type中声明</strong></p></li></ul></li><li><p>GET请求的编码：默认UTF-8（不指定Content-Type，一般传输不了中文）</p></li></ul><h3 id="服务器解码顺序："><a href="#服务器解码顺序：" class="headerlink" title="服务器解码顺序："></a>服务器解码顺序：</h3><ol><li><p>使用requst.setCharactorEncoding( )指定的编码解码。</p></li><li><p>根据客户端发送的Content-Type中的编码解码。</p></li><li><p>使用默认的UTF-8解码</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 设置Content-Type作用与于GET请求<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">useBodyEncodingForURI</span> = <span class="hljs-string">&quot;true&quot;</span> &gt;</span> <br> // 设置GET请求使用UTF-8解码, Tomcat 8以后这个默认值已经是UTF-8，<br> // 注意：request.setCharactorEncoding对GET请求不生效。<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">URIEncoding</span> =<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span> <br></code></pre></td></tr></table></figure><h3 id="服务器编码顺序和Content-Type："><a href="#服务器编码顺序和Content-Type：" class="headerlink" title="服务器编码顺序和Content-Type："></a>服务器编码顺序和Content-Type：</h3><ol><li><p>response.setContentType(“application&#x2F;json; charset&#x3D;UTF-8”)，respnse.setCharactorEncoding()</p></li><li><p>Servlet response的默认编码是UTF-8</p></li><li><p>JSP会默认Content-Type：</p><p>JSP的编码只受到Page指令的contentType&#x2F;pageEncoding命令约束，而且这两个命令对于JSP生成的Content-Type决定权最高。</p><p>response.setCharactorEncoding方法：设置返回数据的编码</p><p>response.setContentType方法：设置Servlet返回数据的编码和返回数据的Content-Type。<strong>setContentType方法优先级最高</strong>，在此方法前后出现setCharactorEncoding()，数据会按照Content-Type编码。</p></li></ol><ul><li>注解设置注解设置：@RequestMapping(value &#x3D; “”, <strong>produces&#x3D;”application&#x2F;json;charset&#x3D;UTF-8”</strong>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乱码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
