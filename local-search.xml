<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2023/12/19/Java/%E6%96%B0blog/6.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/12/19/Java/%E6%96%B0blog/6.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h4 id="1-创建线程的基础方式"><a href="#1-创建线程的基础方式" class="headerlink" title="1. 创建线程的基础方式"></a>1. 创建线程的基础方式</h4><p>一般情况下，需要通过创建Thread对象，并调用Thread对象的start()方法来创建一个线程。也就是说我们的目标就是得到一个有执行代码的Thread实例，那执行线程代码的任务放在哪里呢？</p><ul><li>第一种就是任务类继承Thread类并重写run方法，然后使用Thread类的无参构造方法得到实例化Thread对象；</li><li>另一种形式就是任务类实现Runnable接口或者Callnable接口重写run()，然后将Runnable对象或者Callnable对象传入Thread的有参构造方法得到实例化Thread</li></ul><h4 id="2-线程池来管理线程"><a href="#2-线程池来管理线程" class="headerlink" title="2. 线程池来管理线程"></a>2. 线程池来管理线程</h4><p>写的啥啊？我这是？每次看自己的笔记都感觉看不明白，还不如看别人的笔记。都是些名词性的注解和简写</p><p>为什么我们有时候会通过线程池来创建线程呢？对于那种频繁执行的任务，不断创建和销毁线程是极大的开销，所以我们就创建线程池来管理线程，Java中你要使用线程池，基本就要创建<strong>ExecuterService</strong>的实例，ExecuterService是Java中所有线程池的基类，创建实例以后，调用<code>execute(Runnable runnable)</code>和<code>submit(Callnable callnable)</code>创建1个线程任务，execute()不会有返回值，适合调用没有返回值的任务，而submit()返回一个Future&lt;T&gt;对象，可以用来异步获取“子线程“任务执行的结果。<br>具体创建ExecuterService的执行类有两种方式：</p><ol><li>使用Executors静态工厂方法：使用Executors静态工厂创建线程池很简单，不需要像构造方法指定太多的参数，<ul><li>newCachedThreadPool()：会优先复用之前执行的线程，不是一种单例的形式</li><li>newFixedThreadPool(int number)：指定多少的线程数量</li><li>newSingleThreadPool()：单例线程，依次执行</li><li>newScheduledThreadPool()：使用独有的<code>executor.schedule(worker, 10, TimeUnit.SECONDS)</code>，可以定时或者延迟执行任务</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);  <br>Future&lt;Integer&gt; future = executorService.submit( ()-&gt;&#123;  <br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;  <br>        sum=sum+i;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> sum;  <br>        &#125;);  <br>System.out.println(future.get());  <br>executorService.shutdown();  <br></code></pre></td></tr></table></figure><ol start="2"><li>但是由于Executors创建出来的线程池都是<strong>无界队列</strong>，啥意思呢，就是如果提交的任务越来越多，如果线程消费的速度很慢，这些任务就会形成很长的队列保存在Java内存中，容易OOM，所以开发规范上是更推荐使用带参数的<strong>线程池类的构造方法</strong>，即使用线程池实现类 <strong>ThreadPoolExecutor</strong> 和 <strong>ScheduledThreadPoolExecutor</strong> 的构造方法，后者继承自前者，在构造方法中指定queenCapacity参数，指定队列的容量，另外<br> 构造方法参数的解释：当线程池中的线程数量少于corePoolSize时，线程池会为每个新提交的任务创建一个新线程，无论是否有空闲线程；corePoolSize数量的线程会保留不会销毁，corePoolSize数量的线程全部在执行时，新任务会进入任务队列，CorePoolSize的线程有空闲时从任务队列获取任务，只有当任务队列queueCapicity也满了，开始创建新线程，直至达到maximumPoolSize               <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>; <span class="hljs-comment">// 核心线程数 </span><br><span class="hljs-type">int</span> <span class="hljs-variable">maxPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 最大线程数 </span><br><span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>; <span class="hljs-comment">// 线程的最大空闲时间 </span><br><span class="hljs-type">TimeUnit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS; <span class="hljs-comment">// </span><br>keepAliveTime的时间单位 <span class="hljs-type">int</span> <span class="hljs-variable">queueCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 任务队列容量 </span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>( corePoolSize, maxPoolSize, keepAliveTime, unit, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(queueCapacity) );<br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://mp.weixin.qq.com/s/q0Qt-ha9ps12c15KMW7NfA">线程池实现原理</a></p><h4 id="3-关于线程小TIPS"><a href="#3-关于线程小TIPS" class="headerlink" title="3. 关于线程小TIPS"></a>3. 关于线程小TIPS</h4><ul><li>Java中没有严格的父子线程，因为传统意义上的子线程与父线程是绑定的，父线程销毁，子线程也会销毁；而Java中，当一个线程中启动另一个线程（子线程），这些线程都变成了Java中独立线程</li><li>守护线程：通过<code>t.setDaemon(true)</code>设置守护线程，守护线程将会在所有用户线程结束后被JVM强制关闭，所以应用在一些循环运行且与主任务伴随的线程，如日志线程、垃圾回收线程就是守护线程，从业务设计上来说，主任务没了守护线程也没了意义。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li><p>新建：new出来实例，没有start()</p></li><li><p>可运行：正在执行run中的代码</p></li><li><p>终止 ：run方法执行完毕</p></li><li><p>阻塞：注意IO阻塞方法，其实线程是进入了一种类似“等待”的状态，与线程的“阻塞”状态是没有关系的，线程阻塞，或者说<strong>线程的阻塞状态，是多线程状态下锁竞争产生的</strong>，没拿到锁的就进入阻塞状态</p></li><li><p>等待：通过wait()、t.join()的方法进入 。协助</p></li><li><p>超时等待：this.wait(long)、t.join(long)、Thread.sleep(long)</p></li></ul><h4 id="线程状态相关的方法"><a href="#线程状态相关的方法" class="headerlink" title="线程状态相关的方法"></a>线程状态相关的方法</h4><ol><li>t.join()，对子线程t使用，当前线程进入等待状态，直到t线程完成。比如等待某个异步任务执行完，要注意对子线程join()时，当前线程不能被其他线程interrupt()中断，会报异常。</li><li>Thread.sleep(long)，是一个静态方法，当前线程会在等待设定的时长后再继续执行，应用在模拟延迟，限制速率。<strong>sleep过程中不会释放锁</strong></li><li>tihs.wait()搭配notifyAll()和notify()，是一种条件等待机制，应用于<strong>线程间的通讯和协调</strong>，当一个线程需要等待另一个线程完成某些任务时，通过这三个方法来协调通讯，例如生产者-消费者模型。<br>他们是Object类的一个native方法，首先，这三个方法需要<strong>用在synchronized代码内</strong>，不能用于ReentranLock等，其次必须要在已拿到锁的对象上调用这三个方法，例如你拿到的锁对象是this，就使用this.wait()调用，拿到的是lock，就用lock.wait()调用。<br>生产者消费者模型距离，消费者线程拿到this锁，进入获取资源的方法时，要判断资源不为空才去poll()消费资源，如果资源为空我们应该wait()等待生产者线程生产，<strong>wait()会释放消费者持有的锁</strong>，让生产者拿到锁去生产，生产完成后this.notifyAll()，唤醒处于this.wait()状态下的所有线程，所有进入阻塞状态争夺锁，拿到锁的线程会接着执行this.wait()后面的代码。<br>要注意的是，生产者判断资源为空进入wait()需要使用while而不是if，因为拿到锁以后，仍然需要再次判断资源是否为空，其他没有拿到锁的线程，不需要再次唤醒，而是已经进入主动争夺锁的阻塞状态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(resource.isEmpty())&#123;<br>  <span class="hljs-built_in">this</span>.wait();<br>&#125;<br>resource.poll();<br></code></pre></td></tr></table></figure><h2 id="同步和异步、阻塞与非阻塞"><a href="#同步和异步、阻塞与非阻塞" class="headerlink" title="同步和异步、阻塞与非阻塞"></a>同步和异步、阻塞与非阻塞</h2><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>编程本就是同步性质的，加入一些异步编程，面对并发进行一些“同步处理”。</p><p>同步，是一个由上到下执行的概念，<strong>强调必须要拿到最终结果，才执行下一步</strong>，必须顺序执行，这符合我们人思考的逻辑，先操作什么，得到什么结果，最后进行什么操作。<br>我们编写的代码本身就是同步的，那为什么我们还常常听说到<strong>线程同步</strong>这个概念呢？因为多线程的并发执行，可能会出现资源竞争等一些不符合我们原本同步逻辑下的线程安全问题，这时候我们要加入一些“同步机制”，如<strong>同步方法</strong>，目的就是让多个线程之间“同步”执行，保证线程安全，让并发的进程一个接一个的同步执行。要注意的是，同步方法的对立面并不是异步方法，例如没有synchronize关键字的方法，应该称为“非同步方法”而不是异步方法，我们常常描述的异步方法，和异步编程或异步调用是一个概念。</p><p>异步，对于是否顺序执行的要求不严格，一些执行时间比较长的任务，在不影响业务逻辑的情况下，我们可以考虑采取异步编程，<strong>异步任务先直接返回，让主程序接着往下执行</strong>，异步任务与主程序同时执行，当异步任务执行完了，后续异步任务<strong>通知或者回调主程序</strong>，再进行下一步应该的操作。例如我们在Java开发中，一些外部接口调用中使用“异步调用”，例如异步方式调用外部接口发短信；Java底层也有部分异步API，如Future、CompletableFuture等实现内部代码的异步编程。<br>多线程如果同时执行多个相同任务，这种形式就不能够称异步，可以称为并行或者并发，异步概念强调主程序与异步任务之间存在因果关联性的并行执行关系。当主程序开启子线程，这个时候可以称为是<strong>异步编程</strong>，一般会搭配Future和CompletableFuture等处理。</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞，不同的场景下有不同的解释，第一种，用于描述线程时，“阻塞”是Java线程的6种状态之一，例如多线程资源竞争时，如果设置了“同步方法”，没拿到锁的线程就会进入阻塞状态；第二种，描述IO时，可以描述阻塞式IO和非阻塞IO，这是POSIX规定的5种IO模型之二，阻塞型IO，如inputStream中的read方法，read()在没有结束或者关流之前，会让调用IO的程序线程中断的现象，通常称为IO阻塞，但是IO阻塞没有让线程进入“阻塞”状态，阻塞时多线程竞争时的概念，IO阻塞或者说阻塞方法，强调的是在当前线程中，有任务耗时比较长，而我们说过，一般的代码是同步的，就会导致当前线程中断，不去执行任务。第三种，阻塞方法，如serversocket.accpet()，阻塞方法也是针对当前线程的的概念，强调耗时长，或需要等待特定条件才能往下走，也要时刻注意，阻塞方法也没有让线程进入阻塞状态，是让当前线程进入了类似“等待的状态”。</p><p>同步&#x2F;异步，关注通知机制，关注；阻塞，关注任务本身</p><h2 id="线程的同步处理"><a href="#线程的同步处理" class="headerlink" title="线程的同步处理"></a>线程的同步处理</h2><h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><p>一段代码的多线程执行，有线程安全问题，我可以使用锁，同步这段代码，保证线程安全；两段代码之间有线程安全的竞争关系，可以给两段代码设置相同的锁，来保证安全全。</p><p>没有申明做了线程安全处理的，我们都默认他线程不安全。但也有部分很明显线程安全类，如没有成员变量的类，或类里所有的成员变量都是final修饰的基本数据类型或String类型，这两种类是线程安全的。</p><p>被synchronized修饰的同步方法，相当于方法内的所有代码被synchronized(this){}封装，也就是锁是this当前对象实例，而静态同步方法锁是类Class实例。</p><p><strong>公平锁和非公平锁：</strong></p><ul><li>Java的锁一般默认都为非公平锁，线程自由竞争随机获取锁</li><li>公平锁是线程获得锁的顺序，按照请求顺序获得，在ReentrantLock和ReetrantReadWriteLock的构造方法传入true打开</li></ul><p><strong>乐观锁和悲观锁：</strong></p><ul><li>悲观锁，假设其他事务会修改数据，执行代码前必须要先获得锁，认为资源的竞争关系比较强烈。</li><li>乐观锁，通常其他事务不会修改数据，默认不设置锁，当完成操作以后，看版本号有没有改变，如果有改变再rollback重试，没有改变就提交。对于那种读非常多，写比较少的情况下，用乐观锁是非常合适的</li></ul><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>Java的单条语句中，实际上只有基本数据类型和引用数据类型的<strong>赋值</strong>是真正的原子操作 ，就算时sum&#x3D;i+1这种简单语句都不是原子的。</p><p>首先说一下<strong>共享变量</strong>，多线程的共享变量是位于堆上或者说主内存上的，也就是对象的成员变量或者静态类型数据，存储在栈也就是工作内存上的，只有局部变量，这无法作为共享资源被多个线程操作，共享变量存储在主内存上，多线程操作共享变量就多了一个流程，都需要从主内存取值，复制到工作内存的过程，显而易见，在多线程下是不安全的。</p><p>volatile关键字第一个<strong>解决了共享变量的可见性</strong>问题，保证当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值，主要是解决如count&#x3D;3这种问题；第二个<strong>防止了编译时和运行时发生指令重排</strong>，这称为volatile的有序性。</p><p>volatile也只能保证在多线程模型下，获取共享变量值是没有问题的，但是对于非共享变量，以及无法保证复合操作的原子性，volatile的线程同步特性有限。如我们对共享变量n用volatile关键字修饰，连基本的n&#x3D;n+1和n++，volatile也是无法保证原子性的，因为他们本身就是复合操作。</p><h4 id="1-synchronized-内置锁"><a href="#1-synchronized-内置锁" class="headerlink" title="1. synchronized 内置锁"></a>1. synchronized 内置锁</h4><p>这是Java提供最原始的锁机制，同步代码块或者同步方法，是一种可重入锁，也就是同一个线程能多次获取同一个锁的机制，可重入锁可以避免递归调用不会导致死锁；经过优化后synchronized也没有这种“重”了，对系统的开销没有那么大了。</p><h4 id="2-ReentrantLock（1-5）显示锁"><a href="#2-ReentrantLock（1-5）显示锁" class="headerlink" title="2. ReentrantLock（1.5）显示锁"></a>2. ReentrantLock（1.5）显示锁</h4><p>ReentrantLock也是Java早期提供的锁机制，相比于synchronized锁更加轻量和灵活，代码中使用<code>lock()</code>，线程就等于拿到lock对象锁，使用这种形式的锁一定要注意，用try-finally代码块的形式保证<code>lock.unlock()</code>的执行，搭配条件变量 <strong>Condition</strong> 的<code>await()</code>和<code>signalAll()</code>也可以起到synchronized配合wait()和notify()的作用。</p><p>ReentrantLock相比传统synchronized，还提供了一种尝试获取锁的机制，<code>lock.tryLock(1, TimeUnit.SECONDS)</code>方法，尝试获取锁，支持在设定时间后放弃锁的争夺，做其他的处理，这可以根据业务情况看需不需要这样做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(String s)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            queue.add(s);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                condition.await();<br>            &#125;<br>            <span class="hljs-keyword">return</span> queue.remove();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-ReadWriteLock（1-5）读写锁"><a href="#3-ReadWriteLock（1-5）读写锁" class="headerlink" title="3. ReadWriteLock（1.5）读写锁"></a>3. ReadWriteLock（1.5）读写锁</h4><p>包含读锁和写锁两种锁，读锁可以被多个线程持有，写锁和普通锁一样只能被一个线程拿到，但是读锁和写锁之间存在锁竞争关系，持有读锁需要等待写锁释放，持有写锁需要等待所有读锁释放，而且由于读锁之间没有竞争关系，可能写锁一直无法全部释放，陷入“写线程饥饿”，所以适用于读远大于写的情况。</p><p>有一种解决方案是使用<strong>公平锁模式</strong>，构造方法参数使用true打开，公平锁就是按照锁的请求顺序分配锁，请求写锁线程先过来，后续请求读锁线程会先阻塞，等待现有的读锁线程释放所有读锁，这防止了“写线程饥饿”，但降低了读锁的并发性能，因为意味着读锁也要按顺序分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>(<span class="hljs-literal">true</span>); <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">rlock</span> <span class="hljs-operator">=</span> rwlock.readLock();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">wlock</span> <span class="hljs-operator">=</span> rwlock.writeLock();<br></code></pre></td></tr></table></figure><h4 id="4-StampedLock（Java-8）乐观锁机制"><a href="#4-StampedLock（Java-8）乐观锁机制" class="headerlink" title="4. StampedLock（Java 8）乐观锁机制"></a>4. StampedLock（Java 8）乐观锁机制</h4><p>乐观锁可以进一步提升读的并发性能，Java中StampedLock除了支持悲观读锁和悲观写锁，还支持了乐观读锁的机制。但是要注意和ReentrantLock不同，StampedLock的读写锁不支持重入，不支持条件变量Condition，实现线程间的通信。</p><p>传统悲观锁中，读写一定不能并行执行，而乐观锁的读和写可以并发执行，因为乐观锁不是传统意义上一种实际的锁，本质是没有加锁的，而是提供了一种校验机制，校验当前读锁代表的共享资源，在读操作开始后，有没有被“写操作”，减少了锁的开销，适用于读远大于写的场景。<br>通过writeLock()方法，上写锁的同时，获得一个事件戳；可以应用在进行<code>validate(stamp)</code>校验，也就是通过<code>tryOptimisticRead()</code>乐观读锁获取的时间戳，会和悲观写锁获得的时间戳进行比较，通过这种校验，达到乐观锁的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.StampedLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-comment">// 修改 x 和 y 坐标的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算到原点的距离</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead(); <span class="hljs-comment">// 尝试获取乐观读锁</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="hljs-comment">// 检查乐观读锁是否有效</span><br>            stamp = stampedLock.readLock(); <span class="hljs-comment">// 如果无效，获取悲观读锁</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br>&#125;```<br><br>#### <span class="hljs-number">5.</span> Semaphore 信号量<br><br>Semaphore 信号量，不像之前说过的传统悲观锁，更像一种限流机制，他的目的不是确保线程间的同步，而是限制对共享资源访问的线程连接数量，如数据库连接，他可以最多可以允许设定数量的线程并发执行，比线程池还要轻量一些。<br><br>```java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 3个许可</span><br>semaphore.acquire(); <span class="hljs-comment">// 请求许可</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 访问共享资源</span><br>    System.out.println(<span class="hljs-string">&quot;Accessing shared resource...&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    semaphore.release(); <span class="hljs-comment">// 释放许可</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-Atomic包中的类"><a href="#6-Atomic包中的类" class="headerlink" title="6. Atomic包中的类"></a>6. Atomic包中的类</h4><p>Java中一般的复合操作，例如count++都是线程不安全的，可以用Atomic中的包，实现count++这类复合操作，变成原子操作，可以用来代替，多线程下，基本数据类型和引用数据类型进行部分原子性操作，比如在AtomicInteger代替int类型数据进行线程安全的数学运算，比如其中的incremnetAndGet()实现count++。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2023/12/18/Java/%E6%96%B0blog/5.Java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/12/18/Java/%E6%96%B0blog/5.Java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在计算机网络中，IP协议是网络层， 用于数据转发，路由器就是工作在这一层，网络层可以说是与IP相关的，我们使用<code>ping</code>命令的时候，就是工作在这一层；TCP协议是传输层的一种协议，用于建立数据连接、保证传输可靠性，传输层其实就是一个关于端口的通信连接协议，所以我们如果要看服务器的端口是否正常，这个时候我们应该使用<code>telnet</code>命令。</p><p>程序实现数据通信的核心是建立了TCP连接，无论哪种编程语言都是去调用操作系统的Socket建立，而在Java中，用Socket API封装了操作系统套接字以快速建立TCP请求，底层调用了<code>native socket0()</code>创建操作系统套接字；这些Java网络API提供了一系列方便的方法来创建和管理TCP网络连接，封装了底层TCP&#x2F;UDP网络细节，使得网络编程变得更加容易和高效。我们在Socket API上的编程，其实就是应用层编程了，你在TCP报文中所传输的内容就相当于应用层报文，当你制定一个的报文传输和解析的标准与服务，就应用层协议。</p><p>TCP的报文头包含源端口、目标端口、ACK和检验和等等，设计复杂而且与上层应用相关度低，报文的设计为了保障报文传输的安全和可靠，HTTP报文就是TCP报文的正文部分，具体在Java API中的体现就是，Java Socket的inputstream()是TCP的数据报文，或者说TCP报文的正文部分，即应用层报文的全部内容；而HttpURLConnection中的inputstream是HTTP报文的正文部分。</p><p>Tomcat服务器或者说应用层服务器做了什么呢？第一当然是接收TCP请求；第二解析应用层报文；第三提供一组API，让用户方便的获取报文的某个部分，组装报文发送。</p><h4 id="TCP-UDP编程"><a href="#TCP-UDP编程" class="headerlink" title="TCP&#x2F;UDP编程"></a>TCP&#x2F;UDP编程</h4><p>TCP&#x2F;UDP即<strong>传输控制协议</strong>和<strong>用户数据报协议</strong><br>互联网建立在<strong>TCP&#x2F;IP</strong>协议族（包含TCP、IP、UDP、ICMP等协议）基础上，<a href="https://blog.csdn.net/qq_26816591/article/details/53022183">网络报文图</a>，路由器只工作在网络层，只处理IP数据报的分发；<a href="https://zhuanlan.zhihu.com/p/53374516">TCP协议</a>通过三次握手建立连接，四次挥手关闭连接。TCP和UDP是两套端口，在TCP连接的建立过程中，客户端（本地浏览器）和服务器端（HTTPS网站）都需要分配一个端口。服务器端通常使用预定义的端口（在HTTPS的情况下是端口443），而客户端则使用一个临时的、动态分配的端口。</p><p>Java TCP&#x2F;UDP编程 API：<code>ServerSocket、Socket</code>；<code>DatagramSocket、DataGramPacket</code></p><p>TCP编程使用<strong>流</strong>来处理数据，因为它提供了可靠的、有序的数据传输，当客户端<code>new Socket(host, port)</code>时，就建立TCP连接，服务器每<code>serversocket.accpet()</code>到一个新连接，就会开启一个线程，处理socket。而<strong>UDP不使用流</strong>，因为它是基于独立数据包的无连接通信，datagramsocket.send()和receive()方法直接实现用户数据报的收发。</p><h4 id="HTTP客户端的使用"><a href="#HTTP客户端的使用" class="headerlink" title="HTTP客户端的使用"></a>HTTP客户端的使用</h4><p>HTTP是建立在TCP基础上应用层协议，HTTP的端口实际就是指的TCP端口，HTTP报文由<strong>起始行、头部、正文</strong>三部分组成，然后头部和正文之间有空行，请求报文的起始行教请求行，响应报文的起始行叫状态行，常用的头比如Cache-Control、Content-Type、Accept、Cookie、Authorization等</p><p>请求报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br></code></pre></td></tr></table></figure><p>响应报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br></code></pre></td></tr></table></figure><p>HTTP的特性：</p><ol><li><strong>无连接</strong>；即请求时连接，返回响应就释放连接。多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消。</li><li><strong>无状态</strong>：每个HTTP请求是独立的，服务器不会记住之前的请求和响应的状态。所以用<strong>Cookie和Session</strong>来模拟状态信息。</li></ol><p>GET请求参数放在URL中，这部分参数也称params，如果参数是中文，中文字符要编码成UTF-8的字节码，Java中使用<code>URLEncoder.encode(keyword, &quot;UTF-8&quot;)</code>，POST请求：post请求的参数放在报文体中</p><p><code>URL</code>和<code>HttpUrlConnection</code>是Java的HTTP客户端编程传统API，实现了使用HTTP协议的诸多特性，而服务器端HTTP编程是编写Web服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLPostExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">urlString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;<br><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(urlString);<br>        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>        <span class="hljs-comment">// 设置请求方法为POST</span><br>        connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>        <span class="hljs-comment">// 设置请求头内容类型为JSON</span><br>        connection.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json; utf-8&quot;</span>);<br>        <span class="hljs-comment">// 设置请求头接受内容类型为JSON</span><br>        connection.setRequestProperty(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>        <span class="hljs-comment">// 允许输出，以便可以发送请求正文</span><br>        connection.setDoOutput(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 创建请求正文</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonInputString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;title\&quot;: \&quot;Sample Post\&quot;, \&quot;body\&quot;: \&quot;This is a sample post.\&quot;, \&quot;userId\&quot;: 1&#125;&quot;</span>;<br><br>        <span class="hljs-comment">// 将请求正文写入输出流</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> connection.getOutputStream()) &#123;<br>            <span class="hljs-type">byte</span>[] input = jsonInputString.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>            outputStream.write(input, <span class="hljs-number">0</span>, input.length);<br>        &#125;<br><br>        <span class="hljs-comment">// 读取响应状态码</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">responseCode</span> <span class="hljs-operator">=</span> connection.getResponseCode();<br>        System.out.println(<span class="hljs-string">&quot;Response code: &quot;</span> + responseCode);<br><br>        <span class="hljs-comment">// 如果响应状态码为201（HTTP_CREATED），则读取响应内容</span><br>        <span class="hljs-keyword">if</span> (responseCode == HttpURLConnection.HTTP_CREATED) &#123;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(connection.getInputStream()));<br>            String line;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">responseContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                responseContent.append(line);<br>            &#125;<br><br>            reader.close();<br><br>            System.out.println(<span class="hljs-string">&quot;Response content: &quot;</span> + responseContent.toString());<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭连接</span><br>        connection.disconnect();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 11引如了 <code>HttpClient</code> API，基于NIO实现，所以相比基于传统IO实现的HttpURLConnection，HttpClient具有更好的性能和更丰富的功能，如支持HTTP&#x2F;2、自动管理连接池和响应式流等。</p><h4 id="邮件协议（SMTP）"><a href="#邮件协议（SMTP）" class="headerlink" title="邮件协议（SMTP）"></a>邮件协议（SMTP）</h4><p>邮件客户端MUA（Main User Agent）通过<strong>SMTP</strong>协议与自己邮件系统的MTA服务器（Mail Transfer Agent）交互，MTA是SMTP服务器，MTA继续通过SMTP协议传输至收件系统的MTA。</p><p>进入收件人邮件系统后，MTA服务器先投递给MDA服务器（Mail Deliver Agent），MDA将邮件存储到用户的“Mail Box”中，有专门的<strong>IMAP</strong>或<strong>POP3</strong>收件服务器，与收件人邮件客户端直接交互。</p><p>![[邮件协议.png|500]]<br>javax.mail实现了MUA客户端的功能，能够实现收发邮件</p><h4 id="NIO和AIO和操作系统IO模型"><a href="#NIO和AIO和操作系统IO模型" class="headerlink" title="NIO和AIO和操作系统IO模型"></a>NIO和AIO和操作系统IO模型</h4><p>传统TCP编程Socket基于IO流进行数据传输，IO流读写操作是阻塞的，传统IO的read方法，会先让数据在内核缓冲区完全就绪，然后在Memory Copy到Java内存中，整个过程可能随着read的数据大，而导致阻塞时间过长。</p><p>例如，在单线程BIO Socket服务器中，如果客户端数据很大，或者客户端没有关流，这样read或者write过程，网络可能占据更长的耗时，而操作系统进行真正IO的时间其实很少，线程阻塞时间长，其他客户端暂时无法与服务器建立TCP连接。BIO下，如果要实现1个服务器同时处理多个客户端数据，只能增加线程数提高响应性能，这种模式成为<strong>thread-based architecture</strong>。</p><p>NIO（New IO）是从Java 1.4开始的一种<strong>非阻塞IO</strong> API和网络API，相当于传统IO流和传统Socket API的进化版本，应对<strong>高并发</strong>的网络编程出现的，是<strong>事件驱动架构</strong>（event-driven architecture），在API使用上的体现是，Selector去监听系统事件。NIO事件驱动的实现基于操作系统多路复用API（如epoll等），可以在操作系统层面注册四种事件，connect、accept、read、write，如读事件和写事件,只有当操作系统<strong>内核缓冲区内的数据完全就绪</strong>，也就是程序真正可读或者真正可写了，才会被Java程序所监听到，直接进行memory copy，这种就是非阻塞IO，这种事件驱动机制，使得在单个线程可以处理大量的并发连接。</p><p>API方面，NIO使用channel通道和buffer缓冲区进行数据传输，搭配selector轮询器，使单个线程处理多个数据通道；共有4种channel，即SocketChannel、ServerSocketChannel、DatagramChannel、FileChannel。要注意两点的是：</p><ol><li>可以使用FileInputStream.getChannel()获得FileChannel，通过channel去操作文件，如果要进行读写，就需要在inputstream和outputstream的基础上构建两个FileChannel对象，而socketChannel是双通道的，一个socketChannel对象可以进行读和写；</li><li>另外，FileChannel不能切换到非阻塞模式，不能搭配selector使用，而<strong>socketChannel必须使用非阻塞模式搭配selector</strong>。</li></ol><p>简单NIOserver中，selector.register()监听serverSocketChannel的accept事件；轮训selector.select()，没有监听事件时select()会一直阻塞，监听到任意事件，使用selectedKeys()取所有的事件处理；acceptable时，accept()建立新的socketChannel通道，并register监听新socketChannel的READ事件。</p><h4 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h4><p>Reactor和Proactor是两种网络模型</p><p>Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即使用I&#x2F;O多路复用API监听事件，收到事件后，根据事件类型分配（Dispatch）给某个业务线程。NIO是一组API，他可以用来设计成Reactor模式，如Netty</p><ol><li>单Reactor单线程，也就是工作线程直接在Reactor线程上处理，Reactor虽然解决了IO阻塞，但一旦业务操作执行时间长，例如进行部分数据库操作，就会阻塞，单工作线程也不适合CPU密集型工作。采用<strong>单Reactor单线程模式的例如Redis</strong>，业务操作简单，而且完全基于内存，响应速度很快，对CPU依赖度低。</li><li>单Reactor多工作线程，单Reactor负责接收和响应操作系统的所有事件，业务逻辑通过工作线程池处理，解决了单Reactor单线程模式下，易发生业务阻塞和CPU利用率低的问题，但是单Reactor面对瞬时高并发场景，容易成为性能瓶颈，所以就将单Reactor变为多Reactor。</li><li>多Reactor多线程，mainReactor只负责建立网络连接，然后将socketChannel传递给subReactor线程，进行读写响应和业务处理。如Netty、Nginx。Spring 5的异步、Dubbo、RocketMQ等等</li></ol><p>Proactor异步IO模型，AIO就是采用这种模型，性能不一定比NIO高，但处理长耗时IO如文件下载有一定的优势，在Reactor 同步非阻塞IO模式下，JVM会一直使用操作系统IO多路复用API轮训是否就绪可read，最后channel.read()，也就是从内核缓冲区memorycopy到jvm内存的过程是同步的，而Proactor，最后由内核缓冲区到jvm内存的过程也是由内核完成的，最后由操作系统通知。</p><p>到这里，<strong>非阻塞IO是就绪读通知，异步IO是完成读通知</strong>。AIO理论性能会比NIO稍高，但应用非常少，成熟度一般，在Linux支持度一般，netty 5进行过实践弃用。</p><p>参考：<a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？-小林回答</a>、<a href="https://zhuanlan.zhihu.com/p/95662364#:~:text=Reactor%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A2%AB%E5%8A%A8,%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E3%80%82">高性能IO模型分析</a></p><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><p>Netty是JBoss基于NIO封装的开源异步网络API，源码层面很复杂，但是使用上却比NIO简单，需要处理高并发网络、实现自定义协议时更高层次抽象的Netty API，而不是直接使用传统网络编程Socket、NIO网络编程SocketChanel这些API。</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>主流的JavaWeb框架，例如SpringMVC，都是默认处理HTTP请求。</p><p>HTTP服务器首先肯定基于TCP，需要服务端不断的accept()或者其他形式去监听TCP端口，Tomcat服务器就是典型的HTTP服务器，同时Tomcat也是一个Java应用程序容器，部署相应的Java程序，也就相当于服务器支持了相应的网络通讯。</p><p>系统之间的交互，都可以称之为RPC，大部分情况下直接使用HTTP协议交互足够，可以自行协商交互报文，也可以在HTTP上使用标准的RESTful协议用于接口交互。很多RPC框架会觉得应用层通用的HTTP协议，用于系统间的通讯比较冗长，他们自定义了一些协议，例如sofaRPC、 Dubbo、gRPC、Spring Cloud之间，都是自定义协议，这些自定义协议其实就是基于Java Socket API开发的一套应用层协议+应用层服务器，RPC框架实现这些，其实和写一些HTTP服务器大同小异，都是在Socket API之上处理上层协议。</p><ul><li>实现系统间的连接通讯</li><li>实现报文高效的发送、分发和解析</li><li>定义易于理解和维护API规则，或者说应用层报文的规则</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流</title>
    <link href="/2023/12/09/Java/%E6%96%B0blog/4.Java%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/09/Java/%E6%96%B0blog/4.Java%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!question]- 带着问题<br>因为属于复习了，先思考并整理完我的笔记，再带着具体的问题，向ChatGPT提问，不要没有想清楚自己内心的疑问是什么，就急着让ChatGPT把答案告诉你。甚至你可以带着答案提问，看你的理解，和ChatGPT的理解，有没有思维的碰撞</p><ol><li>Java中的流，也就是InputStreat、OutputStream，到底是什么样的概念，可以对Java中的这些API进行分类吗？</li><li>InputStream或者说Reader中的read()方法，如何完整的将文件读取，如果多次读取，如何拼接读取到的字符或者字节？</li></ol></blockquote><p>“流”是<strong>程序与目标数据源</strong>之间，高效读取和写入的一个抽象概念。建立一个流，具体在Java中的就是建立了一个流的对象，如new FileInputStream(“file”)。<br>流基于程序和目标数据源，那他所有的“输入流”其实都是针对于程序内存，目标数据源有几种</p><ul><li>目标数据源为文件的<strong>文件流</strong>；</li><li>还有一种<strong>网络流</strong>，目标数据源是TCP的客户端或者服务端，如socket、url等API连接产生的流。</li><li>无需存储在磁盘时，在Java程序虚拟出输入流输出流，目标数据源在程序内存的<strong>内存流</strong>（ByteArray流）</li></ul><h4 id="操作流需要注意的几个问题"><a href="#操作流需要注意的几个问题" class="headerlink" title="操作流需要注意的几个问题"></a>操作流需要注意的几个问题</h4><ol><li>IO流无论是**输入流或者输出流结束后都需要手动调用close()**，除非使用了 <strong>try-with-resource</strong> 这个Java 7以后提供的API开启的流，如果不关流，会一直占用操作系统资源，例如文件资源和网络资源。保持最后打开的流先关闭，例如要先关buffered流，再关掉buffered关联的File流，推荐使用try-with-resource。</li><li>需要注意**输出流写入完成后需要进行flush()**，否则有可能出现写入不成功的情况，因为在write时，为减少IO次数，会将数据写入至缓冲区中，只有当写满了缓冲区或者调用flush才会正式将文件写入，即使close流时最后会将缓存中还未完成真正写入的进行文件写入，但是可能close抛出异常导致文件写入不全，反正从规范性上来说，强烈推荐在输出流write()后调用flush()。</li><li>流是单向的，虽然<strong>网络流有两条双工的单向流</strong>，包含流实际操作也是单向的，inputStream就只能read。在网络连接中，可以关闭一条流保持半关闭，而不关闭整个TCP连接，例如使用socket.shutdownOutput()这样就是服务器关闭输出流，保持一种半关闭状态。</li></ol><h2 id="基本IO流"><a href="#基本IO流" class="headerlink" title="基本IO流"></a>基本IO流</h2><p>字节流InputStream和OutputStream，字符流Reader和Writer是Java IO中最重要的基类，而FileInputStream&#x2F;FileOutputStream 与 FileReader&#x2F;FileWriter是他们最重要的子类，操作目标为“文件”，他们的构造方法，需要指定操作的文件，传入<strong>File类对象或者字符串</strong>都可以完成指定，传入字符串会自动转化成File类对象；在输出流的构造方法中，可以传入第二个是否append的参数，为true时，文件追加写入，第二个参数为false或者不传时，文件覆盖写入。<br>基本上所有的IO流都可以用下面的通用API。</p><h4 id="1-核心读取方法："><a href="#1-核心读取方法：" class="headerlink" title="1. 核心读取方法："></a>1. 核心读取方法：</h4><p>通常读取数组后，要将byte数组或char数组转化成String，<strong>请使用String的构造方法将2种数组转化成String</strong>，不要使用数组的toString方法，这是Object方法，会返回类名和哈希值的信息，并不会转化成String。<br>而且推荐使用<code>new String(buffer, 0, readLength)</code>这个构造方法，这样而不是<code>new String(buffer)</code>，这样buffer没有读满时，buffer写入String中不会包含多余的空格。第二个参数代表“读取偏移量”，通常是0，代表从buffer数组的第1个字节开始写入，写入整个buffer，如果你不需要写入整个buffer，可以更改。<br>如果。<br>转化成String时，可能需要多次读取，来拼接最终的数组，拼接字符串一般就使用StringBuilder和StringBuffer，不是多线程环境或者没有线程安全问题，使用StringBuilder的性能略高。</p><ol><li>无参read()，每次读取1个字节&#x2F;字符到返回值，读到末尾会返回-1。使用while循环读取，可以</li><li>有参read(buffer数组)，方法参数传入指定长度的字节数组或字符数组，按数组长度读取字节或字符，同时返回实际读取的字节或字符数，读到末尾时返回-1。这个利用缓冲区来读，一般用这个会更多一点点，但是在边读边写的时候，搭配write(byte[ ] b, int off, int len)使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> Builder();<br><span class="hljs-type">byte</span>[ ] buffer =<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bufferLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>( ( bufferlength = inputstream.read(buffer) ) != -<span class="hljs-number">1</span> )&#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,bufferLength);<br> stringBuilder.append(str);<br>&#125;<br>System.out.println(stringBuilder.toString());<br><br></code></pre></td></tr></table></figure><h4 id="2-核心写入方法"><a href="#2-核心写入方法" class="headerlink" title="2. 核心写入方法"></a>2. 核心写入方法</h4><p>通常写入前需要将String转化成数组，请使用String的实例方法getBytes()和toCharArray()进行转化。这里提一个热知识，编写原生JSON串时，编辑器要求写很多转义符“\”，转义符只存在于Java代码层面，在编译成字节码就不存在了，在内存中处理和控制台打印都是不存在转义符的。</p><p>输出流也有两个常用写入方法，字节流写入byte数组，字符流同理写入char数组，但字符流可以write(String str)：</p><ol><li>write(byte[ ] b)，写入整个数组。</li><li>write(byte[ ] b, int off, int len)，指定写入数组的偏移量和长度，例如写入byte数组，从第10个字节开始，写20个字节。</li></ol><p>日常用普通的write方法足够，但是，和上面的String情况相似，当你的输入流是通过buffer去读取的，而你想直接将读到的buffer块写入时，请搭配可以指定偏移量的write方法，防止在buffer没有读满时，write了我们不需要的空字符串导致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Byte[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>((size = in.read(buffer))!= -<span class="hljs-number">1</span>)&#123;<br>  out.write(buffer,<span class="hljs-number">0</span>,size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-字节字符转化流"><a href="#3-字节字符转化流" class="headerlink" title="3. 字节字符转化流"></a>3. 字节字符转化流</h4><p><code>InputStreamReader</code>、<code>OutputStreamWriter</code>是FileWriter&#x2F;FileReader是的父类，<strong>将字节流转化成字符流</strong>，不能使用FileReader&#x2F;FileWriter接收，可以用Writer&#x2F;Reader或者本身引用接收，将字节流转化成字符流后搭配BufferReader或BufferWriter，进一步使用readLine或者newLine方法，尤其是搭配BuffedReader非常常见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">consoleReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>consoleReader.readLine();<span class="hljs-comment">//和scanner.nextLine()类似</span><br></code></pre></td></tr></table></figure><p><code>PrintWriter</code>也是在网络流中常用的字节字符转化流，字节输出流转Writer，用PrinWriter类接收，独有的封装方法println()，等同使用BufferedWriter的write()加newLine()，抽象程度更高，既有缓存装饰，也能够直接完成字节流转成Writer，他的构造方法可以是File类、Writer、OutputStream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream, <span class="hljs-literal">true</span>);<br>writer.println(userInput);<br></code></pre></td></tr></table></figure><h4 id="4-内存流"><a href="#4-内存流" class="headerlink" title="4. 内存流"></a>4. 内存流</h4><p>ByteArrayInputStream&#x2F;ByteArrayOutputStream也就是内存流，不同于一般的目标数据源是“文件”或者“网络”，在Java程序中，我们虚拟的构造出一个字节流，我们需要借助流操作，就使用内存流。使用场景：</p><ol><li>我个人的理解的第一种用法是临时存储，通过网络输入流或者文件输入流read数据时，有一种后续处理，是我们同步使用输出流write，例如服务器文件的上传与保存；还有一种后续处理，是read后将数据先在Java程序程序，如果是文本数据，我们可以通过StringBuffer来拼接多次read的数据，但如果是二进制数据，我们一般在Java程序中构建一个虚拟的输出流，即<code>ByteArrayOutputStream</code>，read的同时同步write数据，最后使用<code>toByteArray()</code>转化成完整的byte数组，达到临时存储的作用，再统一处理的作用，例如进行加密或者解密等操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 对读取到的数据进行加密</span><br>    <span class="hljs-type">byte</span>[] encryptedData = encryptData(buffer, len);<br>    bos.write(encryptedData, <span class="hljs-number">0</span>, encryptedData.length);<br>&#125;<br><span class="hljs-type">byte</span>[] data = bos.toByteArray();<br>fis.close();<br></code></pre></td></tr></table></figure><ol start="2"><li>搭配对象流，不借助文件在内存中完成对象序列化和反序列化，实现clone()深拷贝，参考下边“装饰流的对象流部分”</li></ol><h2 id="装饰流"><a href="#装饰流" class="headerlink" title="装饰流"></a>装饰流</h2><p>使用装饰流，传入普通的输入流和输出流，让输入输入流有更多的API功能，例如字符缓冲、读写对象和读写二进制。</p><h4 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1. 缓冲流"></a>1. 缓冲流</h4><p>BufferedInputStream&#x2F;BufferedOutputStream 与 BufferedReader&#x2F;BufferedWriter这几个类是缓冲流，Buffered流是字节流字符流基类的装饰器，<strong>他们的构造方法需要接收字节流字符流基类对象</strong>来实现自身实例化，也就是说在使用装饰流时，；相比普通File流，方法使用上没什么区别，但增加了内存缓冲区，多次读取和写入时，减少了IO的次数，尤其可以提高大文件的读写效率。要使用他们本身引用来接受缓冲流对象，会增加一些独有方法：</p><ol><li>BufferedReader中的readline()方法读取一行，返回String，没有下一行返回null</li><li>BufferedWriter的newLine()方法，换行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">inputStreamReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.conf&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(inputStreamReader);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">while</span>((line=bfr.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>bufferWriter.write(line);<br>    bufferWriter.newLine();<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-对象流"><a href="#2-对象流" class="headerlink" title="2. 对象流"></a>2. 对象流</h4><p>对象流就是ObjectOutputStream和ObjectInputStream，对象想要能够通过对象流持久化保存，需要实现下面两种接口，transient关键字用于申明属性不应该被序列化，序列化以后会用默认值序列化。</p><ul><li>实现Serializable空接口，就对对象进行序列化，如果属性是类，也需要实现serializable接口才能完成序列化，序列化版本号用于标记对象版本，不写继承Serializable会根据类的属性进行哈希计算一个。</li><li>实现Externalizable接口，重写writeExternal和readExternal方法，能够更精细化控制序列化的属性，较少使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>; <span class="hljs-comment">// 序列化版本号，建议显式声明</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 序列化对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>oos.writeObject(s);<br>oos.close();<br><br><span class="hljs-comment">// 反序列化对象</span><br><span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) ois.readObject();<br>ois.close();<br>bis.close();<br>bos.close();<br></code></pre></td></tr></table></figure><h4 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3. 数据流"></a>3. 数据流</h4><p>数据流是DataInputStream和DataOutputStream，数据不通过原始字节保存，使用<code>writeInt(1999)、WriteUTF(&quot;String&quot;)、readUTF()</code>等方法，将数据以Java二进制的形式保存或读取，使用方式上和各类装饰流大同小异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> ( <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/file&quot;</span>)) ) &#123; <br>dos.writeInt(<span class="hljs-number">123</span>); <br>dos.writeFloat(<span class="hljs-number">123.45f</span>); <br>dos.writeUTF(<span class="hljs-string">&quot;Java数据流&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2023/12/06/Java/%E6%96%B0blog/3.Java%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/12/06/Java/%E6%96%B0blog/3.Java%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda和方法引用"><a href="#Lambda和方法引用" class="headerlink" title="Lambda和方法引用"></a>Lambda和方法引用</h2><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p>Java源码中存在很多<strong>单抽象方法的接口</strong>，称函数式接口，通常会用@FunctionalInterface标记，如Comparator、Runnable、Callable、Function。函数式接口作为方法的接收参数时，我们通常通过匿名内部类的形式，直接创建函数式接口的实例化匿名类对象。<br>Java8以后，可以用Lambda表达式来<strong>简化函数式接口的匿名类</strong>编写，编译器会通过lambda表达式推断出函数式接口的匿名实现类，而且性能会比直接编写匿名类更高。<br>编写方式：不需要写传入参数的类型，也不需要写返回值，编译器会自行推断，Lambda表达式实际生成了匿名内部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lamda表达式详写</span><br>Function&lt;String, String&gt; fun = name -&gt; &#123; <br>  <span class="hljs-keyword">return</span> name.toUpperCase();<br>&#125;<br><span class="hljs-comment">// Lambda表达式简写，一行代码时，省略花括号，省略return</span><br>Function&lt;String, String&gt; fun = name -&gt; name.toUpperCase();<br></code></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用可以说是Lambda表达式的子集，因为方法引用一定可以用Lambda表达式表达，但理念和用途上可以说完全不一样，lambda表达式强调一段独立处理，传入的参数可以自由的处理（方法引用只能通过方法签名参数引用），很多函数式接口都可以使用，尤其是Runnable等接口的使用；而方法引用，强调直接关联一个已经存在的方法，需要抽象方法和引用方法之间参数的完全匹配，通常是源码中提供的方法，最常搭配Stream AP使用。</p><p>使用方式：在函数式接口引用要接受数据的情况，可以选择与抽象方法签名匹配的方法，什么叫签名匹配，就是<strong>方法传入参数的数量和类型，以及方法的返回值完全匹配</strong>，这个方法就可以作为方法引用，<strong>这个方法引用，同Lambda表达式一样，实际推导成了匿名内部类对象</strong>。</p><ol><li><p>引用静态方法：显性签名一致，直接可以引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(array, Main::cmp);<br></code></pre></td></tr></table></figure></li><li><p>引用实例方法：</p><ul><li>类实例方法引用：隐性的包含一个自身类型的this引用，作为实例方法签名的第一个参数，例如下面的例子，实际签名可以看为<code>int compareTo(String this,String 0)</code>，所以与需要传入的compare()方法的签名还是匹配的。</li><li>对象实例方法引用：方法签名是不包含对象this的引用<br> 下面map()和forEach()的例子中，明显的表示出这种区别，map需要传入一个Function对象（1个传入参数，1个返回值），toLowerCast是一个无参方法，但类实例方法隐形包含String this.toLowerCast()，Strream流中的参数过来，首先会匹配到String this的位置；与之不同，forEach需要传入一个Consumer对象（1个传入参数，无返回值），println(String x)是一个有参方法，使用对象实例方法引用，Stream流中的参数，会匹配到String x的位置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span> &#125;;<br>Arrays.sort(array, String::compareTo).map(String::toLowerCast).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>引用构造方法时，如：<code>Person::new</code>，虽然构造方法没有return语句，会隐性的包含返回一个Person类型的this对象，所以也要注意匹配</p></li></ol><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream API是一个处理集合和数组的流式API，在处理之前，我们需要先将数据转化成Stream对象，可以使用<code>Stream.of(&quot;a&quot;,&quot;b&quot;)</code>这个静态方法直接构建Stream对象，也可以通过<code>Arrays.stream( arr )</code>这个静态方法，将数组转化成Stream，更多的时候，我们通过<code>list.stream()</code>这个Collection集合的实例方法，将List和Set集合转化成Stream对象。<br>连接两个Stream流：Stream.contact(a,b)合并a和b两个stream，返回成一个Stream<br>处理基本数据类型的数据时候，例如对一个int型数组进行流式操作，我们要使用<strong>IntStream</strong>接收，而不是Stream&lt;Integer&gt;，同理的还有LongStream、DoubleStream，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><p>有了前期的准备工作，我们可以开始进行流式处理，为什么说流式处理，因为中间操作的方法的返回值任然是一个Stream对象，可以连续处理，Stream API的操作分为中间操作和终端操作，<strong>只有终端操作开始，才会真正开始处理</strong>，如果没有执行终端操作，进行中间操作lambda里面的内容是不会执行的。</p><h4 id="常用中间操作"><a href="#常用中间操作" class="headerlink" title="常用中间操作"></a>常用中间操作</h4><ul><li>map，引用为Function接口，方法只有1个入参和返回值且都为泛型。方法内可以写Lambda，也可以写方法引用</li><li>fitter：传入1个泛型参数，返回一个boolean参数。filter一般搭配Lambda定制过滤的规则。 <code>stream.filter(s -&gt; s != null &amp;&amp; !s.isBlank())</code></li><li>sorted：元素实现Comparable就可以直接调用；没有就传入一个比较器</li><li>distinct：需要元素重写equals和hashmap方法</li><li>skip(3)：跳过Stream前三个元素截取</li><li>limit(2)：截取stream流中的前两个元素</li></ul><p>flatmap操作：传入1个泛型参数，返回一个Stream。flatmap用来理嵌套的数据结构，将一个嵌套的流的映射形成一个扁平的流。例如下边的例子中，List::streamList，nestedNames这个Stream中的，list会调用list.stream()，返回到flatMap的主Stream中，最终形成扁平的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; nestedNames = Arrays.asList(<br>        Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>),<br>        Arrays.asList(<span class="hljs-string">&quot;Cathy&quot;</span>, <span class="hljs-string">&quot;David&quot;</span>)<br>);<br><br>Stream&lt;String&gt; flattenedNames = nestedNames.stream().flatMap(List::stream);<br><span class="hljs-comment">// 结果：[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cathy&quot;, &quot;David&quot;]</span><br></code></pre></td></tr></table></figure><h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>1个终端操作之后，不能再进行其他的终端操作，例如<strong>进行了reduce以后，不能再使用collect(Collectors.toList())等方法</strong></p><ol><li><p>reduce：对元素进行聚合计算，比如说累加操作、累乘操作、聚合Map等等，推荐使用带初始值reduce(T identity, BinaryOperator&lt;T&gt; accumulator)，其BinaryOperator的抽象方法，需要传入2个参数，返回1个参数，例如<code>reduce(0, (acc,n) -&gt; acc+n )</code>，BinaryOperator中第1个参数为上次计算的结果，第2个参数stream元素的值。</p></li><li><p>collect操作：**collect(Collectors.toList())**，还可以传入Collectors.toSet()、Collectors.toMap()，要注意toMap()方法有两个参数，需要指定两个Lambda表达式进行两个值的映射。<br> Collectors.groupingBy()，groupingby内的方法引用，1个传入参数，返回1个String。目的让我们写一个Lambda表达式作为分组的Key，默认被Collectors.toList()收集器所收集。<br> 另外还有一个带两个参数的重载方法，可以在groupingBy()方法中输入第2个参数，指定用其他收集器例如Collectors.toSet()或者Collectors.counting()来统计分组的结果。</p></li></ol><p>假设我们从数据库中取到了List&lt;Student&gt;，我们在Java程序中按照班级进行分组，就可以使用Stream API的groupingby功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, List&lt;Student&gt;&gt; grouped = studentList.stream().collect(Collectors.groupingBy(Student: :getClassId,Collectors.toList()));<br></code></pre></td></tr></table></figure><ol start="3"><li>for-each：一般用来循环打印，<code>stream.forEach(System.out: :println)</code>，你也可以在循环体通过Lambda写自己想要循环执行的事情</li><li>count()、anyMatch()</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础语法糖</title>
    <link href="/2023/09/06/Java/%E6%96%B0blog/1.Java%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2023/09/06/Java/%E6%96%B0blog/1.Java%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常是Java源码定义的一组类，当然你也可以继承某些异常基类来自定义异常，反正异常抛出来，代码表示代码出现了“错误”。</p><p>Java中有2大类异常：</p><ol><li><strong>运行时异常</strong>（非受检异常），IDE不需要不捕获的异常。这种异常一般就意味着代码有问题，出现了不应该出现的一些错误，比如空指针异常、数组越界异常，我们应该去修改代码的问题。当我们自定义异常不想要IDE在编译阶段强制我们处理异常时，也可以继承运行时异常作为基类</li><li><strong>检查性异常</strong>（编译时异常），IDE会要求必须捕获也就是必须try-catch的异常。这种异常意味着你对这部分API应该进行容错处理，try-catch就是为了容错处理，万一没有按照要求执行，我们应该如何继续处理，比如IOException、SQLException等，这些操作非常容易没有按照要求继续。</li></ol><p>异常的产生，都是你在调用这些Java API的时候，源码的方法throws了异常，对于运行时异常，IDE不会在编译阶段，让抛出的异常进行try-catch或者throws，但对于检查性异常，这要求我们在编译前必须捕获，如果不捕获，那就必须方法签名再throws给上层调用方。一般来说，如果是执行层面的代码，就一般会try-catch，如果是封装层面的API，throw异常并方法签名throws是一种常规操作，表示你调用我API失败后，必须容错处理。</p><p>对于try-catch，try块捕捉异常对象，catch块决定捕捉异常后的处理方式，要注意try代码块中，抛出异常，后面的代码不再可达。自己去裁定try的范围，需要明细打印问题，可以精细化try-catch处理，自己结合工作实践合理的去划定try的范围，使代码更清晰，可读性更高。然后在try执行代码块中主动throw一个Exception，然后在catch，这是<strong>异常用于流程控制</strong>的一种使用，有些情况相比于if-else，可能更加清晰的标注了“错误”的代码处理逻辑，保持代码的清晰性。</p><p>抛出异常后，在catch中使用e.printStackTrace()，只会在控制台打印堆栈信息，如果要记录在日志中，则需要利用日志工具将堆栈信息印在日志中，大部分日志工具都会提供<code>log.error(&quot;&quot;,e)</code>的方法打印堆栈信息至日志。</p><h2 id="变量和方法的设计"><a href="#变量和方法的设计" class="headerlink" title="变量和方法的设计"></a>变量和方法的设计</h2><p><strong>Java类由成员变量和方法组成</strong>，任何的代码都是从方法内部开始的。</p><p>传入参数到方法时，或者说变量赋值是，基本数据类型是<strong>值传递</strong>，引用类型数据时<strong>引用传递</strong>，此时方法内对参数进行修改，也会影响原始值，这是Java的设计，如果不想改变引用类型数据的值，在方法内部使用clone或者其他方式创造副本再进行操作。</p><p>对于成员变量的设计，除了类标志性的属性可以设置为成员变量，试情况也可以将一些需要外部传入的业务流水号等，设置为成员变量，不需要将所有外部传入的值，全部通过方法参数传入。很多纯逻辑处理的工具类，是没有成员变量的，里边可能就全是static方法。注意成员变量设置的时候一般就全部设置为private访问控制符，很少设置成其他访问控制符。</p><ol><li>（类的）成员变量：定义在方法外的变量，<strong>有默认值</strong>，引用类型的变量默认值是null（**String初始化建议写””**），布尔类型默认值为false，加载在堆内存中，随着对象产生或消亡。</li><li>（方法的）局部变量：定义在方法中的变量，<strong>局部变量无默认值，使用前必须要初始化</strong>。局部变量的创建在栈内存中，随着方法产生和消亡，即随线程产生或消亡。</li><li>静态变量（类变量）：是一种特殊的成员变量，成员变量基础上加用static关键字修饰属性，类加载时产生（class文件读取到内存中）</li></ol><h2 id="流程语法"><a href="#流程语法" class="headerlink" title="流程语法"></a>流程语法</h2><p>break跳出控制语句（switch，for，while等），continue跳出本次循环（用于for循环），return跳出整个函数</p><p>在判断语句中，<strong>单纯判断、char、byte、short、int和String（JDK 7 ）的值情况</strong>可以用switch代替if-else<br>switch效率比if-else高，但是灵活度非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    System.out.println(<span class="hljs-string">&quot;this is one.&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    System.out.println(<span class="hljs-string">&quot;Others.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resource和try-catch-finally"><a href="#try-with-resource和try-catch-finally" class="headerlink" title="try-with-resource和try-catch-finally"></a>try-with-resource和try-catch-finally</h4><p>Java 7以后，数据库连接和流，可以使用try-with-resource代替try-catch-finally，让代码变得更简单，资源会自动关闭，不再需要在finally里调用close方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 读取文件数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-comment">// 处理异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包与访问权限控制"><a href="#包与访问权限控制" class="headerlink" title="包与访问权限控制"></a>包与访问权限控制</h2><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>当我们需要使用<strong>非本包中的类</strong>时，用import关键字导入包的具体类或所有类；或者直接在代码中写类。只有lang包下的类和同一个包下的类不需要导包，可以直接使用类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.zhuxin.*  <span class="hljs-comment">//通配符导入com.zhuxin包中所有的类</span><br><span class="hljs-keyword">import</span> com.zhuxin.Demo<span class="hljs-comment">//导入com.zhuxin包中的Demo类</span><br><span class="hljs-comment">//JDK5后，支持导入静态属性，称静态导入，导入System类中的out属性</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.out<br></code></pre></td></tr></table></figure><h4 id="类、方法和属性的访问权限控制符"><a href="#类、方法和属性的访问权限控制符" class="headerlink" title="类、方法和属性的访问权限控制符"></a>类、方法和属性的访问权限控制符</h4><ul><li><p><strong>类的属性与方法的访问控制</strong></p><p>当你对类有访问权限后（同包类，或者导包后），访问权限控制符，约束了调用类中成员变量和成员方法能否被直接调用，下面访问权限越来越大</p><ol><li><strong>private</strong>：除了在本类，均不能被直接访问，即使是继承了父类的子类，这也是最常使用的权限控制符</li><li>不加修饰符：可以被<strong>同包</strong>的类直接访问，又称为包级访问权限。要注意的是，对于接口，他不是类，所有方法和属性只能是public权限，所以接口不加修饰符，方法和属性就是public，而不是default的同包权限</li><li><strong>protected</strong>：可以被<strong>同包和子类</strong>直接访问，一般来说子类通常可以允许</li><li>public：可被所有包的类访问。</li></ol></li><li><p>类的访问权限，比较少使用</p><ol><li>public：修饰的类在导包后，能在所有包中使用，</li><li>不加权限（包私有类）：修饰的类只能在本包中使用，就算导包也无法访问到类</li></ol></li></ul><h2 id="Java重要的关键字"><a href="#Java重要的关键字" class="headerlink" title="Java重要的关键字"></a>Java重要的关键字</h2><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this关键字是JVM在创建对象后产生的一个<strong>指向对象本身的一个引用</strong>，根据这个原理，得出this的作用</p><ol><li>this.属性&#x2F;方法：<strong>强调本类的成员属性或成员方法</strong>，内部类中的this强调内部类本身的成员属性和方法<br>重写方法后不仅使用方法默认会指向子类重写方法，原父类方法中的this调用的方法也会指向子类重写方法。<br>属性不存在重写，就算子类有一个父类同名属性，父类方法加与不加this都是永远调用的是父类属性，子类方法永远调用的是子类的属性。</li><li>this()：<strong>在构造方法中调用本类的其他构造方法，注意必须写在构造方法第一行</strong><br>场景举例：写一个包含所有字段的构造函数，然后其他部分字段构造函数去调用这个全字段构造函数</li><li>this：单纯<strong>代指当前对象</strong><br>比如父类方法中存在return this，父类对象调用这个方法返回父类对象；子类对象调用这个父类方法，虽然是父类中的this，但是会返回子类对象，这是Java多态性的体现。</li></ol><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ol><li>super.属性&#x2F;方法：当<strong>子父类存在相同的属性或方法时</strong>，super强调当前对象父类中的属性和方法，如果不存在，子类可直接使用父类的属性方法（private修饰除外）</li><li>super()：在子类构造方法中调用父类构造方法。super方法必须写在构造方法的首行，不能和this()一同使用<br>子类构造方法默认在首行使用了super()调用了父类中的无参构造方法，要注意的是，如果父类不存在无参构造方法将会报错，<strong>注意给父类编写带参构造方法后需要注意再编写一个无参构造方法</strong>。</li></ol><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ol><li>被final<strong>修饰的类不能被继承</strong>，为了安全考虑明确禁止继承，一般很少将类设计为final类。</li><li>修饰的变量为不可更改的常量，当修饰基本数据类型值不能改变，<strong>修饰引用类型不能更改指向的对象</strong></li><li>被final<strong>修饰的方法不能被子类重写</strong>，明确禁止子类重写此方法时才用final修饰方法，父类的private方法其实是一种隐式地指定为final方法。</li></ol><h4 id="static关键字（类方法，类属性）"><a href="#static关键字（类方法，类属性）" class="headerlink" title="static关键字（类方法，类属性）"></a>static关键字（类方法，类属性）</h4><p>static修饰的属性（不能修饰局部变量）和方法，成为静态属性或静态方法，静态方法和静态属性属于类，不依赖与某个对象，可以直接<strong>通过类名调用静态属性和静态方法</strong>，但遵循访问权限控制。<strong>静态方法只能直接调用静态变量和静态方法</strong>，所以在Main方法调用的其他方法，要么是静态方法，要么是通过对象调用的普通方法。</p><p>static方法可以重写，但是不支持多态，也可以说<strong>static方法的重写不算重写</strong>，父类引用调用的还是父类中的方法，而不是子类中的同名静态方法，当然这种编写方式也没什么意义。<br>static还有一个地方用法是静态内部类，基本很少用。</p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h4 id="重载-overloadding"><a href="#重载-overloadding" class="headerlink" title="重载(overloadding)"></a>重载(overloadding)</h4><p>重载是方法名不变，<strong>形参的变化形成新的方法</strong>，返回类型可变可不变，也就是说相同的方法名实际代表不同的方法。</p><p>当没有对构造方法进行重载时，默认带一个无参构造方法，当对构造方法重载了一个有参数构造方法后，无参构造方法消失。</p><p>可变长度参数（如String… args）：0个或多个参数。方法的参数列表内可以传入不定长度的参数，只能有一个可变长参数且放于所有参数后面，在要实现不定长度参数的类型后加 **…**。Java的可变参数在编译为字节码后，在方法签名中就是以数组形态出现的（将几个参数打包成数组），所以二者同时不可重载</p><h4 id="重写-override-，也称覆写"><a href="#重写-override-，也称覆写" class="headerlink" title="重写(override)，也称覆写"></a>重写(override)，也称覆写</h4><p>重写方法是继承性的重要性质，子类的重写方法的<strong>行参和返回类型不能改变</strong>，JDK5后子类返回值可以是父类的派生类，子类重写方法<strong>访问权限不能比父类方法严格</strong>。</p><p>重写方法后，调用方法默认会指向子类重写方法，比如父类引用也会调用子类方法（提现Java的多态），同时原父类this调用的方法也会指向子类重写方法。当子类想调用父类方法不调用子类重写方法，使用super关键字调用原父类方法。</p><p>属性不存在重写，就算子类有一个父类同名属性，父类方法加与不加this都是永远调用的是父类属性，子类方法永远调用的是子类的属性。</p><h2 id="Java的几种特殊类"><a href="#Java的几种特殊类" class="headerlink" title="Java的几种特殊类"></a>Java的几种特殊类</h2><p>Java中存在3种类，普通类，抽象类和接口。抽象类在继承方面的特性和普通类一样，单继承类，多继承接口；接口可以多继承接口，当普通类实现子接口时，强制实现类重写子接口和父接口中的所有抽象方法。<strong>抽象方法即abstract方法，用abstract修饰且无方法体的方法</strong></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口定义了规范或者说协议，他是一组抽象方法的集合，public abstract可以省略。我们使用interface声明定义一个接口，然后类使用implement实现接口。<br>接口的属性只能是静态常量并很少使用，默认可以不写public static final。Java8以后，接口方法可以是default方法和static方法，这使得接口和抽象类很像，default一般用于老接口的拓展，他们都可以实现类来调用，一般不推荐在接口中使用这两种方法。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>用<strong>abstract修饰class</strong>即为抽象类，<strong>唯一特征是不能被实例化</strong>，必须被继承才能实例化。抽象类可以有属性，甚至可以没有抽象方法，有抽象方法的抽象类被继承时，子类必须实现抽象方法，要注意<strong>与接口不同，抽象类的抽象方法必须要用abstract声明</strong>；抽象类可以像普通类一样单继承类，多继承接口，继承接口也可以选择不实例化，留给继承抽象类的类实例化。</p><h4 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h4><p>内部类是一个编译时的概念，编译完成以后成为两个不同类。内部类中的this关键字指的内部类成员属性和方法，外部类名.this才是强调外部内的成员属性和方法，<br>内部类特性：可以直接调用外部类的private属性。<br>成员内部类、<strong>匿名内部类</strong>、静态内部类。Runnale接口就常用匿名内部类，这是内部类最重要的部分，其他比较少使用，参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409">廖雪峰内部类</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部类实例化依赖于外部类实例化</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><h4 id="1-封装性"><a href="#1-封装性" class="headerlink" title="1. 封装性"></a>1. 封装性</h4><p>面向对象的核心思想之一就是封装性（Encapsulation），封装就是将属性和方法这些具像的东西“装”到一个类中，私有化属性，<strong>提高安全性</strong>，<strong>隐藏实现细节</strong>。<br>我们使用API或者各种框架时，封装性使得我们忽略实现细节，只要去使用即可。</p><h4 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h4><p>子类extents父类，获得父类的属性和方法（除private属性和方法），并<strong>通过重写方法和增加新方法，形成新的类，复用父类的代码</strong>，这就是OOP中的继承性的作用。C++使用多继承，Java支持单继承（Single inheritance）。</p><p>实际证明，继承关系（class-based）确实会带来一些代码量的减少，但是带来了子父类的强耦合，所以更现代的流派更推荐使用组合关系（prototype-based），也就是像Java的接口一样，Go语言已经完全采用prototype-based关系。</p><h4 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3. 多态性"></a>3. 多态性</h4><p>Java中的多态是一个父类类型对不同子类对象同一方法的不同响应，代码解耦合，例如工厂模式，service接口等就是多态的运用。</p><p>实现多态，最基础依赖于继承或者实现（extends&#x2F;implement），当子类方法重写，这是动态多态的基础（运行时多态），后续可以进行向上转型或者向下转型，另外方法的重载也是一种多态，这是静态的多态（编译时多态）。<a href="https://blog.csdn.net/SEU_Calvin/article/details/52191321">多态原理</a></p><ul><li>向上转型（upcast）：父类引用指向子类对象。也可以解释成子类对象转化成了父类，也就是所谓的“向上”</li><li>向下转型（downcast）：父类引用重新强转回子类，当父类对象要调用子类的独有方法时需要向下转型，相当于我们多态父类引用转回原子类。向下转型比较少用，用也搭配<code>instanceof</code>，防止出现类型转化异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCasting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Upcasting</span><br><br>        <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) animal; <span class="hljs-comment">// Downcasting</span><br>            dog.bark(); <span class="hljs-comment">// Outputs: Dog barks</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Java所有类都继承自Object类，同时也会继承到Object类中的方法，如hashcode()、equals()、clone()、notify()、wait()、finalize()，除了equals()和finalize()，其他方法都是native方法（JNI调用），此处重点摘记一下浅拷贝和深拷贝。</p><p>实现浅拷贝：<strong>需要拷贝的类必须implements Cloneable接口，重写clone()方法</strong>，然后对象调用clone()实现浅拷贝，浅拷贝只会复制基本数据类型，复制的属性是引用型数据时，例如类和数组，只会复制内存地址，而不会完全复制一份对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 浅拷贝重写clone()方法</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>而深拷贝就是所有属性都会完全复制一份，自己去实现对象复制，任何可以达到的方式都可以，比较常用的是<strong>使用对象序列化和反序列化实现深拷贝</strong>，整体使用简单，用流先写入到字节内存，然后再读取，特别是属性较多时，不需要一个个赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 将对象写入字节流</span><br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>    oos.writeObject(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// 从字节流中读取对象</span><br>    <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>    <span class="hljs-keyword">return</span> ois.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些方式实现深拷贝，就是clone()方法先拷贝基本数据类型，再逐步实现引用型数据的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>  <span class="hljs-type">int</span> number;<br>  String name;<br>  <span class="hljs-type">int</span>[] arr;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepCopy</span><span class="hljs-params">(<span class="hljs-type">int</span> number, String name)</span> &#123;<br>      <span class="hljs-built_in">this</span>.number = number;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>      <span class="hljs-type">DeepCopy</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> (DeepCopy) <span class="hljs-built_in">super</span>.clone();<br>      copy.arr = arr.clone(); <span class="hljs-comment">// Deep copy of the array</span><br>      <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="int和String的转化"><a href="#int和String的转化" class="headerlink" title="int和String的转化"></a>int和String的转化</h4><p>这几个方法整体性能差不多的：</p><ul><li>**Integer.toString(int a)和Integer.parseInt(String str)**；原型方法</li><li>String.valueOf(int a)和Integer.valueOf(String str)； 对上面2个方法的封装，部分情况下使用更方便，比如是String.valueOf()重载了多种基本数据类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2023/03/07/Java/%E6%96%B0blog/2.Java%E9%9B%86%E5%90%88/"/>
    <url>/2023/03/07/Java/%E6%96%B0blog/2.Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>Java有三种类型的集合，插入有序且元素可重复的List、插入无序且元素不可重复的Set、键值对形式的Map。其中List和Set都继承自Collection，他们公共的且最常用的方法都来自于Collection接口，例如add、remove、isEmpty、contains。</p><p>关于集合插入null值：大部分集合类都允许元素为null，List支持插入多个null值、HashSet、HashMap支持一个null值，TreeSet、TreeMap等要排序的集合不支持插入null值</p><h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>集合是Java提供的一组泛型类，所以讲集合之前，我们先讲一下什么是泛型。</p><p>泛型在集合源码中非常常见，假设我们设计集合不用泛型，要让一个集合类能够兼容所有数据类型，那集合元素就必须设计成是Object类型，通过“向上转型”来接收所有类型数据，但每一次获取数据，需要向下转型，需要强转；要么就为每一种数据类型写一个集合类，就增加了类的编写数量。<br>所以集合引用了泛型，让集合类一种<strong>模板代码</strong>，来适应任意的数据类型，<strong>让我们在实例化的时候才决定了参数的数据类型</strong>，不需要为每一种数据类型都写一个集合类。</p><p>Java的泛型是“擦拭法”实现的，无论实例化成什么类，编译后泛型类中的数据通过Object对象保存，所以泛型类型不能为<code>int</code>等基础数据类型，要使用他们的包装器对象例如<code>Integer</code>；用反射或者Class，<code>List&lt;number&gt;</code>和<code>List&lt;Integer&gt;</code>是同一个Class，他们不存在子父类关系。</p><h4 id="代码引入泛型类型的几种方式"><a href="#代码引入泛型类型的几种方式" class="headerlink" title="代码引入泛型类型的几种方式"></a>代码引入泛型类型的几种方式</h4><ol><li>泛型类：比如ArrayList类，在类的签名中引入泛型<code>&lt;E&gt;</code>，泛型类<strong>在创建对象时指定泛型类型</strong>，不指定泛型类型就默认为Object类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>泛型接口：比如Comparable接口，和泛型类一样，在接口签名中引入泛型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;<br></code></pre></td></tr></table></figure><blockquote><p> 当类继承泛型类或实现泛型接口时，有两种指定泛型类型的时机，第一种是<strong>在类的声明处指定泛型接口的类型</strong>，例如类实现Comparable接口的用法；另一种形式，类变成泛型类，后期实例化再决定数据类型，取决于具体的设计来选择。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;  <span class="hljs-comment">//类实现泛型接口需要指定数据类型</span><br></code></pre></td></tr></table></figure><ol start="3"><li>泛型方法：<strong>在方法签名的返回值前用<code>&lt;T&gt;</code>单独声明泛型类型</strong>，不依赖于类或者接口带来的泛型类型。泛型方法被调用时，可以显示声明泛型方法的类型，如 <code>demo.&lt;String&gt;run(str1,str2)</code> ，也可以不声明参数类型，编译器会根据你传入的参数类型自行推断<br>静态方法不能通过泛型类和泛型接口引入来的泛型类型，编译会报错，必须使用泛型方法才能引入泛型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> <br></code></pre></td></tr></table></figure><h4 id="类型参数边界（type-parameter-bound）"><a href="#类型参数边界（type-parameter-bound）" class="headerlink" title="类型参数边界（type parameter bound）"></a>类型参数边界（type parameter bound）</h4><p>当我们的设计的API，让泛型类&#x2F;泛型接口引用作为方法的参数，通常来说我们要指定泛型引用具体的类型，例如<code>List&lt;Number&gt;</code>，但我们很多时候设计API，想让API中传入泛型类型<strong>适用于某一个基类及其派生类或者他的超类</strong>。由于泛型类型不存在子父类关系，例如虽然Integer是Number的子类，但<code>List&lt;Number&gt;</code>和<code>List&lt;Integer&gt;</code>这两种泛型类型并不存在父子类关系，所以我们不能够通过向上转型，让<code>List&lt;Number&gt;</code>接收<code>List&lt;Integer&gt;</code>，我们想要API的编写支持这样的形式，需要使用<strong>通配符”?“，搭配extends关键字或者super确认泛型的上下界</strong>，例如<code>List&lt; ? extends Numbers&gt;</code>就可以达到我们接受子类的要求。</p><p><strong>泛型的上下界</strong>，参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265105920586976">廖雪峰的泛型上下界</a></p><ul><li>上界：<code>? extends Number</code>，传入的泛型数据类型必须为Number类或他的下级类。<strong>extends上界在方法内允许泛型类的读取方法，但不允许调用泛型类的写入类方法（除非写入null）</strong>，否则编译无法通过。<br>因为Number可以安全的接收传入的任意下界类数据，但是写入，就算方法内写入的是比较小的Integer类型数据，但是传入的泛型类型，可能是和Integer平级的Double，甚至是更下级的数据类型，Integer无法安全的写入到泛型类型数据中。</li><li>下界：<code>? super Integer</code>，传入的泛型数据类型必须为Integer类或他的上级类。<strong>super下界允许在方法内调用泛型类的写入方法，但不允许泛型类读取类方法（除非使用Object类接受）</strong>，否则编译无法通过。<br>不能被读取的原因是，Integer类来接受，但是我们泛型类的读取方法，返回的类型会是任意上界类数据，Integer无法接收比他上级的类的；可以写入，因为泛型类的写入方法可以接受Integer类型。<br>总结就是，上界（extends）用于读取，下界用于写入（super），其实核心原因是因为Java向上转型安全，向下转型不安全的。通过上下界，可以更加精巧的设计API，让编译器来保证数据不被进行写入或读取等我们不想要的操作，Collections类中关于List复制的Copy方法就是源码中最好的一个实现，我们当然可以不用super或extends，但是会让你的API更加高级，健壮度更高。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>              <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i); <span class="hljs-comment">// src是producer</span><br>              dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="List类集合"><a href="#List类集合" class="headerlink" title="List类集合"></a>List类集合</h2><p>List类集合是用的最多的集合，相当于可变长的数组，元素有序可重复，当list里的元素是对象，如果要确保集合contains()方法的有效性，要重写对象equals()方法。</p><h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h4><p>ArrayList底层采用数组，从JDK 8开始，默认数组长度从10变到了0，由于底层是数组，所以ArrayList读取快，但在开头或者中间位置插入或删除数据，后面元素位置都要移动，所以相比于LinkedList，ArrayList整体进行增删的效率低一些，但是通常对集合开始和中间段的修改比较少，进行最多就是add和遍历，所以ArrayList仍然是使用最频繁的List。</p><p>ArrayList的线程是不安全的，容易出现两种情况：</p><ul><li>致元素覆盖和有元素为null值。add()方法中的<code>elmentData[size++] = e</code>导致</li><li>数据越界异常。add()方法中同时判断数组长度无需拓容</li></ul><h4 id="2-LinkedList（双向链表实现）："><a href="#2-LinkedList（双向链表实现）：" class="headerlink" title="2. LinkedList（双向链表实现）："></a>2. LinkedList（双向链表实现）：</h4><p>LinkedList底层采用双向链表，实现了Deque接口（双向队列），所以也就<strong>实现了队列</strong>（FIFO，先进先出线性表）<strong>和栈</strong>（LIFO，后进先出线性表）两种数据结构。插入和删除操作快，但读取遍历慢</p><p>LinkedList当成普通List来使用时，推荐使用add()&#x2F;remove()等方法；LinkedList当成stack栈使用时，push()栈顶压栈，pop()栈顶出栈；当成queue队列使用时，offer()队尾入队，poll()队头出队，peek()取列表头部元素；当成双向队列Deque使用时，可以操作两头，offerLast()&#x2F;offerFirst()，pollFirst()&#x2F;pollLast()。</p><h4 id="3-其他List接口实现类"><a href="#3-其他List接口实现类" class="headerlink" title="3. 其他List接口实现类"></a>3. 其他List接口实现类</h4><p>Vector类：相当于方法<strong>同步版的ArrayList</strong>，所以也是一种数组型的集合</p><p>Stack类：基于Vector类动态数组实现的Java栈类，有锁的开销，用Deque的实现类代替Stack类实现更高效率的栈</p><p>Deque接口，是Queue接口的子接口，的实现类有两个常用的，基于循环数组实现的<strong>ArrayDeque</strong>，和基于双向链表实现的<strong>LinkedList</strong></p><h2 id="Set类集合"><a href="#Set类集合" class="headerlink" title="Set类集合"></a>Set类集合</h2><p>当我们存储数据时，如果要求数据不能重复，或者需要存储大量数据，再或者需要进行很多的排序，这个时候用Set集合</p><h4 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h4><p>HashSet底层基于HashMap，也就是HashMap-Key的存储形式，可以当成没有value的HashMap。集合元素为自定义对象时，需要重写元素类的hashCode()和equals()方法，HashSet重写频率会比HashMap高，因为HashMap的key一般是String不需要重写，而HashSet有更大概率存储自定义实体类。</p><ul><li>重写hashcode()方法：可以取成员属性的值作为hashcode，如<code>this.name.hashcode()</code>。String的hashcode是通过String每一个字符✖️31计算。</li><li>重写equals()方法：参考String的写法，先判断内存地址，在instance of判断属于的类，再比较每个属性的值，如<code>this.name.equals(obj.name)&amp;&amp;this.no==obj.no</code></li></ul><p>HashSet add元素，首先根据hashCode值和数组的长度进行计算出存储的下标；如果下标的位置无元素，那么直接存储；如果有元素，那么使用要存入的元素和该元素进行equals方法，如果结果为真，哈希表对应位置上的Set元素被替换了（不管相不相等）；如果不相等，以链表形式新加节点存储。</p><h4 id="2-TreeSet"><a href="#2-TreeSet" class="headerlink" title="2. TreeSet"></a>2. TreeSet</h4><p>TreeSet基于TreeMap，存储形式为二叉树，适合大量数据的存储。</p><p>Tree类型的Set或者Map，都需要强制排序，意味着使用TreeSet存储类型为对象时，要么这个<strong>类继承Comparable接口，重写compareTo()方法</strong>；要么在<strong>实例化集合的过程中</strong>，构造方法传入一个的<strong>Comparator比较器对象</strong>。默认<code>o1-o2</code>这种形式呢，就是升序排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化Tree型集合，元素需要强制排序，使用Lambda表达式推断匿名内部类，然后实例化了一个Comparator对象 </span><br>TreeSet&lt;Student&gt; studentSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((o1, o2) -&gt; o1.getAge()- o2.getAge());<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_25827845/article/details/53870329">Java 8 String的compareTo()</a>：返回从左到右第一个不同的字符的ASCII码差，长字符和短字符相同，返回两个字符的length差。</p><h2 id="Map类集合"><a href="#Map类集合" class="headerlink" title="Map类集合"></a>Map类集合</h2><h4 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h4><p>HashMap是一个<strong>储存Entry对象的数组</strong>，在数组的基础上是链表+红黑树的组合（Java 8后）。HashMap插入hashcode相等并且equlas放回返回true的key值时，此时新<strong>Entry会替换</strong>老Entry元素，在HashMap体现为value值被替换，HashSet中元素被替换。而LinkedHashMap相比HashMap，底层用链表代替数组，按顺序存储，迭代顺序与存储顺序一致，而HashMap随机存储，也导致LinkedHashMap读写性能差一点。</p><p>HashMap底层是哈希表，值的位置是算出来的，数组桶的数量有限的，所以经过了扰动函数让哈希值尽可能的均匀，也会冲突，哈希表解决冲突有三种，再哈希法、开放寻址法和<strong>分离链表法</strong>，HashMap采用最后一种。</p><p>同ArrayList一样，在 Java 8后，只有当HashMap调用put()方法时，才将HashMap数组长度初始化为16；当链表长度大于等于8时，当前桶的链表将转成红黑树，红黑树元素小于等于6时，转化成链表，除此之外链表转红黑树实际还有一个隐性条件，就是Node数组长度要大于等于64，在64之前，会有限哈希表数组拓容</p><p>调用put()方法的源码过程：首先会调用扰动函数，右移使将高位值参与计算，让哈希值分布更均匀：<code>（h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>作为最后的哈希值，然后根据常规的哈希规则去插入，插入桶的位置通过按位与运算（取余运算）获取，即<code>index = hash&amp;(length-1)</code>，使得高位参与运算，等同于十进制取余hash%length。length-1&#x3D;2^n-1，二进制是n个1，这样取余，结果取决于hashcode，而不是链表，高位hashcode取余完全等于hashcode最后几位。</p><blockquote><p>[!question] 二进制运算复盘：右移和左移、按位运算、逻辑运算、异或运算的学习</p></blockquote><p>插入后，进行判断，当<code>++size &gt; thresholds</code>时（threshold等于capacity✖️loadfactory），执行resize()方法拓容，拓容2倍，反正数组的长度会是2的幂。拓容后调用transfer方法，将元素rehash到新数组中。<br>关于size++和++size的区别：++size会返回size+1后的值，而size++的返回值是size，虽然两者都实现了size加1，再执行判断或者返回的时候，请使用++size。</p><h4 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2. TreeMap"></a>2. TreeMap</h4><p>TreeMap就是一个树结构，每一个树节点都是Entry对象，Entry类型成员变量除了本身的key和value以外，还包括左节点、右节点和父节点三个同为Entry类型的成员变量，这样从根节点Entry对象开始，逐步递归存储，这种存储形式可以叫做“<strong>自引用</strong>”，自树和链表的数据结构中，经常使用。</p><p>TreeMap底层是红黑树（二叉查找树），自定义对象作为key时，需要重写compareTo()方法或者给TreeMap集合传递一个Comparator对象。需要排序时，用TreeMap结构，迭代器输出默认就是自然排序。在这里引申了解几个树相关的概念，满二叉树：一共有2^K-1个节点。完全二叉树：满二叉树基础上，只有h-1可以度小于2，只有一个叶必须在最左边。红黑树的性质：和前两种树一样也是一种二叉树，根和叶（NIL节点）是黑色节点，路径上两个红色节点点不能相连，<strong>根节点到所有NIL节点经过的黑色节点相同</strong>，这种规格使得树的高度维持，查询的最差时间复杂度控制在logn。</p><p>put()时源码解析：首先判断根是否为空，为空则将元素放到根节点，不是则元素从根节点开始compare()，如大于0，继续和根的右子树比较，直至取不到右子树了，就放到当前比较节点的右节点了，remove()整体流程也差不多，插入或者删除节点以后，会调用fixAfterInsertion()进行节点的变色、左旋和右旋完成红黑树调整。一般简单了解红黑树会进行变色、左旋（A左旋，相当于A变成右子节点的左节点，原右子节点的左节点变为A的右节点）、右旋是怎么回事就行了，详细的红黑树调整规则，插入后的调整规则已经清楚了，删除一般会转化成叶子节点，然后再用规则进行删除，如果想要详细了解调整规则，参考<a href="https://zhuanlan.zhihu.com/p/166319823">插入和删除后红黑树的修复</a>。</p><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><h4 id="并发Map"><a href="#并发Map" class="headerlink" title="并发Map"></a>并发Map</h4><p>高并发下的HashMap线程并不安全，高并发下，很多场景都会有线程安全问题，例如一个线程还未插入完成，另一个线程刚好resize到新的数组，元素可能就会覆盖；再比如rehash阶段两个线程并发可能会形成<strong>链表环</strong>，此时get()某元素到环状链表所在的桶，但并不存在equals相等的元素时，会出现死循环，会一直遍历链表去查找。</p><p>给每个Segment上锁，size()方法，所有segment的元素加起来，所有segment的修改次数加起来，Java 8已经不用segment了。</p><p><a href="https://zhuanlan.zhihu.com/p/31614308">ConcurrentHashMap</a>是高并发的，就使用HashTable（同步版HashMap，性能低较少使用）</p><p>ConcrrentHashMap用了Segment，将HashMap分块，降低了锁的粒度。</p><h4 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h4><p>不存储元素，只用于判断元素是否存在过。加入元素时，多个哈希函数计算后映射到位数组上的位置，值设置为“1”，判断元素是否存在过时，必须满足三个哈希值在位数组上的映射都为1。网络爬虫是一个最常见的场景，因为网页中有很多重复URL，需要判断是否已经爬取过。谷歌的Guava BloomFilter是一个常见的实现。</p><h4 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h4><p>创建集合是一个泛型类的实例化，<strong>在JDK 1.7以后，泛型类实例化，右边的构造方法不再需要指定泛型的类型</strong>，编译器会根据上下文推断类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>集合通过增强for和迭代器遍历集合。List和Set集合都继承自Collection接口，他们的实现类重写了Collection借口中的iterator()方法，所以他们都可以通过iterator()方法获取自身的迭代器；而Map的遍历，无法直接使用增强for或者iterator迭代器，需要现将map转化成**entrySet()、keySet()或values()**，然后再使用迭代器&#x2F;增强for，实现Map的循环</p><p>在增强for循环体中，不允许add或者remove元素，如果我们要在遍历过程中增删元素，需要使用迭代器提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>  System.out.println(iterator.next(););<br>  it.remove();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h4><p>List和Set集合需要排序，如果存储的元素本身就是支持排序的基础数据类型，直接调用Collections.sort()方法，就能对list&#x2F;set&#x2F;map集合实现排序；如果集合元素是对象，如果需要实现排序，就有两种方式</p><ol><li>使用两个参数的Collections.sort()重载方法，第二个参数中<strong>传入一个Comparator比较器，充血比较器的compare()方法</strong>，通常来说，会写成匿名内部类的实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>            &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>另一种方法是是<strong>对象类实现Comparable接口，重写compareTo()方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Student类中实现Comparable接口，重写compareTo方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age-o.age;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 使用排序</span><br>  List&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">3</span>));<br>  students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jackson&quot;</span>,<span class="hljs-number">5</span>));<br>  students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jessi&quot;</span>,<span class="hljs-number">1</span>));<br>  <span class="hljs-comment">// students集合将会被排序</span><br>  Collections.sort(students);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁和事务</title>
    <link href="/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/2.%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/2.%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>事务是一组原子性的SQL语句，MySQL中只有Innodb引擎才支持事务，锁是针对事务来说的，比如，在执行当前事务时，拿到了锁，才能进行update，事务提交。就释放了记录的锁。</p><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><p>InnoDB基本不使用表级锁，除了在Alter table时，会自动加上表锁，我们在SQL层面操作主要还是下面<strong>两种行锁</strong>，要注意的是，select默认情况下不加锁，update和delete默认加X排他锁。数据库锁以事务为单位，同一个事务下锁可重入，也就是说数据锁是可重入锁，主要有两种显示的悲观锁。</p><ol><li><strong>排他锁</strong>（X锁，Exclusive Lock）：for update。</li><li><strong>共享锁</strong>（S锁，Shared Lock）：lock in share mode</li></ol><p>除了常规行锁，还有两种隐藏的锁，一种是<strong>GAP间隙锁</strong>，例如对一个索引字段使用范围查询（如BETWEEN、&lt;、&gt;等），如SELECT … WHERE … FOR UPDATE ，会在索引区间上加上GAP间隙锁，不允许其他事务新插入或删除索引区间内的数据。</p><p>另一种是RR级别下独有的Next-Key锁，在以索引字段为条件，进行当前读&#x2F;update&#x2F;delete时，当前记录加入行锁，两边区间加入GAP间隙锁，统一形成叫Next-Key锁。你可以理解为在RR中，用索引进行update&#x2F;delete，会比RC级别形成更多GAP锁，RC级别只在用索引进行范围操作时产生GAP锁。</p><p>GAP间隙锁和Next-Key锁，都能降低当前事务出现“<strong>幻读</strong>”的几率，幻读是值指同一个事务内多次查询返回的结果集不一样，比如事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录。</p><p>对于数据库悲观锁，基于数据库版本号的乐观锁其实就是CAS乐观锁</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>由于MySQL事务是默认自动提交的，注意使用<code>SET AUTOCOMMIT=0</code>关闭MySQL事务自动提交。</p><p>另外MySQL DML可以像Oracle数据库一样隐式开启事务，但是更推荐使用BEGIN或者START TRANSCATION显式开启事务，保持更好的可读性，并使用COMMIT提交事务。</p><p>不同隔离级别下的加锁方式是不同的。<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">mysql事务下的锁机制(美团)</a></p><p>数据库事务遵循ACID的设计原则，即原子性（要么都执行，失败回滚）、隔离性（并发事务隔离）、一致性（一个状态转化另一个状态，但数据完整性一致）、持久性（事务完整，数据库改动是永久的）。</p><p>MySQL存在4中事务隔离级别，可以说是4种类型的事务等级，其中<strong>Innodb默认事务隔离级别是可重复度</strong>，实际上，数据库并发的优化，或者说这些隔离级别之间的差异，就是针对“读”。</p><ol><li><p>READ-UNCOMMITTED（未提交读）：任何情况都不加锁，也就意味着，事务没有提交，新值就可以被其他事务所读取，这就叫出现“<strong>脏读</strong>”。</p></li><li><p>READ-COMMITTED（提交读）：读不加锁，增删改加排他锁；不会再出现脏读，其他事务如果提交，当前事务就可能够读取最新的版本，这就是所谓的RC会出现“<strong>不可重复读</strong>”，也就是指“在一个事务内，多次读取同一数据可能会结果”。因为RC的MVCC（多版本并发控制），在每次<strong>快照读</strong>，都会生成一个基于当前已提交的生成新一致性视图，可能其他人进行了update或delete并提交了，造成两次读取不一致。</p></li><li><p>REPEATABLE-READ（可重复读）：<strong>读不加锁，增删改加排他锁</strong>；RC的MVCC在快照读在第一次读，就生成了一个全局的一致性视图，这就不会再出现“不可重复读”。</p></li><li><p>SERIALIZABLE（串行化）：完全使用悲观锁，读用读锁，写用写锁。解决了幻读的问题</p></li></ol><p>为了防止数据库死锁有几种措施，比如事务之间保持数据更新的顺序；业务允许的情况下，尽量降低事务的粒度，或者降低事务级别到RC级别，防止gap锁造成死锁；添加合理的索引，不走索引会全表加GAP锁，更容易死锁。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几种常见查找日志命令的比较</title>
    <link href="/2023/02/23/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/7.%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/"/>
    <url>/2023/02/23/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/7.%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>推荐使用：</p><ol><li><p><code>tail -f -n 20 file</code>，-f实时查看，-n 20是查看末尾20行，不加-n默认是只看10行</p></li><li><p><code>less -N file</code>，分页打开文件，-N表示显示行号，然后使用<code>/keyword</code>匹配关键字。less也支持像tail命令一样实时查看日志<code>less +F file</code></p><ul><li>匹配关键字后，n查找下一个匹配，N查找上一个匹配。</li><li>分页操作：space下翻一页、b上翻一页、上翻一行(↑) 下翻一行（↓）、跳转末尾G、跳转开头g</li></ul></li><li><p><code>grep -C 10 &quot;keyword&quot; file</code>，大日志查看时，效率最高的，而且支持递归查找文件，如果要打印行号，可以加-n参数，注意tail和grep是-n，less是-N</p></li></ol><p>低频率使用:</p><ol><li><code>cat file ｜ grep &quot;keyword&quot;</code>，打印文件在控制台。只适合直观查看小文件，用管道搭配grep效率低，且无法利用grep的多个参数精确查找，直接用grep就可以。</li><li>vi&#x2F;vim打开日志文件，然后使用<code>/keyword</code>匹配关键字，匹配后n查找下一个匹配的关键字，N查找上一个匹配，使用与less类似，但要加载整个文件，less翻页更方便。</li><li>head file 头10行，more和less类似，但不支持往前看，也基本不用于查找日志</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/12/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/4.%E4%B8%AA%E4%BA%BA%E7%90%86%E8%B4%A2/"/>
    <url>/2022/12/12/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/4.%E4%B8%AA%E4%BA%BA%E7%90%86%E8%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ol><li>理财不是针对人某一生命阶段，而是整个生命周期。</li><li>理财监管机构：一委一行两会（银保监会、证监会）一局</li><li>第三方理财机构大多数没有自己的理财产品</li><li>理财业务– &gt;财富管理业务–&gt;私人银行业务（600万金融净资产–房子车子不算）。客户等级和服务种类提升。</li><li>利息收入：核心业务（存贷款）和投资业务。非利息收入（支付结算、托管、理财、银行卡各种）</li><li>萌芽：80-90年代（外汇），形成时期：至05年。</li><li><strong>净值型理财产品</strong>称为理财市场的主流。</li><li>个人理财建立在委托代理上。受托、顾问性质</li><li>职业资格（4E。教育、考试、工作经验和职业道德）</li></ol><h4 id="两种理财服务"><a href="#两种理财服务" class="headerlink" title="两种理财服务"></a>两种理财服务</h4><ol><li><p>综合理财服务：由客户承担或者按约定分类</p></li><li><p>理财顾问服务：财务<strong>分析</strong>和规划、投资建议和个人投资产品推介</p><p>区别于一般性业务咨询人员（不是理财专业人员或者理财师）：产品介绍、宣传和推介</p></li></ol><h2 id="法规"><a href="#法规" class="headerlink" title="法规"></a>法规</h2><h4 id="民法补充"><a href="#民法补充" class="headerlink" title="民法补充"></a>民法补充</h4><ol><li><p>法律主体是金融机构和客户。自然人、法人（盈利法人–最常见的是公司法人、非盈利法人和特别法人）和非法人组织。</p></li><li><p>限制民事行为能力人的一般民事法律行为需要法定代理人追认，但可以独立实施纯获利的民事法律行为（比如继承、保险受益人）。</p></li><li><p>民法遵循4原则：自愿、平等（公平）、<strong>诚信原则</strong>、不得违背公序良俗。</p></li><li><p>代理人未经被代理人同意或者追认，责任由代理人承担。合同</p></li><li><p>代理人和相对人承担连带责任（伙同卖出） </p></li><li><p>代理人和被代理人承担连带责任（替考、催收）</p></li><li><p>格式条款，首先按通常理解解释；两种以上解释的，按照不利于提供格式条款的一方解释；格式条款与非格式条款不一致的，采用非格式条款。</p></li><li><p>同时履行抗辩权、先履行抗辩权、不安抗辩权</p></li><li><p>违约责任承担方式：<strong>继续履约</strong>、支付违约金、赔偿损失、遵守定金法则和采取补救措施</p></li><li><p>反担保。海域使用权可以抵押、正在建造的东西可以抵押。</p></li><li><p>债权人为抵押权人&#x2F;质权人；债务人为抵押人&#x2F;出质人（财产权利、知识产权中的财产权、应收账款）</p></li><li><p>财产约定需要采用书面形式</p></li><li><p>个人独资企业承担无限责任。自行清算和法院指定清算人清算</p><p>15日内书面通知债权人（或公告），债权人30日内（公告60日内）申报债权，破产清算后，需要继续偿还，债权人需要在五年内提出偿债请求。</p><p>偿还顺序：工资和社保、税、其他债务。</p></li><li><p>普通合伙企业：</p><ul><li><p>有限合伙企业：普通合伙人承担无限连带责任，有限合伙人以出资额承担债务，至少一个有限合伙人，有限合伙人权限小。</p><p>有限合人伙可以直接出质，转让提前30日通知，同等情况其他合伙人有限购入。未成年人。</p></li><li><p>普通合伙企业：出质需要所有合伙人同意</p></li></ul></li></ol><h4 id="理财产品法规"><a href="#理财产品法规" class="headerlink" title="理财产品法规"></a>理财产品法规</h4><p>资管新规、理财新规、理财子公司。</p><ol><li>公募按照证券法发行，私募向合格投资者发行（2年以上，净资产不低于300万，家庭净资产不低于500万，年均收入不低于40万，满足其一即可）</li><li>投资性质分类：固定收益类（存款、债券比例不低于80%）、权益类理财产品（股票等不低于80%）、商品及金融衍生品理财、混合类（都没达到80%）</li><li>产品比例15个交易日内调会规定</li><li>运作方式分类：封闭式、开放式</li><li>非金融机构和个人不得代理销售资产管理产品</li><li>不得宣传预期收益率</li><li>产品分级1-5，客户分级1-5</li><li>穿透原则：需要识别最终投资者，来识别风险</li><li>公募理财产品：1万、私募固收30万、私募混合40万、私募权益和金融衍生100万。</li><li>代销商业银行理财产品的机构：能够<strong>吸收公众存款的银行业金融机构</strong>可以代理销售银行理财</li><li>商业银行需要使用合作机构的宣传资料</li><li>商业不得非本行人员在营业网点从事产品宣传推介、销售。严禁代为操作（不能为老人操作）。录音录像合同解除6个月内</li><li>20-50万元：没有保送、刚性兑付、没提示风险、拒绝检查等等</li></ol><h4 id="代理基金"><a href="#代理基金" class="headerlink" title="代理基金"></a>代理基金</h4><ol><li>申请注册基金销售业务资格：基金从业人员不少于20人。<strong>最近3年没有行政处罚</strong>。</li><li>私募基金不能通过公开渠道宣传</li><li>投资利益有限和风险匹配。推进定投和养老，杜绝短期申赎、频繁申赎的行为。</li><li>不得对投资人适用不同的费用，增值服务可以向投资人收取服务费，不得对基金收入作为主要考核指标</li><li>分支机构销售活动不能委托给他人。身份资料在合同结束后保存20年，销售业务资料自业务发生日期至少保存20年</li><li>基金销售业务许可证有效期3年，不存在销售日均保有量5亿元、违规的，延期3年</li></ol><h4 id="代理保险"><a href="#代理保险" class="headerlink" title="代理保险"></a>代理保险</h4><ol><li><strong>2年内无违法记录</strong>，保险许可证不设置有效期，变更后（营业执照等）5日内向银保监报告。</li><li>签订代理保险合同，总行（法人）签订，分公司先要法人的书面授权，分公司才能委托签订</li><li>银行保险业务要独立核算，不得保费收入抵扣佣金，加强佣金集中管理。</li></ol><h4 id="外汇"><a href="#外汇" class="headerlink" title="外汇"></a>外汇</h4><ol><li>黄金期货：大于4人（交易2，风险2），业务隔离制度，自由黄金期货代理经济黄金</li><li>外汇经常账户（可兑换原则管理）、资本账户（可兑换进程管理），外汇保存5年</li><li>境外个人兑回水单，有效期24个月</li></ol><h2 id="投资市场（金融市场）"><a href="#投资市场（金融市场）" class="headerlink" title="投资市场（金融市场）"></a>投资市场（金融市场）</h2><p>头寸（金融上的款项）；多头头寸（买入合约后持有的头寸）</p><h4 id="金融市场的对象"><a href="#金融市场的对象" class="headerlink" title="金融市场的对象"></a>金融市场的对象</h4><p>金融市场主体：央行、政府、企业、个人</p><p>金融市场客体（被交易的金融产品）：同业拆借（头寸）、票据、债券、股票等</p><p>金融市场中介：交易中介（银行、证券交易所、证券结算公司等）、服务中介（会计事务所、律师事务所、评级机构）</p><p>金融市场上，<strong>居民个人是最大的资金供给者。</strong></p><h4 id="参与金融市场"><a href="#参与金融市场" class="headerlink" title="参与金融市场"></a>参与金融市场</h4><ol><li><p>个人投资者参与货币市场：交易所逆回购（国债回购市场）、货币市场基金、现金管理类理财产品</p></li><li><p>个人投资者参与债券市场：商业银行、交易所市场、通过基金银行等发行的金融产品间接参与（债券价格与预期收益率和市场利率成反比关系）</p></li><li><p>股票市场：</p><p>一版（涨跌幅10%）：主板市场（600上交所、000深交所，核准制）、中小板（002，中国纳斯达克，核准制。中小板已经和000合并）；</p><p>二板（涨跌幅20%）：创业板（300，成长期的企业，注册制）、科创板（个人投资要50万以上，注册制）。</p><p>三版四版是场外市场，三版非主要面向机构；四版面向私募</p><p>审批、核准（我国主流）、注册</p><p>新三板是核准制</p></li><li><p>债券是固定收益类（事先约定收益率，剩余资产优先受偿）、股票是权益类 。</p></li></ol><h4 id="金融衍生品市场"><a href="#金融衍生品市场" class="headerlink" title="金融衍生品市场"></a>金融衍生品市场</h4><ol><li>金融衍生品是保证金交易，可复制性和杠杆特性。交易方式划分衍生品工具：<strong>远期、期货、期权</strong>和互换。</li></ol><ul><li><p>远期市场（场外）：约定一个远期合约，有债券、股票、利率、汇率。没有保证金。</p></li><li><p>期货市场：期货和远期的区别是场内交易，标准化合约，履约通过对冲方式，不用通过全额，有交易所担保（保证金），限制最大和最小浮动。</p><p>主要制度：保证金交易、每日结算制度、持仓限额、大户报告、强行平仓</p></li><li><p>金融期权市场：期权相当于远期股票会员卡，投资期权最大的损失就是期权费。看涨期权和看跌期权、欧式期权和美式期权（1年内自由日期，有利买方）、现货期权和现货期权</p></li><li><p>金融互换：利率互换和货币互换（比如银行之间锁死汇率合约）。</p></li></ul><ol start="2"><li><p>外汇市场分为即期外汇市场（主要外汇形式）和远期外汇市场</p></li><li><p>黄金：9999，9995、999、995。供求关系、通胀（黄金保值）、利率（利率高，黄金贬值）、汇率（美元贬值，黄金上升）、股票市场和黄金市场不相关甚至负相关，可作为组合资产。</p></li><li><p>保险市场：保险人是保险公司，被保险人是孩子。指定受益人的时候需要被保险人同意，只有父母才可以给孩子买死亡条件的保险。被保险人和受益人同时死亡，推定受益人死亡在先，作为受益人遗产</p></li></ol><h2 id="理财产品（20）"><a href="#理财产品（20）" class="headerlink" title="理财产品（20）"></a>理财产品（20）</h2><h4 id="银行理财产品"><a href="#银行理财产品" class="headerlink" title="银行理财产品"></a>银行理财产品</h4><p>理财产品不保证本金支付。</p><p>按照风险承受能力把投资者分为5类：保守谨慎稳健积极激进（极低、低、中、较高、高）</p><ul><li><p>银行理财产品：现金管理型（货币收益类，活期替代）、固守、权益、商品衍生、混合、QDII（境内去投资境外资本市场）、另类银行理财产品（投机，提供给私人银行）、结构性存款（一般采用<strong>存款+期权衍生品</strong>，大部分保本，纳入存款管理）。占比超80%。理财子公司</p></li><li><p>银行代理理财产品（基金、保险、国债）：赚手续费和佣金等。</p></li><li><p>其他理财产品</p></li></ul><h4 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h4><p>投资的80%以上，股票基金、债券基金、混合基金（偏债偏股大于60%）、货币基金</p><ol><li><p>收益凭证即仅仅份额是否可以增加、赎回：</p><p>a. 封闭式基金：不能增加赎回。</p><p>​期限内需要通过交易所套现，现金分红，资产净值每周公告，在交易所交易</p><p>b. 开放式基金：能增加赎回。</p><p>​在基金公司交易，现金分红和红利再投资</p></li><li><p>按投资目标分类：成长型（长期成长，风险较大，年轻人）、收入型（稳定的、最大化单期收入、现金持有大，投资倾向分散风险，老年人）、平衡性</p></li><li><p>按投资理念分类：主动性基金和被动性基金（指数基金）</p></li><li><p>法律地位分类：公司型（买了就是股东，基金就是法人资格的公司，可以向银行借款）和契约型（我们国家都是）</p></li><li><p>特殊类型基金：摊余成本法债券基金（与市值法基金相比，受市场利率影响小，净值波动小，收益高于同样摊余成本法的货币基金）</p><p>FOF（基金中的基金，Fund Of Fund）</p><p>ETF（交易型开放式指数基金–场内+场外，结合封闭式和开放式的优点，申购赎回基金份额必须用一揽子股票）</p><p>LOF（上市开放式基金，申购赎回是基金份额和现金的交易，中国特色ETF）</p><p>QDII</p><p>理财专户：200人以下、100万以上、每季度开放、最多开放5天</p></li></ol><h4 id="保险"><a href="#保险" class="headerlink" title="保险"></a>保险</h4><ol><li>人身险：</li></ol><p>分红险（利率的波动和预定死亡率、预定投资回报率和预定营运管理费用。现金红利和增额红利），</p><p>万能险（交费灵活，有保单账号和投资账户，保单账户价值提供<strong>最低收益保证，</strong>，随时取，流动性高）</p><p>投连险（弱化保险，多个投资账户，<strong>投资风险完全由投保人承担</strong>）</p><ol start="2"><li>财产险</li></ol><p>家庭财产险</p><p>企业财产险</p><p>房贷险：银行是保单的第一受益人（人和房子没了，贷款保险公司还，不长于抵押贷款期限和余额）</p><p>银行卖的保险有长期性，中途退保损失大</p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220711231957140.png" alt="image-20220711231957140" style="zoom:33%;" /><h4 id="国债"><a href="#国债" class="headerlink" title="国债"></a>国债</h4><p>国债是无风险收益率。</p><ol><li><p>凭证式国债。面向个人和机构，一次性，不可流通但可提前兑取（定期存单）</p></li><li><p>电子储蓄国债。只面向个人（境内），每年计息，不可流通但可提前兑取（银行卡）</p></li><li><p>记账式国际。面向个人和机构，<strong>交易所交易</strong>可流通，证券无纸化（股票）</p></li><li><p>银行代理国债6风险。违约风险、通膨风险、赎回风险、提前偿付风险、价格风险（利率上涨，债券价格降低，短期好）、再投资风险（利率下降，再投资，没有高收益，长期好）</p></li></ol><h4 id="信托"><a href="#信托" class="headerlink" title="信托"></a>信托</h4><ol><li>代理信托计划资金收付（信托的钱放银行）、代为推介信托计划（代卖）</li><li>信托关系的建立（和受益人关系）：任意信托和法定信托。委托人性质：法人信托和个人信托。信托财产分：资金信托、动产信托、不动产信托和其他财产信托</li><li>信托公司承担有限责任。加大标准化</li></ol><h4 id="贵金属"><a href="#贵金属" class="headerlink" title="贵金属"></a>贵金属</h4><p>黄金T+D业务，黄金准期货</p><h4 id="其他理财"><a href="#其他理财" class="headerlink" title="其他理财"></a>其他理财</h4><p>基金子公司产品：组合投资业务（FOF、MOM）、资产证券化业务、资本市场业务、债券类投资产品</p><p>期货资产管理产品：挂钩。。。。</p><p>合伙制私募基金（2-50人）：普通合伙人（私募基金管理人，无限责任，GP）和有限合伙人（相当于投资者，出资额为限，LP），税收少，交个税。</p><p>智能投顾：</p><p>公司制私募基金</p><p>私募：2-200人。自然人投资不低于100万。非公开宣传、不得承诺保底收益或最低收益（不然构成非法集资）</p><h2 id="客户分类和需求（10）"><a href="#客户分类和需求（10）" class="headerlink" title="客户分类和需求（10）"></a>客户分类和需求（10）</h2><p>理财师从以产品为中心到以客户为中心。</p><p>客户信息：基本信息、<strong>财务信息</strong>（收支和资产负债）–定量信息、个人兴趣和人生规划–定性信息</p><p>客户分类：风险态度分类（厌恶、中立、偏好）、客户资产分类（AUM 50万以下，数量80%以上，贡献度低于20%；AUM 50至600万，重点挖掘；600万以上，私人银行）</p><p>家庭生命周期：<strong>形成期</strong>（结婚，追求高风险和高流动性资产）、<strong>成长期</strong>（孩子上学了，保持流动性和增加固收）、<strong>成熟期</strong>（孩子经济独立，养老金筹措，进一步增加固定收益）、<strong>衰老期</strong>（退休了，80%以上投资固收）</p><h2 id="理财计算（20）"><a href="#理财计算（20）" class="headerlink" title="理财计算（20）"></a>理财计算（20）</h2><h4 id="货币时间价值的计算-复利"><a href="#货币时间价值的计算-复利" class="headerlink" title="货币时间价值的计算(复利)"></a>货币时间价值的计算(复利)</h4><p>现值PV ：Present Value、终值FV：Future Value、时间：time、利率：rate</p><ol><li>终值计算：**复利终值—- $FV&#x3D;PV(1+r)^t$**、单利终值—-$FV&#x3D;PV(1+rt)$；,</li><li>现值计算：除法：$PV&#x3D;FV&#x2F;(1+r)^t$</li><li>72法则：迅速计算翻倍所需要的利率，如12年翻倍， 利率就需要72&#x2F;12&#x3D;6，大概年化6%的利率</li><li>有效利率的计算：复利是年复利，还是按季复利，还是按月计算。$EAR &#x3D; (1+r&#x2F;m)^m-1$</li><li>连续复利：$FV&#x3D;PVe^re^t$</li></ol><h4 id="规则现金流计算-年金PMT—未来收入支出"><a href="#规则现金流计算-年金PMT—未来收入支出" class="headerlink" title="规则现金流计算(年金PMT—未来收入支出)"></a>规则现金流计算(年金PMT—未来收入支出)</h4><p>年金（PMT，公式用C）：不间断、金额相等和方向相同的现金流。如房贷、定投基金、房租、信托都是年金。</p><p>期初年金，期末年金（普通年金）。只需要知道年金、收益率和期限三个就可以知道年金初值和年金末值。</p><p>贷款100万，这100万就是年金现值</p><p><strong>期末年金终值：$PV&#x3D;C&#x2F;r[(1+r)^t-1]$</strong></p><p><strong>期末年金现值：$FV&#x3D;C&#x2F;r[1-1&#x2F;(1+r)^t]$</strong></p><p>期初年金与期末年金的关系：$期初年金终值&#x3D;期末年金终值*(1+r)$</p><p>永续年金：无限期没有终值，比如优先股，只有现值。$PV&#x3D;C&#x2F;r$，每年股利就是年金</p><p>增长型永续年金：g是增长率。现值:$PV&#x3D;C&#x2F;(r-g)$</p><h4 id="不规则现金流的计算"><a href="#不规则现金流的计算" class="headerlink" title="不规则现金流的计算"></a>不规则现金流的计算</h4><ol><li><strong>净现值NPV：</strong>大于0可以盈利，NPV小于0亏损。$加权C&#x2F;(1+r)^t$</li><li><strong>内部回报率IRR</strong>：IRR&gt;r，有利可图；IRR&lt;r，无利可图</li><li>复利终值系数表和复利现值系数表、年金现值系数表、年金终值系数表</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/12/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/2.%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/"/>
    <url>/2022/12/12/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/2.%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="存款业务"><a href="#存款业务" class="headerlink" title="存款业务"></a>存款业务</h2><ol><li>活期1元起存，角分不计息，<strong>只有个人活期存款计算复利</strong>，每个季度末月的20日为结息日，21日利息到账。活期银行使用<strong>积数计息法</strong>，定期银行使用<strong>逐笔计息法</strong> </li><li>定期存款中，<strong>整存整取</strong>最常见，起存50元，期限选择多，可以部分本金支取，同时这部分利息也按活期取出。整存零取（起存1000），零存整取（起存5）、存本取息（起存5000）— 一三五年的期限</li><li>教育储蓄存款：非义务教育阶段，四年级以上可以存，零存整取，一三六期，，50起存，最多2万，也需要全部支取本金。留学常用<strong>个人保证金存款</strong></li><li>单位活期存款：基本户、一般户（不能办理现金支取，可以结算）、专户、临时户（有效期不超过2年）</li><li>单位定期存款、单位通知存款（1天通知和7天通知存款）、单位协定存款（超过基本存款额度采用上浮利率）、<strong>单位保证金存款</strong>（承兑汇票、信用证、黄金、远期结售汇四种保证金）</li><li>银行间存款：同业存放（负债业务）、存放同业（资产业务） </li><li>现汇是汇票支票等外币票据</li><li>账户性质外汇账户分类：<strong>外汇储蓄账户</strong>（一般不得转账）、<strong>外汇结算账户（经常项目账户）</strong>、<strong>资本项目账户（贷款股票等）</strong>。  个人外汇账户主体划分：境内个人外汇账户和境外个人外汇账户。</li><li>单位外汇存款账户：单位经常项目外汇账户、单位资本项目账户（全是专户，两贷两股）</li><li>个人结构性存款主要是小额外汇结构性存款，特点是<strong>本金无风险</strong>。</li><li>商业银行债券（商业银行发行的债券种类）：普通、次级、混合、可转债</li><li>再贴现+再贷款是商业银行</li></ol><h2 id="贷款业务："><a href="#贷款业务：" class="headerlink" title="贷款业务："></a>贷款业务：</h2><h4 id="个人贷款"><a href="#个人贷款" class="headerlink" title="个人贷款"></a>个人贷款</h4><ol><li>4大个人贷款：<strong>个人消费贷款</strong>（车贷、<strong>装修</strong>、消费额度贷款、助学贷）、个人住房贷款、个人经营贷款（需要经营实体）、个人信用卡透支</li><li>个人汽车贷款最高贷款比例：自用新能源85，商用新能源75，自用传统能源80，商用传统能源70。二手车最多70，年限不超5年，二手不超3年，经销商不能超过1年</li><li>消费额度贷款：通过质押、抵押和第三方保证和信用的方式获取额度，质押额度不超过票面价值的90%，抵押额度不超过评估物的70%</li></ol><h4 id="公司贷款"><a href="#公司贷款" class="headerlink" title="公司贷款"></a>公司贷款</h4><ol><li><p>公司贷款种类：流动资金贷款（不能用于固定资产投资）、固定资产贷款（基本建设贷款和技术改造贷款，超过500万或者超过项目5%，需要受托支付方式）、项目融资（高风险高投资高回收期的项目，特殊固定资产贷款，多家银行参与）、房地产开发贷款（非住宅投资超过50%属于商业用房开发贷款）</p><p>贸易融资（国际贸易，支付业务和信贷业务的结合）：</p><p>a. 保理：出口商收到应收账款，把应用账款的卖给保理银行，银行的追索权看合同规定。</p><p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220509005438967.png" alt="image-20220509005438967"></p><p>b. 福费廷（forfaiting）：出口商收到商业票据，将商业票据（远期汇票和本票）卖给银行，银行向进口商追索，银行对出口商无追索权，长期固定利率融资。是一种特殊的票据贴现，<strong>福费廷相比于普通票据贴现，银行放弃了票据追索权</strong></p><p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220509005939676.png" alt="image-20220509005939676"></p><p>c. 信用证（L&#x2F;C）：进口商申请，<strong>信用证是开证行开给出口商</strong>（受益人）。<strong>信用证开证完后开证行是第一付款人</strong>，<strong>信用证处理的是单据而不是货物</strong>（货有问题，不能退钱），是<strong>开证行的支付承诺</strong>（只要和信用证上面描述发货信息一致，给钱）。</p><p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220509010627620.png" alt="image-20220509010627620"></p><p>d. 打包放款（又称信用证抵押贷款）：在信用证交易中，出口商收到信用证，但是货物生产资金有问题，将<strong>信用证抵押给银行</strong>，银行借钱给出口商，来生产这一批货物。</p><p>e. 出口押汇：在信用证交易中，出口商将货物发出后，在收到开证行发出的资金前，将<strong>货运单据做抵押</strong>，银行将资金融通给出口商，出口商<strong>即期收汇申请出口押汇，远期收汇申请贴现</strong>。</p><p>f. 进口压汇：在信用证交易中，开证申请人<strong>将代表货权的单据质押</strong>，银行借钱给进口商。</p></li><li><p>贷款流程：申请、受理调查、风险评价、审批、签订、发放、支付、贷后、贷款回收</p></li></ol><h2 id="保函和承诺业务"><a href="#保函和承诺业务" class="headerlink" title="保函和承诺业务"></a>保函和承诺业务</h2><p>都需要纳入综合授信管理，实行综合授信额度管理。</p><ol><li><p>保函（和信用证区别）：相当于开保函的行作为担保人，<strong>书面保证承诺</strong>（第二付款人），分为融资类保函和非融资类保函两大类（<strong>即期付款保函</strong>类同信用证）。</p><p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220713133059724.png" alt="image-20220713133059724"></p></li><li><p>备用信用证：借款人向开证行申请的特殊信用证，是<strong>银行保函的替代品</strong>，只有当申请人无法偿还时，银行才承担付款（银行第二付款人）。<strong>有可撤销和不可撤销</strong>。</p></li><li><p>贷款承诺业务的分类：<strong>项目贷款承诺</strong>（银行同意贷款某个项目）、客户授信承诺（解决短期流动资金需要，就是额度）、票据发行便利（银行对中期周转性票据发行融资的承诺，企业发短期票据，银行长期包销）和开立信贷证明（有条件和无条件信贷证明，也是用于中标后，银行统一贷款）</p></li></ol><h2 id="支付结算业务"><a href="#支付结算业务" class="headerlink" title="支付结算业务"></a>支付结算业务</h2><p>存贷汇三大传统业务，汇款就是支付结算业务，是银行最古老的业务，存贷在此汇款上发展而来。</p><p>支付结算原则：恪守信用，履约付款；谁钱进谁帐；银行不垫款</p><p>票据的出票日期必须是中文大写，零壹月、零贰月、零壹拾月。月：1、2、10。日：1至9，10，20，30</p><p>贰拾元整，<strong>元结尾必须要加整，角可选，分不加整</strong>。</p><h4 id="国内票据结算"><a href="#国内票据结算" class="headerlink" title="国内票据结算"></a>国内票据结算</h4><p>银行汇票、银行本票和支票不需要承兑，见票即付</p><ol><li>银行汇票：<strong>出票人和付款人都是银行</strong>（商业汇票出票人企业）。先存够钱银行才能开，<strong>异地</strong>使用，记名，<strong>有现金字样可取现</strong>，提示付款期限是出票日起1个月。</li><li>银行本票（promise，承诺）：本票基本情况与银行汇票相同，不同的是<strong>同城</strong>使用，提示付款期限是出票日起2个月。</li><li>支票：<strong>出票人是企业</strong>（单位活期存款账户就可以开），<strong>付款人是银行</strong>。<strong>同城</strong>使用，记名，现金转账普通三种支票。划线支票不能提取现金，提示付款期限是出票日起10日。</li><li>商业汇票：同城或者异地，<strong>出票人是企业</strong>，有商业承兑汇票（企业付款）和银行承兑汇票（银行付款，如果账户余额不足）两种。付款期限不得超过<strong>6个月</strong>，提示付款期限自到期日起10日。</li></ol><h4 id="国内非票据结算："><a href="#国内非票据结算：" class="headerlink" title="国内非票据结算："></a>国内非票据结算：</h4><p>银行卡、国内信用证</p><p>结算账户管理：个人结算账户和单位结算账户（个体工商户纳入单位计算账户，基本户）</p><p>只有一类户存取现金，二类户可以理财和支付，三类户只能支付</p><ol><li><strong>汇兑</strong>：就是打钱，<strong>异地</strong>结算中最广泛的。汇款划款解付3步。</li><li><strong>（异地）托收承付</strong>：<strong>先发货</strong>后，根据购销合同，委托银行帮忙收款。收款方可以选择邮汇和电汇，起点金额是1万，只有国有企业才能用的结算方式。</li><li><strong>委托收款</strong>：<strong>同城或异地，不受金额起点</strong>，一般水费电费等小费用</li></ol><h4 id="国际结算："><a href="#国际结算：" class="headerlink" title="国际结算："></a>国际结算：</h4><ol><li><p>汇款（顺汇-主动给钱）：付款人收款人汇出行汇入行4个当事人，分为电汇（通过SWIFT）、信汇、票汇</p></li><li><p>托收（光票和跟单，有无发票等商业单据界定，不是说的汇票等金融单据、直接托收）：逆汇。、</p><p>委托人、托收行（国内行）、代收行和付款人—4个基本当事人。提示行（收到拒绝时要通知托收行）和需要时的代理是2个其他当事人</p><p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220713230500812.png" alt="image-20220713230500812"></p></li><li><p>信用证（可撤销和不可撤销，现在基本只开不可撤销信用证。跟单和光票、基本都是跟单信用证—附带商业单据、都是不可转让信用证）：逆汇，基本当事人3个：开证申请人、开证行、受益人</p></li></ol><h4 id="清算业务："><a href="#清算业务：" class="headerlink" title="清算业务："></a>清算业务：</h4><p>四种清算模式：实时全额清算（每一笔支付）、净额批量清算（付款人之间结算后净值）、大额资金转账系统和小额定时清算。</p><p>国内清算：系统内联行清算—同一银行总分支行之间清算、跨系统清算—不同银行之间清算，通过中国人民银行办理</p><p>国际清算：内部转账型和交换性，清算双边或多边债务。</p><h2 id="票据业务"><a href="#票据业务" class="headerlink" title="票据业务"></a>票据业务</h2><p>票据业务是传统的<strong>资产业务</strong>，就是指贴现和承兑，通过承兑，商业信用转化成了银行信用，所以也归于<strong>信贷业务或者授信业务</strong>。坚持建立在真实业务上</p><ol><li>票据贴现业务：银行对未到期的远期票据<strong>有追索权的买入</strong>，或者说客户将未到期的<strong>票据背书转让给银行</strong>。银行转让票据给银行是转贴现，银行将票据转让给中央银行是再贴现。</li><li>汇票承兑业务（accept）：商业汇票才有承兑（和贴现），分为 <strong>商业承兑汇票</strong>（企业付款，如果有银行保证章，也能起到银行承兑汇票的作用）、<strong>银行承兑汇票（</strong>委托承兑行开立，银行承兑）两种。债权人和债务人都可以开，重点在于承兑。</li><li>买入返售（卖出回购）：<strong>两家金融机构之间</strong>约定先买后卖，不能有第三方担保，只能是2家金融机构。</li></ol><h2 id="代理和托管业务"><a href="#代理和托管业务" class="headerlink" title="代理和托管业务"></a>代理和托管业务</h2><p>代理业务：代收代付（如工资房贷）、代理银行（代理中央银行、代理商业银行）、代理证券、代理保险、委托贷款、代销开放式基金</p><h2 id="银行卡、理财、同业业务"><a href="#银行卡、理财、同业业务" class="headerlink" title="银行卡、理财、同业业务"></a>银行卡、理财、同业业务</h2><p>理财是表外业务(赚的是手续费)，不属于资产负债</p><p><strong>信用卡信息保存2年</strong></p><p>金融机构之间投融资业务，买入反售属于同业。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库加索引</title>
    <link href="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>数据库有3种方式创建索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 这种方式建立索引最简单，但是表中需要有数据，否则索引建立失败<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> lmt_crdt_app <span class="hljs-keyword">ADD</span> INDEX idx_cust_name(cust_name);<br># 通过<span class="hljs-keyword">create</span> INDEX<br><span class="hljs-keyword">CREATE</span> INDEX idx_cust_name <span class="hljs-keyword">ON</span> lmt_crdt_app(cust_name);<br># 可以在建表时，在所有字段的最后，加上索引 INDEX idx_cust_name(cust_name);<br></code></pre></td></tr></table></figure><p>最常见的是普通索引（<strong>INDEX</strong>），上面代码中创建的就全是普通索引</p><p>还有一种索引是唯一索引（<strong>UNIQUE INDEX</strong>），创建唯一索引在普通索引的INDEX前加一个UNIQUE标识就行了。他的值必须要唯一，如给“电子邮件”这个字段加上唯一索引，那么每一个电子邮件都不能够重复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/20/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E7%BD%91%E8%B4%B7%E7%B3%BB%E7%BB%9F/2.%E6%9F%A5%E8%AF%A2%E6%94%B9%E9%80%A0/"/>
    <url>/2022/07/20/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E7%BD%91%E8%B4%B7%E7%B3%BB%E7%BB%9F/2.%E6%9F%A5%E8%AF%A2%E6%94%B9%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h4><p>客户查询、产品查询（没有授信为什么会有贷款？120102）、合作平台查询。 </p><p>中间集大的时候，用数据库SQL直接计算效率更高。</p><ol><li><p>业务贷款查询（OG120104List.do）：产品下的客户的授信、贷款笔数、总贷款金额、总贷款余额</p></li><li><p>业务统计（OG120106List.do）：产品维度查询，加了个日期？</p><blockquote><p>和产品查询的记录数都不一样。记录对不上。</p><p>产品类别中，个人贷款和个人助贷的区别。这个查询中的日期是放款合同录入日期。</p><p>？放款余额不可能大于授信金额</p><p>授信合同、放款合同</p></blockquote></li><li><p>报表查询–审批通过率查询（OG1204List.do）：借款通过率、授信审批通过率</p><blockquote><p>抵押快带授信通过率为0，但已经有借款信息，不可能没有授信。</p><p>所有授信信息都在crd_app_info中吗？</p></blockquote></li></ol><h4 id="客户贷款查询（120101List）：缺少联合贷款产品。"><a href="#客户贷款查询（120101List）：缺少联合贷款产品。" class="headerlink" title="客户贷款查询（120101List）：缺少联合贷款产品。"></a>客户贷款查询（120101List）：缺少联合贷款产品。</h4><ol><li>产品类别和证件类别条件去除。</li><li>默认不查询和展示页面。jqDOM.attr</li><li>不设置产品时，搜索产品默认自营产品</li><li>搜索到目前缺少的产品（如联合贷中的网商贷，缺少哪些网贷产品）</li><li>数据量过大做限制（最后优化）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/19/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E7%BD%91%E8%B4%B7%E7%B3%BB%E7%BB%9F/1.%E7%BD%91%E8%B4%B7%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/07/19/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E7%BD%91%E8%B4%B7%E7%B3%BB%E7%BB%9F/1.%E7%BD%91%E8%B4%B7%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h4><ol><li>项目基本结构、项目基本配置文件配置（批量配置、队列配置）</li><li>宇信封装框架的基本使用（自定义jsp标签、封装框架调用数据库）、后管前后端不分离的流程（前端ajax调，通过xml配置后管后台接口的路径，op类相当于controller层+service层，component类相当于dao层）</li><li>接口的统一配置入口、使用ESB保文格式请求</li><li>授信用信的业务熟悉</li><li>授信用信有哪些表</li><li>消费壹贷FB33接口授信：业务流程、代码</li><li>1个联合贷业务代码查看。</li></ol><p>根据esb的格式变化，网贷的服务端接口有4个监听端口：</p><p>12013:  DESTcpIpServer.xml</p><p>12023:  DCDTcpIpServer.xml</p><p>12024:  DCDTcpIpServerNew.xml</p><h4 id="自营的几个主要表"><a href="#自营的几个主要表" class="headerlink" title="自营的几个主要表"></a>自营的几个主要表</h4><p>–授信申请。申请人授信的等等信息，姓名职业等个人信息、申请额度、审批额度、放款账号（卡号）、还款账户、抵押信息。<br>select * from <strong>crd_app_info</strong>;</p><p>–申请附加信息。拓展<br>select * from crd_app_extinfo_normal;</p><p>–授信合同。如果说通过授信了，会有授信合同。合同编号、个人基本信息、贷款用户、授信起始到期日期、客户经理、签约类型<br>select * from <strong>crd_cont_info</strong>;<br>–放款申请。授信合同编号、还款日、申请金额、还款方式、贷款利率、罚息利率<br>select * from <strong>loan_app_info</strong>;<br>–放款合同<br>select * from <strong>loan_cont_info</strong>;。授信合同编号、还款日、申请金额、还款方式、贷款利率、罚息利率、贷款金额、贷款余额（还剩多少没换的）、逾期本金、逾期天数、贷款起始到期日。</p><h4 id="点："><a href="#点：" class="headerlink" title="点："></a>点：</h4><p>网贷新接口是在client包中？</p><h4 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h4><p>银行是贷款人，客户是借款人。</p><p>授信：一种风险控制类概念，额度。（准入、反欺诈、贷款产品自定义规则，最后判断授信是否成功）</p><p>用信：贷款就是一种用信方式。在银行用信会体现在征信上。</p><p>放款：放款是一种用信方式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/16/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/0.%E9%93%B6%E4%BB%8E%E6%B3%95%E5%BE%8B/"/>
    <url>/2022/07/16/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/0.%E9%93%B6%E4%BB%8E%E6%B3%95%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="0-银行从业法律基础、监管"><a href="#0-银行从业法律基础、监管" class="headerlink" title="0. 银行从业法律基础、监管"></a>0. 银行从业法律基础、监管</h2><h4 id="银行基本法律"><a href="#银行基本法律" class="headerlink" title="银行基本法律"></a>银行基本法律</h4><p>《中国人民银行法》：</p><ol><li>规定中国人民银行的职能和职责（监督和批准金融机构是银保监会的）；中国人民银行只能为银行提供贷款，不能为政府机构贷款，不能直接购买债券。</li><li>规定人民币的法律地位。假币相关行为构成犯罪的追究刑责，不构成犯罪拘留15日以下，罚款1万元；非法使用人民币图样，罚款5万。</li><li>中国人民银行有<strong>直接检查监督权</strong>（对金融机构、单位、个人一些中国人民银行自身业务上的监督，比如银行的存款准备金率等）和<strong>建议检查监督权</strong>（建议国务院去查银行）</li></ol><p>《银行业监督管理法》：</p><ol><li>银保监会监管银行业金融机构、财务公司、金融租赁公司等</li><li><strong>审慎经营</strong>（风险管理、内部控制、资本充足率等）是银保监对银行业金融管理机构的<strong>核心经营指标</strong></li><li>国务院银行业<strong>监督管理机构的职责</strong>：银保监会对银行业金融机构的设立申请、业务新增业务需要在6个月内书面回应，更改和终止申请需要在3个月内书面回应（<strong>机构准入和业务范围准入</strong>）。对银行业金融机构董事和高级管理人员管理（<strong>人员准入</strong>）。机构或个人持有股份总额达5%需要审查（<strong>股东变更审查</strong>）。根据评级决定现场审查银行的频率。非现场监管。现场检查，检查人数不得少于2人。</li><li>问题银行：接管、重组和撤销</li></ol><p>《商业银行法》：</p><ol><li>一般业务都需要银保监批准，结汇售汇还需要中国人民银行的同意</li><li>商业银行的“<strong>三性四自”的经营原则</strong>：安全性、流动性、效益性；自主经营、自担风险、自负盈亏、自我约束</li><li>商业银行的分支机构也需要国务院银行监督管理机构办理营业执照，不需要按行政区设立，但<strong>分支机构不具有法人资格</strong>，民事责任由总行承担。分支机构超过6个月未开业或停业吊销营业支招，<strong>总行分配资本至分支机构总和不能超过资本总额60%</strong></li><li>开放贷款业务指标：资本充足率不得低于8%。流动性资产与流动性负债比例（流动性比例）不得低于25%，同一借款人不得超过资本净额的10%。</li><li>商业银行取得<strong>不动产需要在2年内处置</strong>。</li></ol><p>《反洗钱法》</p><ol><li>洗钱过程：处置培植融合。借用金融机构贷款；保留在洗钱天堂如瑞士、开曼等；现金密集型行业</li><li>中国人民银行是<strong>反洗钱的主管部门</strong>；中国银保监是实际来<strong>制定反洗钱规章</strong>、发现反洗钱犯罪向公安机构报告。</li><li><strong>金融机构客户信息至少保存5年</strong>（客户信息和交易信息）</li></ol><h4 id="商事法律制度"><a href="#商事法律制度" class="headerlink" title="商事法律制度"></a>商事法律制度</h4><p>《公司法》</p><ol><li>公司股东以出资额（有限责任公司）或认购股份（股份有限公司）承担责任。两合公司无限公司</li><li>工商行政管理机关登记公司，公司设立必须有公司章程（公司、股东、董监高有约束力）</li><li>股东会或者股东大会<strong>超过三分之二决议资产变更、选举更换董事</strong>。</li><li><strong>董事会对股东大会负责，公司经理对董事会负责</strong>。公司破解和解散</li><li>有限责任公司：出资额决定股东且股东人数<strong>不能大于50人，不能上市，无需向社会公布财报</strong>；股份有限公司则不同</li></ol><p>《证券基金与保险法律制度》</p><ol><li><strong>公开</strong>、公平 、公正三公原则是证券法的最基本原则。</li><li>证券发行：公开发行（非特定对象，或者特定对象超过200人）和非公开发行（私募发行）</li><li>证券发行管理制度：审批制（按照国家计划上市）、核准制、注册制（成熟股票市场，我国目前采用，不进行判断）</li><li>证券承销方式：<strong>证券代销和证券包销</strong>（卖不出去包销人买），代销包销日期不超过90天。内幕人持股5%以上。</li><li>基金是一种集合投资方式，<strong>证券投资基金</strong>（普通基金，公募私募基金），<strong>私募股权基金</strong>、风险投资基金（私募基金）、对冲基金（私募基金）</li><li>私募<strong>人数不能超过200人</strong>，私募是发行给未上市公司的。</li><li>股票基金（80%以上股票）、债券基金（80%以上债券）、混合基金、货币基金</li><li>私募股权基金：投资时效长，流动性长，专业性强</li><li>商业银行申请基金销售资格：主要分支机构<strong>负责人必须要取得基金从业资格</strong>，基金部门取得资格要<strong>大于50%</strong></li><li>保险合同当事人：投保人和保险人（保险公司）。保险合同关系人：被保险人和受益人</li><li><strong>保险代理人</strong>（站在保险公司角度卖）、<strong>保险经纪人</strong>（在投保人角度买），商业银行属于保险兼业代理结构。</li></ol><p>《信托法》</p><ol><li>信托法律关系的主体：委托人、受托人、受益人（委托只有双方）</li><li>信托财产分离出来，委托不分离财产权。信托的受托人以自己名义行事，委托关系的受托人以委托人的名义行事</li><li>信托法律关系的客体：信托财产</li></ol><p>《票据法》</p><ol><li>票据：汇票（商业汇票、银行汇票）、本票（我们国家只有银行本票）、支票</li><li>票据是一种无因证券（无需证明来源）、完全有价证券（像货币一样）、是债券证券、要式证券</li><li>票据是支付结算出现，票据贴现提现票据融资功能</li><li>票据行为：<strong>出票、背书</strong>（就是票据贴现）、<strong>承兑</strong>（汇票独有，谁汇票谁承兑）、<strong>保证</strong>（汇票和本票）</li><li>票据权利：付款请求权和追索权。票据的主债务人包括汇票的付款人和承兑人、本票和支票的付款人</li></ol><h4 id="民事法律制度（民法典）。。"><a href="#民事法律制度（民法典）。。" class="headerlink" title="民事法律制度（民法典）。。"></a>民事法律制度（民法典）。。</h4><p>民事主体：在中国的自然人（<strong>可以不是公民</strong>，在本国的外国人和无国籍人也是）、法人（如有限责任公司、股份有限公司等）、非法人组织（个人独资企业、合伙企业）。民事法律调整的是<strong>民事主体之间的人身和财产关系</strong>。</p><p>《总则》：</p><ol><li>民事权利能力（获取权力，承担义务）：权利<strong>自然人平等，法人的不同</strong>。</li><li>自然人的民事行为能力，才能行使民事法律行为。法人完全行为能力：</li></ol><p>​完全：18岁以上，16岁以上未成年人，自己劳动获取收入来源</p><p>​限制：8岁以上的未成年人，不能完全辨认自己行为的成年人</p><p>​无民事：8岁以下，8岁以上不能辨认自己行为（需代理人追认）</p><ol start="3"><li>宣告失踪（<strong>超过2年</strong>）、宣告死亡（<strong>超过4年或意外事件2年，或意外有关部门鉴定不可能存活</strong>，死亡婚姻解除，死亡之后婚姻关系恢复除了再婚）</li><li>法定代表人（口语通常误称法人）：代表法人从事民事活动，最终由法人承担后果，<strong>清算是法人终止的必要程序</strong>。</li><li>意思机关（权利机关）、执行机关（董事会）、代表机关（法定代表人）、监察机关（监事会）</li><li>民事法律形式：口头书面推定沉默数据电文</li><li>撤销权：<strong>发生了5年内</strong>撤销权消灭，<strong>知道了1年内</strong>要行驶撤销。可撤销的：重大误解（90日内）、欺诈手段、胁迫（1年内形式）、乘人之危</li><li>代理：代理人以被代理人从事代理活动（<strong>法定代理</strong>—无民事行为能力，<strong>委托代理</strong>—劳动合同），最终后果由被代理人承担。</li><li>代理种类：有权代理、无权代理（没有代理权，<strong>无法让人相信有代理权</strong>，相对人主观善意，被代理人追认生效，30日内追认）、<strong>表见代理（</strong>代理终止后，或者<strong>让人相信是有代理权</strong>，主观善意，无需追认）</li><li><strong>普通诉讼时效3年</strong></li></ol><p>《物权和担保》</p><ol><li>物权：包含<strong>所有权</strong>（国家集体私人）、<strong>用益物权</strong>（用别人的动产或不动产使用和收益，土地相关）、<strong>担保物权</strong>（抵押权、质权）。</li><li>物权是绝对权（对世权，义务主体是所有人，债券是相对权）、是支配权（债权是请求权）</li><li>不动产<strong>登记（公示）产生物权</strong>，动产<strong>交付就产生物权</strong>。</li><li>所有权有占用、使用、收益，<strong>处分</strong>的权力，是<strong>物权中最充分的</strong>。</li><li>保证：一般保证（债权人需要再保证时间内先提诉讼，债务人实在无法偿还时，才向保证人问责）和连带保证。</li><li>保证时间是<strong>债权到期6个月内到期</strong>。医院、学校等<strong>非盈利组织、非法人组织不能为保证人</strong>；机关法人不能为保证人（国务院批准的国际担保除外）</li><li>抵押不转移抵押物财产占有（不动产必须登记抵押，动产自抵押合同生效设立）、质押转移质押物财产占用（分为动产质押和权力质押，债券等都是权力质押）。</li><li>留置权：不履行合约，债权人可以<strong>留置动产</strong>，只能发生在特定的合同关系中（如债权人的加工合同中，留置权人需要确认宽限期）</li><li><strong>留置权优于抵押&#x2F;质押处置</strong></li><li>定金，作为债权的<strong>担保</strong>。房子不卖了，返还双倍定金。不能超过合同额的20%。<strong>订金可退</strong>。</li></ol><p>《合同》</p><ol><li><p>订立合同阶段：<strong>要约、承诺</strong></p></li><li><p>要约达到受约方即要约生效，受约人承诺合同成立</p><p><strong>要约撤回</strong>（要约到达受约方前）</p><p><strong>要约撤销</strong>（受约人承诺之前可以撤销，但是要约人确定了承诺期限不可撤销） </p></li><li><p><strong>承诺生效合同成立，合同成立时间不等于合同生效时间</strong></p></li><li><p>合同可以书面口头其他</p></li><li><p>法人的法定代表人和非法人组织的负责人超越权限代表订立的合同，相对人不知道的情况下，该代表行为有效。</p></li><li><p>超越经营范围，不得仅以超越范围确认合同无效</p></li><li><p>合同撤销或变更：重大误解（主要是违背真实意思）  、乘人之危、胁迫、缺少公平</p></li><li><p>合同无效：恶意的，虚假的，违背公序良俗、违反法律的。</p></li><li><p>合同法本质会促进交易，比如申请合同<strong>撤销时，法院可能会判变更</strong></p></li><li><p>超越代理权的代理商，追认合同生效（无权代理）。</p></li><li><p>合同债权转让：通知债务人就行，无需债务人同意。不得转让债权的合同：出版合同、委托合同、赠与合同、雇佣合同</p></li><li><p>合同终止：债务已履行；债务抵消、债务人将标的物提存、债权人免除债务。合同终止，之前的还需要履行</p></li><li><p>解除合同（买卖做不成了，不继续做）：协议解除、约定解除、法定解除</p></li><li><p>债务抵消、免除、混同（债权债务同一人）</p></li><li><p>违约责任：法定不可抗力客观情况–日然灾害、政府行为、社会异常事件。免责条款</p></li></ol><p>《婚姻和继承》</p><ol><li>夫妻财产制：<strong>书面约定优先法定</strong></li><li>婚姻期间超出日常生活的债务（<strong>赌博），不属于共同债务</strong></li><li>一般均等，但尽主要抚养义务或者与被继承人共同生活的，遗产可以多分</li><li>配偶子女父母为第一顺位继承人，丧偶儿媳等可以作为第一顺位继承人。兄弟姐妹祖父母为第二顺位继承人。</li><li>遗嘱有自书遗嘱、口头、录音、公证等，多份遗嘱的，<strong>以最后遗嘱为准</strong>。</li></ol><h4 id="刑事法律制度"><a href="#刑事法律制度" class="headerlink" title="刑事法律制度"></a>刑事法律制度</h4><ol><li><strong>社会危害性</strong>和刑事违法性是<strong>犯罪的特征</strong></li><li><strong>16岁以上需要负刑责</strong>。14岁-16岁需要负重大刑事责任，14岁以下不负刑事责任</li><li>犯罪预备、犯罪未遂（从轻或减除）、犯罪中止（免除或减轻）</li><li><strong>主刑（拘役和管制等）</strong>和<strong>附加刑（剥夺政治权力</strong>）</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>金融犯罪客体是金融管理秩序，犯罪主体是自然人或对象。金融犯罪一定是故意。内部和外部犯罪。</li><li><strong>无形伪造</strong>（有金融票证制作权的人，内部人）、有形伪造</li><li>发生在非国有公司叫<strong>职务侵占</strong>，国有公司的是贪污和履行合同失职罪</li><li><strong>开始</strong>政府监管金融—<strong>泡沫公司法</strong>，<strong>确立</strong>政府监管—<strong>国民银行法</strong></li><li>统一监管、多头监管、双峰监管</li><li>1984年中国人民银行监管，1994非现场监管开始。</li><li>2018年我国金融监管框架变为<strong>一委（国务院金融稳定发展委员会）一行两会（银保监、证保监）一局（外汇管理局）</strong>。</li><li>市场约束（信息披露）</li><li>审慎监管框架：全面的监管规则、行之有效的监管工具（流动性、拨备覆盖率、大额风险暴露、资本、银行账簿利率风险、杠杆）、科学的监管组织体系。</li><li>中国银行业协会的<strong>主管单位为银保监</strong>，<strong>执行机关为理事会，对会员大会负责</strong>，自律维权协调服务是职能，是一个人非营利机构。</li><li>银行业的黑名单和灰名单（限制从事重要岗位）</li><li>金融机构向金融消费者说明的<strong>重要内容和风险资料留存时间不少于3年。每半年排查金融安全隐患。</strong></li><li>金融机构的责任：经济责任、社会责任、环境责任</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/16/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/3.%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86/"/>
    <url>/2022/07/16/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/3.%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="商业银行组织架构"><a href="#商业银行组织架构" class="headerlink" title="商业银行组织架构"></a>商业银行组织架构</h4><ol><li>银行组织架构分类：企业法人角度分类（<strong>统一法人制</strong>—我国、多法人制） 、内部管理角度分类（总分行型—我国、事业部型、矩阵型—西方主流）</li><li>总分行型：<strong>垂直管理体系，分行利润中心</strong>，既能保证统一指挥，又能调动分行、支行的各项业务，<strong>实现业务主动性和积极性</strong></li><li>矩阵型：区域总部事业部接受<strong>双重领导</strong>，争夺资源，资源内耗。</li><li>西方商业银行组织架构：客户为中心的矩阵型组织架构。两大特点<ol><li>五大业务线：零售业务（个人基础）、财富管理业务（个人高端）、商业银行业务（公司基础业务）、金融市场业务和投行业务（公司业务）</li><li>顶层组织架构设计有三类：<strong>大个金和大公金</strong>分类—-渣打、德意志和花旗； <strong>客户需求</strong>基础和高端分类—法国巴黎银行；<strong>业务线职能</strong>—巴克莱和苏格兰皇家银行</li></ol></li><li>我国银行发展方向：垂直化发展风险管理体系、渐进式推进事业部制改革（客户为中心）、建设流程银行（业务线垂直管理、前后台分离制约、业务纵向考核）</li></ol><h2 id="1-银行管理的基本指标"><a href="#1-银行管理的基本指标" class="headerlink" title="1. 银行管理的基本指标"></a>1. 银行管理的基本指标</h2><p>银行管理有8大指标。</p><h4 id="1-规模指标"><a href="#1-规模指标" class="headerlink" title="1. 规模指标"></a>1. 规模指标</h4><p>资产规模、存贷款规模、市场份额、总市值–份数*股票市值、客户规模和收入等</p><h4 id="2-结构指标"><a href="#2-结构指标" class="headerlink" title="2. 结构指标"></a>2. 结构指标</h4><p>资产结构（生息资产占比）、贷款结构（零售贷款占比）、负债结构（定活比，定活比高资金成本高）、收入结构（非利息收入占比，风险易于控制，发达国家40%以上）、客户结构（二八定律，20%的高度客户贡献80%盈利贡献度）</p><h4 id="3-效率指标："><a href="#3-效率指标：" class="headerlink" title="3. 效率指标："></a>3. 效率指标：</h4><ol><li><strong>成本收入比&#x3D;营业费用&#x2F;营业净收入</strong>（不能超过45%，获取一份净值收入需要的费用占比，费用的主要构成是人工和固定资产折旧、摊销 ）</li><li><strong>人均净利润&#x3D;净利润&#x2F;员工数量</strong></li></ol><h4 id="4-市场指标"><a href="#4-市场指标" class="headerlink" title="4. 市场指标"></a>4. 市场指标</h4><ol><li>市盈率PE &#x3D; 股价(P)&#x2F;每股收益(E)：市盈率高，风险高并且收到投资者追捧。每股收益上年度为静态市盈率，取未来是动态市盈率</li><li>市净率PB &#x3D; 股价(P)&#x2F;每股净资产(B)：市净率低，投资价值高</li></ol><h4 id="5-安全性指标"><a href="#5-安全性指标" class="headerlink" title="5. 安全性指标"></a>5. 安全性指标</h4><p>银行风险主要是信用风险、市场风险、操作风险和声誉风险。</p><ol><li>不良贷款率：5%以下</li><li>不良贷款拨备覆盖率：120%～**150%**，不良贷款损失准备&#x2F;不良贷款余额</li><li>贷款拨备率：1.5%～**2.5%**，拨贷比，不良贷款损失准备&#x2F;贷款余额</li><li>资本充足率CAR（资本&#x2F;风险加权资产）</li></ol><h4 id="6-流动性指标。"><a href="#6-流动性指标。" class="headerlink" title="6. 流动性指标。"></a>6. 流动性指标。</h4><ol><li><p>流动性比例：流动性资产余额&#x2F;流动性负债余额，25%以上</p></li><li><p>四个不低于100%：流动性匹配率、流动性覆盖率LCR–短期、净稳定资金比例–中长期、优质流动性资产充足率</p></li></ol><h4 id="7-集中度指标"><a href="#7-集中度指标" class="headerlink" title="7. 集中度指标"></a>7. 集中度指标</h4><ol><li>单一最大客户贷款比例不超过<strong>资本净额</strong>的10%、单一集团授信集中度不超过资本净额的15%、最大十家客户贷款总额比例不超过资本净额。</li><li><strong>大额风险暴露集中度</strong>：可能要发生损失的金额称为风险暴露，金额<strong>超过一级资本净额的2.5%称为大额风险暴露</strong></li><li>非同业单一客户风险暴露不超过一级资本净额的15%，全球重要银行对另一家重要银行风险暴露不超过15%，非同业一组关联客户不超20%，同业客户风险暴露度不超过25%</li></ol><h4 id="8-盈利性指标。"><a href="#8-盈利性指标。" class="headerlink" title="8. 盈利性指标。"></a>8. 盈利性指标。</h4><ol><li>拨备前利润（净利润+风险准备金）：未扣除风险准备金的利润</li><li><strong>平均净资产回报率</strong>（净利润&#x2F;净资产，计算所有比例出发点，<strong>盈利性最重要指标</strong>）、平均总资产回报率（净利润&#x2F;总资产）</li><li><strong>风险调整后资本回报率</strong>：<strong>价值管理核心指标</strong>，考虑了预期损失，也考虑了非预期损失</li><li>每股收益：净利润&#x2F;股本总数，反应了每一股创造的税后利润，又称每股盈余</li><li>净息差：资产平均收益-负债平均收益率</li><li>净利息收益率：净利息收入&#x2F;期初期末生息资产。是银行盈利影响最大的指标之一</li></ol><h2 id="2-商业银行资产负债管理"><a href="#2-商业银行资产负债管理" class="headerlink" title="2. 商业银行资产负债管理"></a>2. 商业银行资产负债管理</h2><p>资产&#x3D;资本+负债。</p><ol><li>商业银行经营管理的基本原则：安全性、流动性、效益型。</li><li>传统资产负债管理的对象是资产负债表，现在已经转为表内外、本外币、集团化发展、主动管理、动态</li></ol><h4 id="资产负债管理的构成内容（八大管理：五资、三险、一价）"><a href="#资产负债管理的构成内容（八大管理：五资、三险、一价）" class="headerlink" title="资产负债管理的构成内容（八大管理：五资、三险、一价）"></a>资产负债管理的构成内容（八大管理：五资、三险、一价）</h4><ul><li><strong>资本管理</strong>：监管资本、账面资本、经济资本（风险资本）—后面拓展</li><li>资金管理：内部资金转移定价机制、全额资金管理体制</li><li>投融资业务管理：投融资和票据转贴现是银行重要的资产业务，是资金调控的蓄水池和信贷规模调节器。坚持科学规划、统一管理、集约经营、综合发展。</li><li><strong>资产负债组合管理</strong>：资产组合管理（资本约束为前提）、负债组合管理（平衡资金来源和运用为前提）、资产负债匹配管理（立足资产负债管理）</li><li><strong>资产负债计划管理</strong>：资产负债<strong>总量计划</strong>（根据资本总量和资本充足率确定资产负债总量计划）、资产负债<strong>结构计划</strong>（资本计划、信贷计划、投资计划、同业和金融机构往来融资计划、资产负债期限控制计划）</li><li>定价管理：外部产品定价、内部资金转移定价管理（FTP）</li><li>利率风险管理：因为利率结构和期限水平导致</li><li>流动性风险管理</li><li>汇率风险管理。</li></ul><h4 id="资产负债管理策略："><a href="#资产负债管理策略：" class="headerlink" title="资产负债管理策略："></a>资产负债管理策略：</h4><ol><li>表内资产负债匹配（核心策略）</li><li>表外工具规避表内风险（利率汇率规避市场风险，CDS规避信用风险）</li><li>利用证券化剥离表内风险</li></ol><h2 id="3-资本管理"><a href="#3-资本管理" class="headerlink" title="3. 资本管理"></a>3. 资本管理</h2><ol><li><p>资本分类：监管资本（合格资本或者最低资本）、账面资本（会计资本，资本金的静态）、经济资本（风险资本，<strong>衡量非预期损失</strong>（不包含预期），实际资本应该要大于经济资本，是一种内部管理工具）</p></li><li><p>资本作用：为银行提供融资（和负债一样为资产提供融资）、吸收和消费损失、限制业务过度扩张、维持市场信心</p></li></ol><h4 id="1988第一版巴塞尔协议："><a href="#1988第一版巴塞尔协议：" class="headerlink" title="1988第一版巴塞尔协议："></a>1988第一版巴塞尔协议：</h4><ol><li><p>第一次明确了资本充足率作为资本监管的基本要求，明确了资本充足率监管的三个要素：<strong>资本充足率&#x3D;监管资本定义&#x2F;风险加权资产</strong>。资本充足率是最低资本要求</p></li><li><p>提出了两个层次的资本</p><p>核心资本：<strong>实收资本</strong>（或普通股）、<strong>公开储备</strong>（资本公积、盈余公积、留存利润、股票发行溢价）</p><p>附属资本（不能超过核心资本）：非公开储备、重估储备、普通准备金、混合资本工具、长期次级债务</p></li><li><p>第一版巴塞尔协议关注信用风险。风险权重分为5个档次：0、10、20、50、100，用于计算风险加权资产</p></li><li><p>确定资本充足率标准（最低资本要求）：核心资本充足率要大于4%，资本充足率要大于8%</p></li></ol><h4 id="2004第二版巴塞尔协议的三大支柱："><a href="#2004第二版巴塞尔协议的三大支柱：" class="headerlink" title="2004第二版巴塞尔协议的三大支柱："></a>2004第二版巴塞尔协议的三大支柱：</h4><ol><li><p>最低资本要求：改革了加权资产的计算方式，风险加权资产要关注<strong>信用风险、市场风险和操作风险</strong></p></li><li><p>监督检查：现场和非现场</p></li><li><p>市场纪律（市场约束、信息披露）</p></li></ol><h4 id="2010第三版巴塞尔协议："><a href="#2010第三版巴塞尔协议：" class="headerlink" title="2010第三版巴塞尔协议："></a>2010第三版巴塞尔协议：</h4><p>三个资本：</p><ol><li>核心一级资本：吸收损失能力最核心的部分。<strong>普通股</strong>、资本公积、盈余公积、<strong>一般风险准备</strong></li><li>其他一级资本：吸收损失中等。优先股和永续债</li><li>二级资本：破产清算时吸收损失。次级债、可转债和超额贷款损失准备金</li></ol><p>核心一级资本充足率（普通股、实收资本、资本公积）、一级资本充足率（优先股）、总资本充足率</p><ol><li><p>全面强化资本充足率监管的三个要素：</p><p>a. 提升资本工具损失吸收能力（界定一级资本和二级资本的功能、<strong>普通股</strong>应该在一级资本中占主导地位）</p><p>b. 加强风险加权资产计算的审慎性。 </p><p>c. <strong>资本充足率的监管标准</strong></p><p>我国核心一级资本充足率：5%、我国重要性银行附加资本要求：1%</p></li></ol><p><img src="/Users/lee/Library/CloudStorage/Dropbox/pictureBed/image-20220714204550995.png" alt="image-20220714204550995"></p><ol start="2"><li>引入杠杆率监管标准，**杠杆率不低于3%**。资本充足率的指标。</li><li>建立流动性风险量化：<strong>流动性覆盖率</strong>LCR–短期、<strong>近稳定融资比率</strong>NSFR–中长期，不低于100%。</li></ol><p>巴三最终方案的确认，对于优化资源配置、增强风险计量可比性、强化市场约束重大意义。</p><h4 id="我国银行业资本监管"><a href="#我国银行业资本监管" class="headerlink" title="我国银行业资本监管"></a>我国银行业资本监管</h4><ul><li>我国第二支柱资本充足率要求（第四层次）：重要性银行—<strong>11.5%（8%+2.5%+1%）</strong>，非重要银行10.5%</li><li>我国计算时要减去<strong>资本扣除项</strong>：商誉、房产外的其他无形资产、<strong>贷款损失准备缺口</strong></li></ul><h2 id="4-风险管理"><a href="#4-风险管理" class="headerlink" title="4.风险管理"></a>4.风险管理</h2><p>风险是一种发生损失的可能性，风险造成的损失类型：</p><ol><li><strong>预期损失</strong>（<strong>信用风险&#x3D;违约概率*违约损失率*违约风险暴露</strong>）：使用风险定价来覆盖预期损失、利用贷款损失准备冲销。）、</li><li>非预期损失（99.9%下，可能超出预期损失的损失水平）：使用资本覆盖</li><li>极端损失（911事件）</li></ol><p>风险的分类：</p><ol><li>根据风险范围划分：系统性风险（全局的，系统性风险不可分散）和非系统性风险（局部的，通过组合投资分散）</li><li>巴塞尔委员会将银行风险分为8个：信用风险（主要风险）、市场风险、操作风险（包含法律风险）；流动性风险；战略风险（不适当的发展规划和战略决策）、国家风险（不同国家的金融往来中出现损失）、声誉风险（负面评价风险）和法律风险（比如没签合同）。</li></ol><h4 id="0-全面风险管理"><a href="#0-全面风险管理" class="headerlink" title="0. 全面风险管理"></a>0. 全面风险管理</h4><ol><li><p>银行的风险是错综复杂的，需要全面一起管理。</p></li><li><p>风险管理的组织架构：</p><p>a. 董事会：最高风险<strong>管理和决策机构</strong>，承担风险管理的<strong>最终责任</strong>或者说第一责任</p><p>b. 监事会：负责、监督评价</p><p>c. 高管：是<strong>执行机构</strong>，负责建立体系，高管的支持与承诺是商业银行有效风险管理的基石</p></li><li><p>三道防线（相互独立）：</p><p>a. 业务团队（第一道防线，承担首要、直接的责任）</p><p>b. 风险管理团队（有效防止系统性风险的发生）</p><p>c. 内部审计团队（监督和评估）</p></li><li><p>风险管理流程：</p><p>a. 风险识别</p><p>b. 风险计量</p><p>c. 风险监测</p><p>d. 风险控制：通过识别和计量后，采取分散、对冲、<strong>缓释和转移（如担保）</strong>、规避（不做某一业务）和补偿（保险）等策略和措施</p></li></ol><h4 id="1-信用风险管理。"><a href="#1-信用风险管理。" class="headerlink" title="1. 信用风险管理。"></a>1. 信用风险管理。</h4><ol><li><p>信贷（贷款）、证券投资、承兑和保证等都是信用风险，是银行最主要的风险</p></li><li><p>传统的信用风险如信贷风险是单向风险，交易对手的违约时是双向的</p></li><li><p>信用风险分类</p><p>a. 按风险能否分散分类：系统性信用分险（不能分散）、非系统性信用风险</p><p>b. 按风险发生形式分类：<strong>结算前风险</strong>和<strong>结算风险</strong>（结算风险在外汇交易中常见）</p><p>c.  按风险暴露特征和引起主体不同分类：零售风险、非零售风险（<strong>主权信用风险、金融机构信用风险、公司信用风险</strong>）、股权信用风险、其他信用风险</p></li><li><p>信用风险管控手段：</p><ul><li>信贷准入（控制授信）控制</li></ul></li></ol><ul><li>信贷退出控制<ul><li>限额管理</li></ul></li><li><strong>风险缓释</strong>：通过抵押质押保证工具，降低违约概率、违约损失率、违约风险暴露（净额结算）。<ul><li>风险定价：信用等级低，<strong>提高风险定价利率加以覆盖信用风险</strong></li></ul></li></ul><ol start="5"><li><p>贷款质量管理（五级分类）</p><p>贷款四级分类（正常、<strong>逾期、呆滞、呆帐</strong>）到五级分类（正常、关注、<strong>次级、可疑、损失</strong>）。</p><p>正常贷款包含正常类贷款和关注类贷款</p><ul><li>次级：即使执行担保，造成一定损失的贷款。可疑：即使执行担保，造成较大损失的贷款。损失：只能收回极少贷款。零售贷款使用脱期法进行分类（逾期90天次级，逾期180天可疑）</li><li>本金或利息逾期，至少关注。</li><li>本金利息已经逾期，并且利用合并、分立等形式恶意逃废银行债务，至少次级。</li><li>需要重组的贷款（无力偿还而调整还款条款的贷款）至少归为次级，重组后任然逾期，至少归为可疑。</li><li>本息已经全部偿还，连续两个还款期或者6个月正常还款，可上调风险评级</li><li>至少每季度对全部贷款进行一次分类（贷款质量的迁徙）</li></ul></li><li><p>贷款损失准备金：<strong>资产减值准备</strong>和一般准备（动态准备，银行总行在年末对风险评估与资产减值准备的差额）</p></li><li><p>不良贷款处置：</p><p>a. 现金请收：<strong>直接追偿</strong>（最主要）、诉讼追偿和委外清收</p><p>b.  贷款重组：重新约期、调整利率、变更担保、债务转移</p><p>c. 以资抵债：协议抵债、裁定抵债</p><p>d. 呆帐核销：银行承担风险和损失，内部账务处理，纳入表外核算。不可核销呆账：银行未履行追偿的债券等</p><p>e. 批量转让：将不良资产（次级可疑损失、已核销资产、抵债地产）转让给资产管理公司</p><p>f.  不良资产证券化</p><p>g. 市场化债转股：公司有发展前景，可疑债转股</p><p>h. 破产清偿：破产清算、破产和解和破产重组</p></li></ol><h4 id="2-市场风险管理"><a href="#2-市场风险管理" class="headerlink" title="2. 市场风险管理"></a>2. 市场风险管理</h4><ol><li><p>市场价格（利率、汇率、股票和商品价格）的不利变动造成的损失</p></li><li><p>利率风险（最主要的市场风险）：重新定价风险、收益曲线风险、基准风险和期权性风险</p></li><li><p>汇率风险：黄金纳入汇率风险考虑</p></li><li><p>市场风险的管控手段：</p><p>a. 限额管理：交易限额（限制买卖净额）、风险限额和止损限额（最大损失额）</p><p>b. <strong>风险对冲</strong></p></li></ol><h4 id="3-操作性风险管理"><a href="#3-操作性风险管理" class="headerlink" title="3. 操作性风险管理"></a>3. 操作性风险管理</h4><ol><li><p>由于不完善的内部流程（缺陷和错误）、人员、科技系统和外部事件造成损失的风险，包含法律风险，不包含战略风险和声誉风险。</p></li><li><p>操作风险具有普遍性、<strong>非营利性，不可避免</strong>。</p></li><li><p>操作风险管控手段：</p><p>a. 操作风险与控制自评估RCSA</p><p>b. 关键风险指标KRI</p><p>c. 损失数据库LD</p></li></ol><h4 id="4-流动性风险管理"><a href="#4-流动性风险管理" class="headerlink" title="4. 流动性风险管理"></a>4. 流动性风险管理</h4><ol><li><p>流动性风险：无法以合理的成本获得充足资金，用于偿付到期债务、履行支付义务和满足正常业务开展需要额风险。</p></li><li><p>相比市场风险、操作风险和操作风险，<strong>流动性风险形成原因更加复杂，通常被视为综合性风险。</strong></p></li><li><p>流动风险体现在市场和融资两个方面。</p><p>a. 市场流动性风险：无法合理出售资产</p><p>b. 融资流动性风险：无法迅速获取资金</p></li><li><p>流动性风险的管控手段：较少对流动性风险计提资本要求，要求银行具备完善的流动性管理体系和措施。</p><p>a. <strong>现金流量管理</strong></p><p>b. 限额管理</p><p>c. 融资管理：提高融资的多元化</p><p>d. 流动性压力测试：常规压力测试至少每季度进行一次</p><p>e. 应急计划</p></li></ol><h4 id="5-声誉风险管理。"><a href="#5-声誉风险管理。" class="headerlink" title="5. 声誉风险管理。"></a>5. 声誉风险管理。</h4><p>银行负面评价导致的风险。</p><ol><li><p>声誉风险管理的基本原则</p><p>a. 前瞻性原则：坚持以预防为主的声誉风险管理理念</p><p>b. 匹配性原则：进行多层次、差异化的声誉风险管理</p><p>c. 全覆盖原则：所有员工</p><p>d. 有效性原则</p></li><li><p>每年进行一次声誉风险管理评估</p></li><li><p>声誉风险管理的流程：风险评估、风险监测、风险分级、风险处置、风险报告、考核问责</p></li></ol><h2 id="公司治理、内部控制、合规管理"><a href="#公司治理、内部控制、合规管理" class="headerlink" title="公司治理、内部控制、合规管理"></a>公司治理、内部控制、合规管理</h2><h4 id="公司治理"><a href="#公司治理" class="headerlink" title="公司治理"></a>公司治理</h4><p>有效的公司治理是银行发展基石。银行章程是公司治理的基本文件</p><p>公司治理是指<strong>董监高+股东大会和其他利益相关者</strong>的相互关系。包含制衡机制（组织架构、职责边界、履职要求）、运行机制（监管、决策、执行、激励约束）</p><p>董事会和监事会对股东大会负责（股份有限公司是股东大会，有限责任公司是股东会），高管对董事会负责</p><h4 id="内部控制"><a href="#内部控制" class="headerlink" title="内部控制"></a>内部控制</h4><p>内部控制（符合法律）：<strong>董监高+全体员工</strong>参与的，实现目标（遵纪守法，控制风险）</p><p>内部控制四原则：全覆盖（所有人）、制衡性（相互制约）、审慎性（风险为本，审慎经营，内控优先制度先行而不是盈利优先）、相匹配</p><p>建立良好治理结构：董事会保证建立内部控制，高管负责建立和完善，董事会最终责任</p><p>内部控制治理措施：内控制度、<font>风险识别</font>、信息系统、岗位设置等等。每年一次外包评估，战略风险审计等不能外包</p><h4 id="合规管理"><a href="#合规管理" class="headerlink" title="合规管理"></a>合规管理</h4><p>合规管理即合规风险管理，对于银行由于不合法而损失的风险进行管理</p><p>合规管理的重点内容：</p><ol><li>建立强有力合规文化（高层领导做起）</li><li>建立有效的合规风险管理体系（<strong>董事会监督</strong>，高管建立部门，合规部门制定具体的）</li><li>建立基本的合规制度（考核问责举报）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/15/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/1.%E7%BB%8F%E6%B5%8E%E5%92%8C%E9%87%91%E8%9E%8D%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/15/%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/%E9%93%B6%E8%A1%8C%E4%BB%8E%E4%B8%9A/1.%E7%BB%8F%E6%B5%8E%E5%92%8C%E9%87%91%E8%9E%8D%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-经济金融知识"><a href="#1-经济金融知识" class="headerlink" title="1. 经济金融知识"></a>1. 经济金融知识</h2><h4 id="经济基础："><a href="#经济基础：" class="headerlink" title="经济基础："></a>经济基础：</h4><ol><li><p>经济增长：GDP是地区内<strong>本国和外国居民产品和劳务</strong>总和，有价值收入产品三种形态，有生产法、收入法和<strong>支出法</strong>三种计算方法。</p></li><li><p>就业充分：失业人数占16岁以上具有劳动能力人数的百分比，我国是城镇登记失业率，实际上会有所偏低。</p></li><li><p>物价稳定：物价总水平稳定。CPI、PPI（生产者物价指数，批发价的变化）、GDP defaulter（国内生产总值物价平减指数）</p></li><li><p>国际收支平衡：是国家<strong>居民和非居民</strong>之间的交易、包含外汇和易货等交易、包含价值对等和单方面转移。逆差是买的多，本币信心丧失，本币贬值；顺差是卖的多，大量外汇闲置，本币通货膨胀。国际收支平衡表三个账户：<strong>经常账户</strong>（结算账户）、<strong>资本与金融账户</strong>、<strong>错误与遗漏账户</strong></p></li><li><p>4大金融危机：货币危机（泰国）、银行危机（房贷）、外债危机（冰岛危机）、系统性金融危机。</p></li><li><p>GDP构成从支出角度看：<strong>消费、投资和净出口</strong>。私人买房算投资不算消费。</p></li><li><p>金融业4大门类：货币金融服务（银行）、资本市场服务（证券期货）、保险业、其他金融业</p></li><li><p>垄断4个结构类型：完全竞争（产品无差异，现实很少，初级产品，如农产品）、<strong>垄断竞争</strong>（侧重竞争，生产者众多，生产资料可流动，产品<strong>同种不同质</strong>，纺织、零售行业）、<strong>寡头垄断</strong>（石油电信行业）、完全垄断（铁路行业，只有1个垄断，现实很少）。第一种和第四种比较少见</p></li><li><p>增长型行业（互联网，与经济周期关联小）、周期性行业（房地产，与经济周期相关）、防守型行业（食品，不受经济周期影响）</p></li><li><p>经济周期：<strong>繁荣衰退萧条复苏</strong>四个阶段。社会经济是有周期的</p></li><li><p>行业的生命周期：<strong>初创</strong>、<strong>成长</strong>（行业黄金发展期，利润迅速增加，竞争压力大）、<strong>成熟</strong>（巅峰时期）、<strong>衰退</strong>（时间最长，可能比其他阶段加起来还长）</p></li><li><p>区域发展分析包含经济、社会和生态环境三个方面。</p></li></ol><h4 id="金融基础："><a href="#金融基础：" class="headerlink" title="金融基础："></a>金融基础：</h4><ol><li><p>货币的五大职能：<strong>价值尺度（货币可以是观念形态）、流通手段（一手交钱一手交货，货币需要是现实足值货币）</strong>、贮藏手段、支付手段（价值的单方面流动，赊账、发工资、偿还欠款、捐款等属于支付手段）、世界货币。</p></li><li><p>货币需求量（理解为现金）的影响因素：收入（正，要发钱）、利率（指银行利率，<strong>负</strong>）、$货币需求量M &#x3D; PQ&#x2F;V$—–(物价水平、社会商品可供量、货币流通速度)、信用制度发达程度（<strong>负</strong>）、汇率（本币汇率上升，本币升值，人们希望持有本币，本国货币需求量增加）、公众预期和偏好（预期物价水平上升，人们便好商品，货币需求减少）。</p></li><li><p>货币供给量（M2）：存量概念、<strong>包含现金货币和存款货币</strong>，信用制度发达条件下，可流通的金融债券等票据也是货币供应量。货币供应量&#x3D;&gt;货币需求&#x3D;&#x3D;&gt;影响社会总需求和总供给的均衡</p></li><li><p>货币层次：</p><ol><li>流通中的现金M0：银行体系外的现金（数字货币定位M0）。</li><li>狭义货币M1，<strong>M1代表现实购买力</strong>：M0+企业或单位存款+农村存款（农村单位存款）+个人持有信用卡类存款。</li><li>广义货币M2，通常意义的货币供应量，反映社会需求变化未来通货膨胀压力：M1+准货币（城乡居民存款、企业定期存款、外币存款、信托类存款、公积金）。<strong>准货币代表潜在购买力</strong></li><li>M3：M2+<strong>金融债券+商业票据+大额可转让定期存单</strong></li></ol></li><li><p>社会融资规模：实体经济从金融体系中获得的资金总额（包含信贷总额、证券、保险总额等）</p></li><li><p>客户存现金是原始存款，非现金贷款会提高派生存款率，派生存款是信用扩张的基础，</p><p>存款总额&#x3D;原始存款*存款乘数；<strong>货币供应量（现金+存款）&#x3D;基础货币（高能货币）*货币乘数</strong>。 </p></li><li><p><strong>货币乘数的影响因素</strong>：法定存款准备金率、超额准备金率、定期存款准备金率和现金漏损率（客户提取现金率）—-都是反比关系</p></li><li><p>通货膨胀的原因：需求拉上（主管需求提升）、成本推动（供给变化，工资推进和利润推进）、需求供给混合、结构型（好部门涨，差部门也要求会涨）。</p></li><li><p><strong>通货膨胀的治理</strong>：</p><ol><li>用紧缩的货币政策：减少货币供应量（直接减少基础货币投放、提高影响货币乘数的准备金率），提高利率（提高基准利率—-降低银行所持有的资金去放贷）</li><li>紧缩的财政政策：流入社会的钱要变少，政府增加税收，减少支出，打到减少赤字的作用。财政赤字：支出大于收入</li><li>紧缩的收入政策和积极的供给政策。</li></ol></li><li><p>我国传统货币政策工具：三大法宝+再贷款（调整再贷款量和再贷款利率即基准利率）。 </p><p>货币政策传导机制：货币政策工具（存款准备金政策、再贴现率和公开市场业务）&#x3D;&#x3D;&gt; 货币政策的操作目标（存款准备金率、<strong>基础货币</strong>和其他指标）&#x3D;&#x3D;&gt; 中介目标（<strong>货币供应量</strong>、利率和其他指标）&#x3D;&#x3D;&gt; 最终宏观经济。我国的主要操作目标是基础货币，中介目标是货币供应量</p><p>a. 比如，存款准备金率（含法准和超额）提升，影响存款准备金率，减少了银行的信贷规模，影响货币供应量和利率</p><p>b. 公开市场业务，中央银行去公开市场买卖政府和国库券，来影响货币供应量，相比调整再贴现率有央行的灵活主动性，公开市场业务可以<strong>微调</strong>，<strong>公开市场是最常用的货币政策工具</strong>。再贴现率和公开市场业务一样，调整信贷规模，影响基础货币，从而影响货币供应量。</p><p>c. 操作目标和中介目标的选取标准是可测性、可控性、相关性。</p><p>d. 创新型的货币政策工具（新增）：短期流动性调节工具SLO,7、临时流动性便利TLF,28、常备借贷便SLF,3个月，抵押方式。 </p></li><li><p>基准利率（官定利率）在<strong>市场经济国家主要是指再贴现利率，而我国是再贷款利率。</strong></p></li><li><p><strong>贷款市场报价利率（LPR），贷款基准利率改革而来</strong>：全国银行间同业拆借中心计算得出，包含1年期和5年期两个品种。</p></li><li><p>我国外汇汇率采用以外币作为标准的直接标价法（汇率上升，数值变小），美国和英国等少数国家采用间接标记法（本币不变）</p></li><li><p><strong>购买力平价</strong>是决定当今纸币汇率的基础，之前金本位是铸币平价。</p></li><li><p>汇率的影响因素：</p><p>a . <strong>国际收支</strong>，哪国逆差，哪国货币贬值（比如美国逆差中国，对人名币需求大，美元贬值；但是反过来本币贬值后，有利率出口，有可能产生顺差、会外储备增加）；</p><p>b. 利率水平（利率降低，偏好存外币，本币贬值）；</p><p>c. 通货膨胀因素（哪国通胀高，购买力下降，本币贬值）；反过来其他不变情况下，本币贬值后，有利于出口，本国商品少了，会产生通膨；</p><p>d. 政府干预</p></li><li><p>汇率上升，默认就是说本币汇率上升，人民币升值。</p></li><li><p>我国外汇汇率目前是<strong>以市场汇率为基准、参考一篮子货币、有管理的浮动汇率制度</strong></p></li></ol><h4 id="金融市场："><a href="#金融市场：" class="headerlink" title="金融市场："></a>金融市场：</h4><p>证券是是财产权的有价凭证，需要有一定的流动性。主要是股票和债券，还有票据、回购协议和cds等。</p><p>票据是一种一年以内短期无担保的特殊债券，发行一般是企业，而债券短则一年，分为国债、政府债券、金融债券和企业债券等。金融债券和银行承兑汇票风险相当，企业债券和商业承兑汇票风险相当或者略低于，票据还具有支付结算功能。</p><ol><li>金融市场六大功能：<strong>资金融通功能</strong>、优化资源配置、风险分散和管理、经济调节功能、交易和定价功能、反映经济运行（晴雨表）。</li><li>金融市场也可分为发行市场（一级市场，通过经纪人购买）和流通市场（二级市场）。交割时间几天之内叫现货市场，一个月以上的是期货市场（初级产品，石油等）。有形市场（具体场所）和无形市场</li><li><strong>货币市场</strong>：<strong>一年以内</strong>的资金融通市场，<strong>风险小</strong>。同业拆借（无担保，国际LIBOR、国内SHIBOR）、回购（签回购协议，先卖国债借钱，再买回来。<strong>相当于抵押贷款</strong>，一般发生在央行和银行或者金融机构之间）、商业票据（信用等级大企业发行的<strong>短期无担保的特殊债券</strong>）、银行承兑汇票、大额可转让定期存单（CDs，不可提前支取，但可在二级市场转让）等。短期就少有二级市场。</li><li><strong>资本市场</strong>：一年以上的资金融通市场，风险高。主要包含<strong>股票市场和债券市场（中长期）</strong>等，中长期贷款。</li><li>股票投资主体不同分为：国家股、法人股、社会公众股</li><li>债券种类：政府债、金融债（金融机构发的，中期是1-10年）、公司债（<strong>注册制</strong>，中期是1-5年）</li><li>普通股：有经营决策权，公司赚越多股息越多，优先认股权（增发普通股股票，可以优先认购维持股份比例）。</li><li>优先股：优先领取股息、优先清偿（比普通股风险低）。限制经营决策，优先股股息固定。</li><li>人民币A股、外币认购是B股（给香港和外国买的）、H股香港、N股美国纽约的大陆企业</li><li>债券发行价格和面值不一定一致。发行价格受内部因素（债券面值）和外部因素（票面利率和市场利率等）和发行成本影响。<strong>票面利率低于市场利率，一般折价发行。票面利率高于市场利率，一般溢价发行</strong>。</li></ol><p>83题（）</p><h4 id="金融市场体系："><a href="#金融市场体系：" class="headerlink" title="金融市场体系："></a>金融市场体系：</h4><ol><li>货币当局（中国人民银行和国家外汇管理局）、金融监管机构（银保监和证监会）</li><li>银行金融机构（开发性银行是国开行，政策性银行是中国进出口银行和中国农业发展银行、普通商业银行）</li><li>非银行金融机构（也属于银保监监管，信托公司、财务公司、汽车金融公司、金融租赁公司、消费金融公司）</li><li>证券期货类金融机构（证券、基金、期货）、保险类金融机构</li><li>其他金融机构（小贷公司、支付公司、融资担保公司等，是<strong>准金融机构</strong>，不受银保监监管，受地方政府监管，不能吸收存款）</li><li>金融自律组织（银行业协会、证券、期货等等各种协会）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用brew去管理一些后台进程</title>
    <link href="/2022/03/24/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/6.brew/"/>
    <url>/2022/03/24/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/6.brew/</url>
    
    <content type="html"><![CDATA[<p>brew对于命令行的程序，起到一个打包编译的作用，ARM版的brew通常只能安装ARM版的程序。</p><p>brew常用的命令brew list&#x2F;search&#x2F;info&#x2F;intall&#x2F;unintall&#x2F;deps&#x2F;outdated&#x2F;update&#x2F;upgrade等。</p><p>在命令前加入<code>arch -x86_64</code>模拟x86环境运行。</p><p>建议brew安装mysql&#x2F;redis，且推荐安装以后使用<code>brew services</code>来管理服务的启动和关闭。以mysql为例，<code>brew services start mysql</code>和<code>mysql.server start</code>同样可以启动mysql，要注意brew的启动在重启后不会失效，使用brew有利于统一多服务的管理。</p><h3 id="macOS多版本-node"><a href="#macOS多版本-node" class="headerlink" title="macOS多版本 node"></a>macOS多版本 node</h3><p>可以使用nvm和n这样常用的node管理工具来管理安装，也可以使用node link&#x2F;unlink不同的node版本</p>]]></content>
    
    
    <categories>
      
      <category>Mac相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GIT要注意的几个问题</title>
    <link href="/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/4.GIT/"/>
    <url>/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/4.GIT/</url>
    
    <content type="html"><![CDATA[<p>Git的commit版本是整个库的版本，不是单独具体到某个文件的版本，处于不同commit的文件，可能就是相同的。</p><p>Git有三大分区，工作区、暂存区和版本库。文件add后，存在于stage区中（暂存区），通过commit到版本库。</p><h4 id="关于切换分支的问题"><a href="#关于切换分支的问题" class="headerlink" title="关于切换分支的问题"></a>关于切换分支的问题</h4><p>切换分支时，如果暂存区中有文件在修改，会有两个情况。第一种是两个分支里的文件内容相同时，checkout切换分支会将暂存区中的修改内容保留；第二种情况是两个分支里的文件就不同时，会提示禁止checkout（-f 强制切换时，会丢失修改内容），此时不想commit，可以使用<code>git stash push</code>，临时存储暂存区修改，push通常省略，使用<code>git stash pop</code>恢复最后一次stash的暂存区。</p><h4 id="pull、push"><a href="#pull、push" class="headerlink" title="pull、push"></a>pull、push</h4><p>pull相当于fetch+merge操作。</p><p>本地和远程的相同分支，本质上是两个分支，pull相当于现将远程分支merge到本地merge，合并规则和本地之间的不同分支是相同的。</p><p><strong>与远程分支同步时</strong>，如果本地有暂存区修改，一定要<strong>先commit，再pull，再push</strong>。</p><p>merge过程中，暂存区不会修改，IDEA的merge过程，远程分支别人已经修改过一版，此时pull正常merge到本地，再commit，可能会将别人的代码覆盖而Git不会出现任何提示，而先commit，再pull，过程中Git会提示解决冲突。本地解决完冲突后，最好再次pull，再push。</p>]]></content>
    
    
    <categories>
      
      <category>GIT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/5.HTTP/"/>
    <url>/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/5.HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP报文由起始行、头部、正文三部分组成，请求报文的起始行教请求行，响应报文的起始行叫状态行，然后头部和正文之间有空行。</p><p>请求报文：</p><p>响应报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Server: nginx<br>Date: Mon, <span class="hljs-number">20</span> Feb <span class="hljs-number">2017</span> 09:<span class="hljs-number">13</span>:<span class="hljs-number">59</span> GMT<br>Content-Type: text/plain;charset=UTF-<span class="hljs-number">8</span><br>Vary: Accept-Encoding<br>Cache-Control: no-store<br><br>&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>无连接</strong>；即请求时连接，返回响应就释放连接。多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消。</p></li><li><p><strong>无状态</strong>：每个HTTP请求是独立的，服务器不会记住之前的请求和响应的状态。所以用<strong>Cookie和Session</strong>来模拟状态信息。</p></li></ol><p>Cookie：会话保存在客户端，Cookie只能保存是字符串（4KB），切勿保存重要数据，<strong>默认浏览器关闭时清除session</strong>，除非服务端设置setMaxAge。一个cookie对象中最重要的成员变量就是name和value，在Javaweb中，使用request.getCookies()获得一个cookie数组，request.getName()获得cookie的name，getValue获得cookie的value</p><p>Session：会话保存在服务器，在调用getSession时创建，判断cookie中有无sessionid，无就生成sessionID，定义一个会话状态，并将sessionid通过Cookie发送给浏览器。</p><p>restful的前后端分离项目中一般会使用 access_token，因为前后端分离项目跨域，使用cookie里的sessionID不方便认证状态，这个token和session_id是一个意思。<a href="https://juejin.im/entry/5bd921fce51d45686d40b2d6">分离Cookie参考</a></p><p><a href="https://blog.csdn.net/hxfghgh/article/details/82840613">关于Cookie</a></p><h4 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1. HTTP 请求报文"></a>1. HTTP 请求报文</h4><p>请求行–HTTP头字段–空行–正文</p><ol><li>**GET请求：放在请求行(URL)**，会暴露在地址栏，有长度限制，会被主动Cache，只有默认编码。</li><li><strong>POST请求：放在报文体</strong>，无长度限制，可以传输中文。POST请求也可以在请求行中写入数据，这时候类似GET请求，但一般没人会在form action或ajax url中加入这种处理</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html?name=kelvin&amp;password=123456</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,en;q=0.6<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br><span class="language-ini"></span><br></code></pre></td></tr></table></figure><h4 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2. HTTP 响应报文"></a>2. HTTP 响应报文</h4><p>状态行–HTTP响应头–空行–正文（body）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-HTTP-Header"><a href="#3-HTTP-Header" class="headerlink" title="3. HTTP Header"></a>3. HTTP Header</h3><p>HTTP Header中有四种Header Filed：</p><p>通用头：请求头和响应头都可使用字段</p><p><strong>Cache-Control</strong>、Pragma、Date、Via</p><p>Connection：keep-alive&#x2F;close</p><p>实体头：用于定义Entity Body（数据）的一些信息的头字段</p><p>Location（重定向跳转就设置了这个）、</p><p><strong>Content-Type</strong>、Conetent-Encoding（响应内容的压缩）、</p><p>Expire、Allow、Etag（资源标识符）、Last-Modify</p><p><strong>请求头：</strong></p><p>User-Agent、Host、Referer、<strong>Accept</strong>（希望接收的类型）</p><p><strong>响应头：</strong></p><p>Age（在代理服务器中缓存秒数）、Server（提供服务器信息）、Vary</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP缓存也称为Web缓存，主要就是客户端本身的<strong>浏览器本地缓存</strong>和代理服务器缓存（正向代理和反向代理）。<strong>只能缓存GET请求</strong>的内容，缓存css、js、HTML等静态资源</p><p><a href="https://juejin.im/post/5c417993f265da61285a6075">缓存Cache-Control参考</a></p><p>在HTTP1.0时代，pragma和Expires两个头字段可以设置缓存策略。</p><p>到了HTTP1.1以后，又有<strong>Cache-Control</strong>设置缓存策略，HTML meta、动态网页中可以设置。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span>：允许客户端和代理服务器缓存<br><br>private（<span class="hljs-keyword">GET</span>请求默认）：允许客户端缓存<br><br>**<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>**：允许客户端缓存，但每次快取需要由服务器请求缓存是否过期，未过期返回<span class="hljs-number">304</span>。协商缓存<br><br>**<span class="hljs-keyword">no</span>-store：不允许缓存。**<br><br>**max-age=<span class="hljs-number">60</span>**：允许缓存保留<span class="hljs-number">60</span>秒（自带<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>），没有这个属性就会去查找expire。强缓存<br><br>must-revalidate<br></code></pre></td></tr></table></figure><p>这些设置缓存的头字段时通用头字段，当request和response都设置时，Apache或nginx等服务器可以设置听哪个request还是response的。</p><p><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/">浅谈在代理环境中的 DNS 解析行为</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/</url>
    
    <content type="html"><![CDATA[<p>mybatis是一个简单工具根据项目调整编写风格。如何写resultmap也是一个比较简单的，模仿性很强的，学习更好的代码。</p><p>mybatis的作用，我认为最关键的就是结果集映射，将数据库结果集，映射到实体类。两种形式resultType和resultMap。mybatis能算得上是最好的方式吗？</p><h4 id="一对一关联association"><a href="#一对一关联association" class="headerlink" title="一对一关联association"></a>一对一关联association</h4><p>对象一对一依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.Emp&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1. 通过左外连接，连接子表的结果返回到这个association的resultMap里。</span><br><span class="hljs-comment">  如果返回的结果用association中用自定义的映射代替resultMap，association要带一个javaType属性，代表属性类型--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Departments.deptMap&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 2. 通过嵌套查询，将查询的结果返回到这个里面来 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;department_id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;Departments.selectById&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="一对多关联Collection"><a href="#一对多关联Collection" class="headerlink" title="一对多关联Collection"></a>一对多关联Collection</h4><p>对象一对多依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1. 需要在collection里指定resultMap（可以自定义）和ofType，接受左外连接传来的数据</span><br><span class="hljs-comment">使用连接查询，里面不能使用分页，否则collection里数据截断。</span><br><span class="hljs-comment">默认javatype是List，可省略List</span><br><span class="hljs-comment">如果ResultMap的type写util.Map(很少)的话，此时必须指定collection的JavaType--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.mybatis.model.RoleInfo&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;entity.Menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createdate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modifydate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifydate&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select <br>  ram.roleid as id,<br>  ro.name as name,<br>  me.id as menuid,<br>  me.name as menuname,<br>  me.description,<br>  me.parent,<br>  me.createdate,<br>  me.modifydate <br>  from roleandmenu ram<br>  left outer join role ro on ram.roleid=ro.id<br>  left outer join menu me on ram.menuid=me.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 使用嵌套查询，会用column指定的列，作为第二次查询的参数，在这个查询里指定resultType或者ResultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;entity.Role&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select id,name from role<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.mybatis.model.Menu&quot;</span>&gt;</span><br>  select m.id,m.name<br>  from menu m join roleandmenu ram on m.id=ram.menuId<br>  where ram.roleId=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mahoking/article/details/46811865">批量增删改</a></p><h4 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h4><p>mysql<a href="https://blog.csdn.net/mytt_10566/article/details/74279105">主键自增长</a>生成：使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”Employee_id”**，在SQL语句中不写自增长字段。</p><p>可以不用<a href="https://blog.csdn.net/death05/article/details/53098328?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">trim</a>，插入为空就不插入了，但是要指定jdbcType。用trim+if判断空值，不需要指定jdbcType。批量插入parameterType依然写类（类地址？）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;department_id&quot;</span>&gt;</span> <br>  insert into departments(default, department_name) values (#&#123;department_id&#125;,#&#123;department_name&#125;) <br>  // 或者insert into departments(department_name) values (#&#123;department_name, jdbcType=varchar&#125;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="update元素"><a href="#update元素" class="headerlink" title="update元素"></a>update元素</h4><p>不修改的值保持原值，传入一个对象。字符串写判断是否为空字符串或null，传入对象时要带其id</p><p><strong>基本数据类型和对象等数据只需要判断是否为null</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Employee&quot;</span>&gt;</span><br>update employee <br>  //set同样会帮我们忽略最后的“，”<br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    //注意if中的first_name是对象中，不是数据库中<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt;</span><br>      first_name = #&#123;first_name&#125;,<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary!=null &quot;</span>&gt;</span> <br>      salary = #&#123;salary&#125;, <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span> <br>  where employee_id = #&#123;employee_id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="元素"><a href="#元素" class="headerlink" title="&lt;delete&gt;元素"></a>&lt;delete&gt;元素</h4><p>一般使用单ID删除，可以在service层循环ID，带调用单删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parametertyep</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>delete from employee where employee_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int[]&quot;</span>&gt;</span> <br>  delete from employee where employee_id in <br>  <span class="hljs-comment">&lt;!-- collection只能写array或者list，即数组或集合，但是orderIDs --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="元素-1"><a href="#元素-1" class="headerlink" title="&lt;select&gt;元素"></a>&lt;select&gt;元素</h4><p>条件查询，用Map&lt;String, Object&gt;作为传入参数，可以不写parameter</p><p>where 1&#x3D;1？</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;mapper namespace=<span class="hljs-string">&quot;com.lee.Mapper.Employee&quot;</span>&gt;<br>  &lt;select id=<span class="hljs-string">&quot;select&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;Employee&quot;</span>&gt; <br>    select * from employee e left outer join Dept d on e.deptno=d.deptno<br>    <span class="hljs-comment">// 可以用where，mybatis会自动帮我们忽略</span><br>    &lt;trim prefix=<span class="hljs-string">&quot;where&quot;</span> prefixOverrides=<span class="hljs-string">&quot;and | or&quot;</span>&gt; <br>      &lt;!-- first_name是Map中的Key，用#&#123;first_name&#125;获取到value --&gt; <br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> #&#123;first_name&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;job_id!=null and job_id!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">job_id</span> <span class="hljs-operator">=</span> #&#123;job_id&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt; <br>    &lt;/trim&gt; <br>&lt;<span class="hljs-type">if</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;index!=null&quot;</span>&gt;<br>      limit #&#123;index&#125;,#&#123;pageSize&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt; <br>  &lt;/select&gt;<br>  &lt;!-- 计数--&gt;<br>  &lt;select id=<span class="hljs-string">&quot;count&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>    select <span class="hljs-title function_">count</span><span class="hljs-params">(*)</span> from employee<br>    &lt;where&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;firstName !=null and firstname!=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> # &#123;firstName&#125;<br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>  &lt;/select&gt;<br>  <br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h4 id="SQL块"><a href="#SQL块" class="headerlink" title="SQL块"></a>SQL块</h4><p>用SQL块代替常用于字段，一个表中的字段可能很多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empSql&quot;</span>&gt;</span><br>  first_name,job_id,salary,department_id <br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--字段用include动态SQL块代替，类似于alias --&gt;</span><br>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empSql&quot;</span>/&gt;</span> from employe<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js的函数和方法的区别</title>
    <link href="/2021/04/12/front/3.js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/12/front/3.js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天偶尔看到，JS中的函数和方法这两个概念竟然有些许差别😅，在我印象中，大部分编程语言里，函数和方法没有任何区别，大概的意思就是通过名字调用的一段代码，只是C&#x2F;C++中，习惯称为函数（function），Java中习惯称方法（method），而在JS中，我们知道也习惯称function，即函数。</p><p>在vue.js中，经常的一种写法就是，将函数绑定到对象上，大概就是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-attr">getMessage</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>getMessage</code>就是对象hua的一个函数，更确切的，这种<strong>绑定到对象上的函数就是方法</strong>，需要通过<code>hua.getMessage</code>或者<code>hua.getMessage()</code>去调用。ES6对于书写这种函数，推荐写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>今日学习随机</title>
    <link href="/2021/03/30/front/2.js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/03/30/front/2.js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>声明变量作用域方面，var定义的变量作用域是函数级，但是代码块里声明的var变量，代码块外又允许访问（所以var有很多不合理的地方）。let是升级版的var，用来代替var，作用域为标准的代码块级。const是代码块级作用域的常量。</li><li>var能够重复声明变量，而let和const不允许被重复声明。</li><li>并且var声明的变量存在<strong>变量提升</strong>，即在用var声明变量代码之前，函数就可以调用这个变量，默认值为undefined，而let&#x2F;const声明的变量，则会提示变量not defined（let）或者error（const）。</li></ol><h2 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h2><p>在模块化出现之前，js通过script标签直接引入另一个js，引入顺序必须固定，而维护成本高，现在主要的两种js模块化规范。</p><ul><li><p>Common JS模块化规范（nodejs）：require&#x2F;exports</p></li><li><p>ES6模块化规范：<a href="https://www.jianshu.com/p/541256d8abb3">import&#x2F;export</a>。</p></li></ul><p>export你需要导出的变量或者函数，import时需要带{}，而export default导出的变量不需要带{}。export可以导出未声明变量或者函数，export default只能导出已声明的变量、函数、或者匿名模块，一个文件中只能使用一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> name;<br><span class="hljs-keyword">export</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  data : &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br>---<br>b.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">import</span> random,&#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(random.<span class="hljs-property">data</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>在学习vue或者初次看到vue项目时，有一些疑问，比如vue组件、实例、vue文件之间的区别是什么new Vue()操作产生vue实例，组件类似于是可被Vue实例反复引用的。</p><p>vue组件是可复用的vue实例。类似于自定义标签，template属性为编写组件的必须项，props和data属性也较为常用。</p><p>注意编写vue组件时，因为html的自定义属性不能大写，会自动转化成小写，所以注册组件props中的变量，要用小写。</p><p>Vue.component()方法用于全局注册的vue组件，全局组件可以用于所有文件中的new Vue()创建的Vue根实例</p><h3 id="JS驱动vue-js"><a href="#JS驱动vue-js" class="headerlink" title="JS驱动vue.js"></a>JS驱动vue.js</h3><p>此时Vue实例用el元素直接绑定HTML。引入vue.js文件，通过js去直接驱动。用component注册全局组件，组件包含template。</p><p>template中的内容是需要有根节点的</p><h5 id="模块化驱动vue-js"><a href="#模块化驱动vue-js" class="headerlink" title="模块化驱动vue.js"></a>模块化驱动vue.js</h5><p>在js文件中可以import单Vue文件，将Vue文件渲染到的Vue实例上，挂载到指定的HTML上。一般模块化开发中我们只写一个vue根实例。</p><h5 id="单文件组件的优势"><a href="#单文件组件的优势" class="headerlink" title="单文件组件的优势"></a>单文件组件的优势</h5><p>模版语法高亮、全局定义命名不能重复、不支持CSS，而单文件的设置stype的scope属性，css只对单文件生效</p><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><ul><li>默认插槽和具名插槽</li></ul><p>将内容分发权限放到调用的父级，将复杂内容放到父级。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">--- vue 2.6之前:<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>--- vue 2.6后:<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:pre-icon</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中预设位置<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>作用域插槽</li></ul><p>让父组件访问子组件的值的一种插槽，弥补父组件无法获取到子组件变量值的情况。</p><p>（具名&#x2F;默认插槽）和（作用域插槽）是并列关系，是同时可以使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">--- 父组件从子组件中取数据，vue 2.6之前<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>--- vue 2.6后<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中slot绑定变量<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="compute、method、watch"><a href="#compute、method、watch" class="headerlink" title="compute、method、watch"></a>compute、method、watch</h5><p>计算属性能做的，watch都能做。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用npm和yarn遇到的问题</title>
    <link href="/2021/03/29/front/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/29/front/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="使用npm和yarn遇到的问题"><a href="#使用npm和yarn遇到的问题" class="headerlink" title="使用npm和yarn遇到的问题"></a>使用npm和yarn遇到的问题</h4><ol><li><p>关于包管理器npm和yarn</p><p>yarn是在npm的基础之上的包管理器，根据情况选用一个工具即可，都是去读取package.json文件，在一个项目中两者可以同时存在，但是每次构建项目后（初次npm install后），需要固定使用yarn，或者或者npm，当要切换包管理器管理项目时，需要删除node_modules文件夹。</p><p>不同版本的npm管理同一个项目，一般不会出现太大的问题，但是遇到构建问题时，也可以选择删除node_module文件夹和package-lock.json文件。</p><p>遇到一个问题，npm 7构建node旧项目时，会出现构建依赖树冲突问题。</p></li><li><p>node-sass在离线机器上的安装问题</p><p>node-sass还会绕过设置的本地仓库去GitHub去获取，获取不到时会在本地编译，本地编译在win下又依赖python和C++环境，这个问题给我整吐了，怎么也不好解决，尝试过多种方法也无济于事后，找同事在能运行的机器上，拷贝了整个项目先启动看看，后期再去解决npm install安装的问题。</p></li><li><p>vue-cli工具：vue-cli、@vue&#x2F;cli。</p><ul><li>vue init webpack demo。npm run dev</li><li>vue create demo。@vue&#x2F;cli构建的项目，会在本地加入vue-cli-serivice这样的依赖npm serve</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传下载</title>
    <link href="/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>表单上传：type为file类型的input标签<strong>和enctype&#x3D;multipart&#x2F;form-data</strong>上传数据，不做处理，是同步上传。</p></li><li><p>ajax上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#myinput&quot;</span>).<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-comment">// 这两个必写</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>($(<span class="hljs-string">&#x27;#uploadForm&#x27;</span>)[<span class="hljs-number">0</span>]),<br><span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-Servlet纯流方式-SmartUpload或Apache-FileUpload"><a href="#1-Servlet纯流方式-SmartUpload或Apache-FileUpload" class="headerlink" title="1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload"></a>1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload</h4><p>Servlet直接读区获取字节流存储在文件夹，但是无法同时区分普通控件和上传文件</p><p>在Servlet中都能实现上传文件功能简化，实现业务数据和上传的文件同时获取，并且直接write（不需要手动outputStream）</p><p><a href="https://www.jianshu.com/p/e7837435bf4c">FileUpload文件上传参考</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">// 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isMultipart</span> <span class="hljs-operator">=</span> ServletFileUpload.isMultipartContent(req);<br>  <span class="hljs-comment">// 如果不满足要求就立即结束对该请求的处理</span><br>  <span class="hljs-keyword">if</span> (!isMultipart) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// FileItem 是表单中的每一个元素的封装</span><br>    <span class="hljs-comment">// 创建一个 FileItem 的工厂类</span><br>    <span class="hljs-type">FileItemFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskFileItemFactory</span>();<br>    <span class="hljs-comment">// 创建一个文件上传处理器（装饰设计模式）</span><br>    <span class="hljs-type">ServletFileUpload</span> <span class="hljs-variable">upload</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletFileUpload</span>(factory);<br>    <span class="hljs-comment">// 解析请求</span><br>    List&lt;FileItem&gt; items = upload.parseRequest(req);<br>    <span class="hljs-keyword">for</span> (FileItem fileItem : items) &#123;<br>      <span class="hljs-comment">// 判断空间是否是普通控件</span><br>      <span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;<br>        <span class="hljs-comment">// 普通控件</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 上传控件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> fileItem.getContentType();<br>        <span class="hljs-keyword">if</span> (!contentType.startsWith(<span class="hljs-string">&quot;image/&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 实现简单的错误提示</span><br>          req.setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;亲，您上传的文件格式不正确，请重新上传！&quot;</span>);<br>          req.getRequestDispatcher(<span class="hljs-string">&quot;upload.jsp&quot;</span>).forward(req, resp);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果不是图片类型则不再对请求进行处理</span><br>        &#125;<br>        <span class="hljs-comment">// 随机命名文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + <span class="hljs-string">&quot;.&quot;</span> + FilenameUtils.getExtension(fileItem.getName());<br>        <span class="hljs-comment">// 将上传的文件保存到服务器</span><br>        fileItem.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:/&quot;</span>, fileName));<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件上传"><a href="#2-SpringMVC文件上传" class="headerlink" title="2. SpringMVC文件上传"></a>2. SpringMVC文件上传</h4><p>SpringMVC的上传功能封装了FileUpload组件的功能</p><ol><li>配置FileUpload和common-io的依赖、在SpringMVC配置文件中配置MultipartResover（上传解析器）</li><li>SpringMVC Controller：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span><br><span class="hljs-comment">// 使用MultipartFile类，String ename是其他控件信息，request用于获取绝对路径</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile img, Emp emp ,String ename, HttpServletRequest request)</span>&#123;<br><span class="hljs-comment">// img存储到文件夹相对路径(Web程序的部署路径)</span><br><span class="hljs-comment">//1. 获得上传文件的名字,方便在下载时还原这个名字（3.jpg）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> img.getOriginalFilename(); <br><span class="hljs-comment">//.当前应用程序的部署绝对路径下的upload文件夹</span><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-comment">// 判断文件夹是否存在</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br><span class="hljs-keyword">if</span>(!file.exists())&#123;<br>file.mkdir(); <br>  &#125;<br> <br>  <span class="hljs-comment">//3.应付存储文件的名字重复，为文件重命名</span><br>  <span class="hljs-comment">// 先获得文件的后缀名</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">extendsName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>); <br>  <span class="hljs-keyword">if</span>(index!=-<span class="hljs-number">1</span>)&#123;<br>  extendsName = name.substring(index); <br>  &#125;<br>  <span class="hljs-comment">// 生成唯一的名字</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extendsName; <br>  <br>  <span class="hljs-comment">//4.MultipartFile.transferTo方法代替流输入</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file,fileName);<br>  <span class="hljs-keyword">try</span> &#123;<br>    img.transferTo(savePath); <br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(); <br>  &#125;<br><span class="hljs-comment">// 5 存储数据库，这个照片是员工的属性</span><br>  <span class="hljs-comment">// 保存到相对路径</span><br>  emp.setFilePath(<span class="hljs-string">&quot;/upload/&quot;</span>+fileName); <br>  emp.setFileName(name);<br>empService.save(emp);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件下载："><a href="#文件下载：" class="headerlink" title="文件下载："></a>文件下载：</h2><p>a标签在h5的download属性可以通过URL访问到，单独的用控制器下载其实比价少用，真的用的时候可以用流下载</p><p>FormData两种方式定义，append(“myimage”, $(“#myfile”).get(0).files[0]) ）<a href="https://harttle.land/2016/07/04/jquery-file-upload.html">异步上传</a></p><p>cache、processData和contentType为false，防止JQ转码</p><h4 id="1-Servlet纯流方式"><a href="#1-Servlet纯流方式" class="headerlink" title="1. Servlet纯流方式"></a>1. Servlet纯流方式</h4><p><a href="https://www.jianshu.com/p/f450da30f594">纯流文件下载参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">String dataDirectory=req.getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/data&quot;</span>);<br><span class="hljs-comment">// 通过service查询到</span><br>File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dataDirectory, <span class="hljs-string">&quot;secret.pdf&quot;</span>);<br><span class="hljs-keyword">if</span>(file.exists())&#123;<br>  resp.setContentType(<span class="hljs-string">&quot;application/pdf&quot;</span>);<br>  resp.addHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=secret.pdf&quot;</span>);<br>  <span class="hljs-type">byte</span>[] buffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>  FileInputStream fis=<span class="hljs-literal">null</span>;<br>  BufferedInputStream bis=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span>&#123;  <br>    <span class="hljs-comment">// BufferInputStream每次读一块字节相比读一个字节对于文件速度更快。</span><br>    fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>    bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    <span class="hljs-type">int</span> i=bis.read(buffer);<br>    <span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>      os.write(buffer,<span class="hljs-number">0</span>,i);<br>      i=bis.read(buffer);<br>    &#125;<br>  &#125;<span class="hljs-keyword">catch</span>(IOException ioe)&#123;<br>    System.out.println(ioe.toString());<br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-keyword">if</span>(bis!=<span class="hljs-literal">null</span>)&#123;<br>      bis.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fis!=<span class="hljs-literal">null</span>)&#123;<br>      fis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件下载"><a href="#2-SpringMVC文件下载" class="headerlink" title="2. SpringMVC文件下载"></a>2. SpringMVC文件下载</h4><p> 使用spirng 自带的<strong>ResponseEntity</strong>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException&#123;<br>  <span class="hljs-comment">//获取你文件的文件夹，一般从数据库读区，这里模拟service已经取到路径</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getSession().getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1168701023208865792.jpg&quot;</span>; <br>  <span class="hljs-comment">// 1. 获取文件路径</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path,filename); <br>  <span class="hljs-comment">//设置header里的ContentDisposition字段，以attachment(下载框方式)打开图</span><br>  <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>(); <br>  headers.setContentDispositionFormData(<span class="hljs-string">&quot;attachment&quot;</span>, downloadFielName);<br>  <span class="hljs-comment">// 2. ResponseEntity返回，返回application/octet-stream : 二进制流数据(最常见的文件下载)。</span><br>  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-type">byte</span>[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/10/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/2.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/10/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/2.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>^a以a开始</p><p>a$以a结束</p><h4 id="字符代表符号（匹配符）"><a href="#字符代表符号（匹配符）" class="headerlink" title="字符代表符号（匹配符）"></a>字符代表符号（匹配符）</h4><p>[a-z]小写字母、[a-zA-Z0-9]字母和数字</p><p>. 除换行符以外的任意单字符</p><p>\d数字。</p><p>\D非数字</p><p>\w数字，字母或下划线</p><p>\s特殊字符</p><h4 id="数量限定符"><a href="#数量限定符" class="headerlink" title="数量限定符"></a>数量限定符</h4><p>{5}： 前面的一个字符出现5次{1,}：1次以上。{1,3}：1次到3次</p><p>*前面的一个字符出现0次以上</p><p>+前面的一个字符出现1次以上</p><p>？前面的一个字符出现0次或1次</p><h3 id="前瞻和后顾"><a href="#前瞻和后顾" class="headerlink" title="前瞻和后顾"></a>前瞻和后顾</h3><p>正则表达的前后，还未解析字符的称为前面，解析过的称为后面</p><p>a(?&#x3D;b)前瞻，匹配a，且a必须在b的前面</p><p>a(?!b)负前瞻，匹配a，且a的前面不是b</p><p>(?&lt;&#x3D;b)a后顾，匹配a，且a的后面b</p><p>(?&lt;!b)a负后顾，匹配a，且a的后面不是b</p><p>|分成两段，或者</p><p>()圈定一个子串</p><h2 id="JS使用正则表达式"><a href="#JS使用正则表达式" class="headerlink" title="JS使用正则表达式"></a>JS使用正则表达式</h2><p><strong>var regexp &#x3D; &#x2F;正则表达式&#x2F;修饰符</strong>，</p><p>修饰符有i（不区分大小写）和g（全局匹配）</p><p><strong>匹配：regexp.test(str)</strong></p><h2 id="Java使用正则表达式"><a href="#Java使用正则表达式" class="headerlink" title="Java使用正则表达式"></a>Java使用正则表达式</h2><p>Pattern.complile(“”)创建正则对象</p><ul><li><p>匹配验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^[0-9a-zA-Z]\\.&#123;5,10&#125;@[0-9a-zA-z]&#123;2,7&#125;(\\.com|.cn)&quot;</span>)<br>p.matcher(str).matches() <span class="hljs-comment">//Match对象</span><br></code></pre></td></tr></table></figure></li><li><p>以一个正则表达式拆分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br>String[ ] s = p.split(str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>  System.out.print(s[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>  结果为ABCDEF<br></code></pre></td></tr></table></figure></li><li><p>替换里面的字符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(str);<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> m.replaceAll(<span class="hljs-string">&quot;-&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本编码</title>
    <link href="/2020/10/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/1.%E7%BC%96%E7%A0%81/"/>
    <url>/2020/10/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/1.%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>通常所说的乱码问题，是指文本文件乱码（非二进制文件），文本乱码的本质是解析的字符编码与文本本身字符编码不匹配导致的。</p><h2 id="1-字符集和字符编码"><a href="#1-字符集和字符编码" class="headerlink" title="1. 字符集和字符编码"></a>1. 字符集和字符编码</h2><ol><li><p>文本文件：通过字符编码（如UTF-8）保存的文件，如数字64，文本文件会将64解析成’6’和’4’两个字符，再根据字符集编码，再存储到硬盘中</p></li><li><p>二进制文件（狭义上的非文本文件）：保留数据本身二进制的文件，数字64，如Java的int型数字64，直接储存64的二进制到硬盘中</p></li></ol><p>字符集规定了字符在字符表的位置，在文本文件的存储过程中，文本会依靠字符集规则转化成字符，其中最著名的就是ASCII字符集和Unicode字符集。</p><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>ASCII既是世界上第一个字符集（charset），同时又规定了字符编码（encoding）。</p><p>ASCII字符编码用一个字节（7位容器）来表示一个字符，ASCII中一共有127个字符（0-126）。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>地球上字符太多，ASCII字符集的单字节无法表示，所以出现了Unicode字符集。最初时UTF-16编码来实现Unicode字符集，用2个或4个字节来保存。</p><ul><li><p>UTF-16：用两个或者四个字节（<strong>Java char类型用的2字节的UTF-16 LE</strong>），四字节称为UTF-16 BE</p></li><li><p>UTF-32：用四个字节</p></li><li><p>UTF-8：1～4个字节，1个字节时与ASCII编码相同，常见<strong>汉字一般3字节</strong></p></li></ul><h3 id="ISO-8859-1-（Latin-1）"><a href="#ISO-8859-1-（Latin-1）" class="headerlink" title="ISO-8859-1 （Latin 1）"></a>ISO-8859-1 （Latin 1）</h3><p>同样是ASCII码的超集，用一个字节（8位容器）实现255节。在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。mysql默认就采用他</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>一般汉字2字节。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html">Java中存在的编码问题</a></p><h2 id="2-Content-Type与前后编解码"><a href="#2-Content-Type与前后编解码" class="headerlink" title="2. Content-Type与前后编解码"></a>2. Content-Type与前后编解码</h2><p>开发过程中，设定HTTP请求和返回报文中的Content-Type是保证文本不乱码正常解析的最重要保障。</p><h3 id="浏览器解码顺序："><a href="#浏览器解码顺序：" class="headerlink" title="浏览器解码顺序："></a>浏览器解码顺序：</h3><ol><li><p>根据服务器返回的Content-Type中指定的编码解码。</p></li><li><p>根据meta标签的charset。</p></li><li><p>根据浏览器设定的编码解码（跟随浏览器设定，一般中文系统为GBK）</p></li></ol><h3 id="浏览器编码顺序和Content-Type："><a href="#浏览器编码顺序和Content-Type：" class="headerlink" title="浏览器编码顺序和Content-Type："></a>浏览器编码顺序和Content-Type：</h3><ul><li><p>POST请求的编码：默认UTF-8，<strong>ajax请求强制数据为UTF-8编码，即使在contentType中设置的编码也不生效</strong>，所以对于发送ajax请求，直接写application&#x2F;json，然后设置服务器对所有请求数据使用UTF-8解析：request.setCharactorEncoding(“UTF-8”)。</p><ul><li><p>Ajax POST默认contentType: application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8。</p></li><li><p>form POST默认的contentType: application&#x2F;x-www-form-urlencoded</p><p><strong>form POST的编码也是UTF-8，但是不会在Content-Type中声明</strong></p></li></ul></li><li><p>GET请求的编码：默认UTF-8（不指定Content-Type，一般传输不了中文）</p></li></ul><h3 id="服务器解码顺序："><a href="#服务器解码顺序：" class="headerlink" title="服务器解码顺序："></a>服务器解码顺序：</h3><ol><li><p>使用requst.setCharactorEncoding( )指定的编码解码。</p></li><li><p>根据客户端发送的Content-Type中的编码解码。</p></li><li><p>使用默认的UTF-8解码</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 设置Content-Type作用与于GET请求<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">useBodyEncodingForURI</span> = <span class="hljs-string">&quot;true&quot;</span> &gt;</span> <br> // 设置GET请求使用UTF-8解码, Tomcat 8以后这个默认值已经是UTF-8，<br> // 注意：request.setCharactorEncoding对GET请求不生效。<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">URIEncoding</span> =<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span> <br></code></pre></td></tr></table></figure><h3 id="服务器编码顺序和Content-Type："><a href="#服务器编码顺序和Content-Type：" class="headerlink" title="服务器编码顺序和Content-Type："></a>服务器编码顺序和Content-Type：</h3><ol><li><p>response.setContentType(“application&#x2F;json; charset&#x3D;UTF-8”)，respnse.setCharactorEncoding()</p></li><li><p>Servlet response的默认编码是UTF-8</p></li><li><p>JSP会默认Content-Type：</p><p>JSP的编码只受到Page指令的contentType&#x2F;pageEncoding命令约束，而且这两个命令对于JSP生成的Content-Type决定权最高。</p><p>response.setCharactorEncoding方法：设置返回数据的编码</p><p>response.setContentType方法：设置Servlet返回数据的编码和返回数据的Content-Type。<strong>setContentType方法优先级最高</strong>，在此方法前后出现setCharactorEncoding()，数据会按照Content-Type编码。</p></li></ol><ul><li>注解设置注解设置：@RequestMapping(value &#x3D; “”, <strong>produces&#x3D;”application&#x2F;json;charset&#x3D;UTF-8”</strong>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乱码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
