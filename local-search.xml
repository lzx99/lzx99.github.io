<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java中的多线程</title>
    <link href="/2023/12/19/Java/%E6%96%B0blog/6.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/12/19/Java/%E6%96%B0blog/6.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h4 id="1-创建线程的基础方式"><a href="#1-创建线程的基础方式" class="headerlink" title="1. 创建线程的基础方式"></a>1. 创建线程的基础方式</h4><p>一般情况下，需要通过创建Thread对象，并调用Thread对象的start()方法来创建一个线程。也就是说我们的目标就是得到一个有执行代码的Thread实例，那执行线程代码的任务放在哪里呢？</p><ul><li>第一种就是任务类继承Thread类并重写run方法，然后使用Thread类的无参构造方法得到实例化Thread对象；</li><li>另一种形式就是任务类实现Runnable接口或者Callnable接口重写run()，然后将Runnable对象或者Callnable对象传入Thread的有参构造方法得到实例化Thread</li></ul><h4 id="2-线程池来管理线程"><a href="#2-线程池来管理线程" class="headerlink" title="2. 线程池来管理线程"></a>2. 线程池来管理线程</h4><p>写的啥啊？我这是？每次看自己的笔记都感觉看不明白，还不如看别人的笔记。都是些名词性的注解和简写</p><p>为什么我们有时候会通过线程池来创建线程呢？对于那种频繁执行的任务，不断创建和销毁线程是极大的开销，所以我们就创建线程池来管理线程，Java中你要使用线程池，基本就要创建<strong>ExecuterService</strong>的实例，ExecuterService是Java中所有线程池的基类，创建实例以后，调用<code>execute(Runnable runnable)</code>和<code>submit(Callnable callnable)</code>创建1个线程任务，execute()不会有返回值，适合调用没有返回值的任务，而submit()返回一个Future&lt;T&gt;对象，可以用来异步获取“子线程“任务执行的结果。<br>具体创建ExecuterService的执行类有两种方式：</p><ol><li>使用Executors静态工厂方法：使用Executors静态工厂创建线程池很简单，不需要像构造方法指定太多的参数，<ul><li>newCachedThreadPool()：会优先复用之前执行的线程，不是一种单例的形式</li><li>newFixedThreadPool(int number)：指定多少的线程数量</li><li>newSingleThreadPool()：单例线程，依次执行</li><li>newScheduledThreadPool()：使用独有的<code>executor.schedule(worker, 10, TimeUnit.SECONDS)</code>，可以定时或者延迟执行任务</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);  <br>Future&lt;Integer&gt; future = executorService.submit( ()-&gt;&#123;  <br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;  <br>        sum=sum+i;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> sum;  <br>        &#125;);  <br>System.out.println(future.get());  <br>executorService.shutdown();  <br></code></pre></td></tr></table></figure><ol start="2"><li>但是由于Executors创建出来的线程池都是<strong>无界队列</strong>，啥意思呢，就是如果提交的任务越来越多，如果线程消费的速度很慢，这些任务就会形成很长的队列保存在Java内存中，容易OOM，所以开发规范上是更推荐使用带参数的<strong>线程池类的构造方法</strong>，即使用线程池实现类 <strong>ThreadPoolExecutor</strong> 和 <strong>ScheduledThreadPoolExecutor</strong> 的构造方法，后者继承自前者，在构造方法中指定queenCapacity参数，指定队列的容量，另外<br> 构造方法参数的解释：当线程池中的线程数量少于corePoolSize时，线程池会为每个新提交的任务创建一个新线程，无论是否有空闲线程；corePoolSize数量的线程会保留不会销毁，corePoolSize数量的线程全部在执行时，新任务会进入任务队列，CorePoolSize的线程有空闲时从任务队列获取任务，只有当任务队列queueCapicity也满了，开始创建新线程，直至达到maximumPoolSize               <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>; <span class="hljs-comment">// 核心线程数 </span><br><span class="hljs-type">int</span> <span class="hljs-variable">maxPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 最大线程数 </span><br><span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>; <span class="hljs-comment">// 线程的最大空闲时间 </span><br><span class="hljs-type">TimeUnit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS; <span class="hljs-comment">// </span><br>keepAliveTime的时间单位 <span class="hljs-type">int</span> <span class="hljs-variable">queueCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 任务队列容量 </span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>( corePoolSize, maxPoolSize, keepAliveTime, unit, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(queueCapacity) );<br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://mp.weixin.qq.com/s/q0Qt-ha9ps12c15KMW7NfA">线程池实现原理</a></p><h4 id="3-关于线程小TIPS"><a href="#3-关于线程小TIPS" class="headerlink" title="3. 关于线程小TIPS"></a>3. 关于线程小TIPS</h4><ul><li>Java中没有严格的父子线程，因为传统意义上的子线程与父线程是绑定的，父线程销毁，子线程也会销毁；而Java中，当一个线程中启动另一个线程（子线程），这些线程都变成了Java中独立线程</li><li>守护线程：通过<code>t.setDaemon(true)</code>设置守护线程，守护线程将会在所有用户线程结束后被JVM强制关闭，所以应用在一些循环运行且与主任务伴随的线程，如日志线程、垃圾回收线程就是守护线程，从业务设计上来说，主任务没了守护线程也没了意义。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li><p>新建：new出来实例，没有start()</p></li><li><p>可运行：正在执行run中的代码</p></li><li><p>终止 ：run方法执行完毕</p></li><li><p>阻塞：注意IO阻塞方法，其实线程是进入了一种类似“等待”的状态，与线程的“阻塞”状态是没有关系的，线程阻塞，或者说<strong>线程的阻塞状态，是多线程状态下锁竞争产生的</strong>，没拿到锁的就进入阻塞状态</p></li><li><p>等待：通过wait()、t.join()的方法进入 。协助</p></li><li><p>超时等待：this.wait(long)、t.join(long)、Thread.sleep(long)</p></li></ul><h4 id="线程状态相关的方法"><a href="#线程状态相关的方法" class="headerlink" title="线程状态相关的方法"></a>线程状态相关的方法</h4><ol><li>t.join()，对子线程t使用，当前线程进入等待状态，直到t线程完成。比如等待某个异步任务执行完，要注意对子线程join()时，当前线程不能被其他线程interrupt()中断，会报异常。</li><li>Thread.sleep(long)，是一个静态方法，当前线程会在等待设定的时长后再继续执行，应用在模拟延迟，限制速率。<strong>sleep过程中不会释放锁</strong></li><li>tihs.wait()搭配notifyAll()和notify()，是一种条件等待机制，应用于<strong>线程间的通讯和协调</strong>，当一个线程需要等待另一个线程完成某些任务时，通过这三个方法来协调通讯，例如生产者-消费者模型。<br>他们是Object类的一个native方法，首先，这三个方法需要<strong>用在synchronized代码内</strong>，不能用于ReentranLock等，其次必须要在已拿到锁的对象上调用这三个方法，例如你拿到的锁对象是this，就使用this.wait()调用，拿到的是lock，就用lock.wait()调用。<br>生产者消费者模型距离，消费者线程拿到this锁，进入获取资源的方法时，要判断资源不为空才去poll()消费资源，如果资源为空我们应该wait()等待生产者线程生产，<strong>wait()会释放消费者持有的锁</strong>，让生产者拿到锁去生产，生产完成后this.notifyAll()，唤醒处于this.wait()状态下的所有线程，所有进入阻塞状态争夺锁，拿到锁的线程会接着执行this.wait()后面的代码。<br>要注意的是，生产者判断资源为空进入wait()需要使用while而不是if，因为拿到锁以后，仍然需要再次判断资源是否为空，其他没有拿到锁的线程，不需要再次唤醒，而是已经进入主动争夺锁的阻塞状态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(resource.isEmpty())&#123;<br>  <span class="hljs-built_in">this</span>.wait();<br>&#125;<br>resource.poll();<br></code></pre></td></tr></table></figure><h2 id="同步和异步、阻塞与非阻塞"><a href="#同步和异步、阻塞与非阻塞" class="headerlink" title="同步和异步、阻塞与非阻塞"></a>同步和异步、阻塞与非阻塞</h2><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>编程本就是同步性质的，加入一些异步编程，面对并发进行一些“同步处理”。</p><p>同步，是一个由上到下执行的概念，<strong>强调必须要拿到最终结果，才执行下一步</strong>，必须顺序执行，这符合我们人思考的逻辑，先操作什么，得到什么结果，最后进行什么操作。<br>我们编写的代码本身就是同步的，那为什么我们还常常听说到<strong>线程同步</strong>这个概念呢？因为多线程的并发执行，可能会出现资源竞争等一些不符合我们原本同步逻辑下的线程安全问题，这时候我们要加入一些“同步机制”，如<strong>同步方法</strong>，目的就是让多个线程之间“同步”执行，保证线程安全，让并发的进程一个接一个的同步执行。要注意的是，同步方法的对立面并不是异步方法，例如没有synchronize关键字的方法，应该称为“非同步方法”而不是异步方法，我们常常描述的异步方法，和异步编程或异步调用是一个概念。</p><p>异步，对于是否顺序执行的要求不严格，一些执行时间比较长的任务，在不影响业务逻辑的情况下，我们可以考虑采取异步编程，<strong>异步任务先直接返回，让主程序接着往下执行</strong>，异步任务与主程序同时执行，当异步任务执行完了，后续异步任务<strong>通知或者回调主程序</strong>，再进行下一步应该的操作。例如我们在Java开发中，一些外部接口调用中使用“异步调用”，例如异步方式调用外部接口发短信；Java底层也有部分异步API，如Future、CompletableFuture等实现内部代码的异步编程。<br>多线程如果同时执行多个相同任务，这种形式就不能够称异步，可以称为并行或者并发，异步概念强调主程序与异步任务之间存在因果关联性的并行执行关系。当主程序开启子线程，这个时候可以称为是<strong>异步编程</strong>，一般会搭配Future和CompletableFuture等处理。</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞，不同的场景下有不同的解释，第一种，用于描述线程时，“阻塞”是Java线程的6种状态之一，例如多线程资源竞争时，如果设置了“同步方法”，没拿到锁的线程就会进入阻塞状态；第二种，描述IO时，可以描述阻塞式IO和非阻塞IO，这是POSIX规定的5种IO模型之二，阻塞型IO，如inputStream中的read方法，read()在没有结束或者关流之前，会让调用IO的程序线程中断的现象，通常称为IO阻塞，但是IO阻塞没有让线程进入“阻塞”状态，阻塞时多线程竞争时的概念，IO阻塞或者说阻塞方法，强调的是在当前线程中，有任务耗时比较长，而我们说过，一般的代码是同步的，就会导致当前线程中断，不去执行任务。第三种，阻塞方法，如serversocket.accpet()，阻塞方法也是针对当前线程的的概念，强调耗时长，或需要等待特定条件才能往下走，也要时刻注意，阻塞方法也没有让线程进入阻塞状态，是让当前线程进入了类似“等待的状态”。</p><p>同步&#x2F;异步，关注通知机制，关注；阻塞，关注任务本身</p><h2 id="线程的同步处理"><a href="#线程的同步处理" class="headerlink" title="线程的同步处理"></a>线程的同步处理</h2><h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><p>一段代码的多线程执行，有线程安全问题，我可以使用锁，同步这段代码，保证线程安全；两段代码之间有线程安全的竞争关系，可以给两段代码设置相同的锁，来保证安全全。</p><p>没有申明做了线程安全处理的，我们都默认他线程不安全。但也有部分很明显线程安全类，如没有成员变量的类，或类里所有的成员变量都是final修饰的基本数据类型或String类型，这两种类是线程安全的。</p><p>被synchronized修饰的同步方法，相当于方法内的所有代码被synchronized(this){}封装，也就是锁是this当前对象实例，而静态同步方法锁是类Class实例。</p><p><strong>公平锁和非公平锁：</strong></p><ul><li>Java的锁一般默认都为非公平锁，线程自由竞争随机获取锁</li><li>公平锁是线程获得锁的顺序，按照请求顺序获得，在ReentrantLock和ReetrantReadWriteLock的构造方法传入true打开</li></ul><p><strong>乐观锁和悲观锁：</strong></p><ul><li>悲观锁，假设其他事务会修改数据，执行代码前必须要先获得锁，认为资源的竞争关系比较强烈。</li><li>乐观锁，通常其他事务不会修改数据，默认不设置锁，当完成操作以后，看版本号有没有改变，如果有改变再rollback重试，没有改变就提交。对于那种读非常多，写比较少的情况下，用乐观锁是非常合适的</li></ul><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>Java的单条语句中，实际上只有基本数据类型和引用数据类型的<strong>赋值</strong>是真正的原子操作 ，就算时sum&#x3D;i+1这种简单语句都不是原子的。</p><p>首先说一下<strong>共享变量</strong>，多线程的共享变量是位于堆上或者说主内存上的，也就是对象的成员变量或者静态类型数据，存储在栈也就是工作内存上的，只有局部变量，这无法作为共享资源被多个线程操作，共享变量存储在主内存上，多线程操作共享变量就多了一个流程，都需要从主内存取值，复制到工作内存的过程，显而易见，在多线程下是不安全的。</p><p>volatile关键字第一个<strong>解决了共享变量的可见性</strong>问题，保证当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值，主要是解决如count&#x3D;3这种问题；第二个<strong>防止了编译时和运行时发生指令重排</strong>，这称为volatile的有序性。</p><p>volatile也只能保证在多线程模型下，获取共享变量值是没有问题的，但是对于非共享变量，以及无法保证复合操作的原子性，volatile的线程同步特性有限。如我们对共享变量n用volatile关键字修饰，连基本的n&#x3D;n+1和n++，volatile也是无法保证原子性的，因为他们本身就是复合操作。</p><h4 id="1-synchronized-内置锁"><a href="#1-synchronized-内置锁" class="headerlink" title="1. synchronized 内置锁"></a>1. synchronized 内置锁</h4><p>这是Java提供最原始的锁机制，同步代码块或者同步方法，是一种可重入锁，也就是同一个线程能多次获取同一个锁的机制，可重入锁可以避免递归调用不会导致死锁；经过优化后synchronized也没有这种“重”了，对系统的开销没有那么大了。</p><h4 id="2-ReentrantLock（1-5）显示锁"><a href="#2-ReentrantLock（1-5）显示锁" class="headerlink" title="2. ReentrantLock（1.5）显示锁"></a>2. ReentrantLock（1.5）显示锁</h4><p>ReentrantLock也是Java早期提供的锁机制，相比于synchronized锁更加轻量和灵活，代码中使用<code>lock()</code>，线程就等于拿到lock对象锁，使用这种形式的锁一定要注意，用try-finally代码块的形式保证<code>lock.unlock()</code>的执行，搭配条件变量 <strong>Condition</strong> 的<code>await()</code>和<code>signalAll()</code>也可以起到synchronized配合wait()和notify()的作用。</p><p>ReentrantLock相比传统synchronized，还提供了一种尝试获取锁的机制，<code>lock.tryLock(1, TimeUnit.SECONDS)</code>方法，尝试获取锁，支持在设定时间后放弃锁的争夺，做其他的处理，这可以根据业务情况看需不需要这样做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(String s)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            queue.add(s);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                condition.await();<br>            &#125;<br>            <span class="hljs-keyword">return</span> queue.remove();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-ReadWriteLock（1-5）读写锁"><a href="#3-ReadWriteLock（1-5）读写锁" class="headerlink" title="3. ReadWriteLock（1.5）读写锁"></a>3. ReadWriteLock（1.5）读写锁</h4><p>包含读锁和写锁两种锁，读锁可以被多个线程持有，写锁和普通锁一样只能被一个线程拿到，但是读锁和写锁之间存在锁竞争关系，持有读锁需要等待写锁释放，持有写锁需要等待所有读锁释放，而且由于读锁之间没有竞争关系，可能写锁一直无法全部释放，陷入“写线程饥饿”，所以适用于读远大于写的情况。</p><p>有一种解决方案是使用<strong>公平锁模式</strong>，构造方法参数使用true打开，公平锁就是按照锁的请求顺序分配锁，请求写锁线程先过来，后续请求读锁线程会先阻塞，等待现有的读锁线程释放所有读锁，这防止了“写线程饥饿”，但降低了读锁的并发性能，因为意味着读锁也要按顺序分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>(<span class="hljs-literal">true</span>); <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">rlock</span> <span class="hljs-operator">=</span> rwlock.readLock();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">wlock</span> <span class="hljs-operator">=</span> rwlock.writeLock();<br></code></pre></td></tr></table></figure><h4 id="4-StampedLock（Java-8）乐观锁机制"><a href="#4-StampedLock（Java-8）乐观锁机制" class="headerlink" title="4. StampedLock（Java 8）乐观锁机制"></a>4. StampedLock（Java 8）乐观锁机制</h4><p>乐观锁可以进一步提升读的并发性能，Java中StampedLock除了支持悲观读锁和悲观写锁，还支持了乐观读锁的机制。但是要注意和ReentrantLock不同，StampedLock的读写锁不支持重入，不支持条件变量Condition，实现线程间的通信。</p><p>传统悲观锁中，读写一定不能并行执行，而乐观锁的读和写可以并发执行，因为乐观锁不是传统意义上一种实际的锁，本质是没有加锁的，而是提供了一种校验机制，校验当前读锁代表的共享资源，在读操作开始后，有没有被“写操作”，减少了锁的开销，适用于读远大于写的场景。<br>通过writeLock()方法，上写锁的同时，获得一个事件戳；可以应用在进行<code>validate(stamp)</code>校验，也就是通过<code>tryOptimisticRead()</code>乐观读锁获取的时间戳，会和悲观写锁获得的时间戳进行比较，通过这种校验，达到乐观锁的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.StampedLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-comment">// 修改 x 和 y 坐标的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算到原点的距离</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead(); <span class="hljs-comment">// 尝试获取乐观读锁</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="hljs-comment">// 检查乐观读锁是否有效</span><br>            stamp = stampedLock.readLock(); <span class="hljs-comment">// 如果无效，获取悲观读锁</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br>&#125;```<br><br>#### <span class="hljs-number">5.</span> Semaphore 信号量<br><br>Semaphore 信号量，不像之前说过的传统悲观锁，更像一种限流机制，他的目的不是确保线程间的同步，而是限制对共享资源访问的线程连接数量，如数据库连接，他可以最多可以允许设定数量的线程并发执行，比线程池还要轻量一些。<br><br>```java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 3个许可</span><br>semaphore.acquire(); <span class="hljs-comment">// 请求许可</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 访问共享资源</span><br>    System.out.println(<span class="hljs-string">&quot;Accessing shared resource...&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    semaphore.release(); <span class="hljs-comment">// 释放许可</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-Atomic包中的类"><a href="#6-Atomic包中的类" class="headerlink" title="6. Atomic包中的类"></a>6. Atomic包中的类</h4><p>Java中一般的复合操作，例如count++都是线程不安全的，可以用Atomic中的包，实现count++这类复合操作，变成原子操作，可以用来代替，多线程下，基本数据类型和引用数据类型进行部分原子性操作，比如在AtomicInteger代替int类型数据进行线程安全的数学运算，比如其中的incremnetAndGet()实现count++。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的网络编程</title>
    <link href="/2023/12/18/Java/%E6%96%B0blog/5.Java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/12/18/Java/%E6%96%B0blog/5.Java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在计算机网络中，IP协议是网络层， 用于数据转发，路由器就是工作在这一层，网络层可以说是与IP相关的，我们使用<code>ping</code>命令的时候，就是工作在这一层；TCP协议是传输层的一种协议，用于建立数据连接、保证传输可靠性，传输层其实就是一个关于端口的通信连接协议，所以我们如果要看服务器的端口是否正常，这个时候我们应该使用<code>telnet</code>命令。</p><p>程序实现数据通信的核心是建立了TCP连接，无论哪种编程语言都是去调用操作系统的Socket建立，而在Java中，用Socket API封装了操作系统套接字以快速建立TCP请求，底层调用了<code>native socket0()</code>创建操作系统套接字；这些Java网络API提供了一系列方便的方法来创建和管理TCP网络连接，封装了底层TCP&#x2F;UDP网络细节，使得网络编程变得更加容易和高效。我们在Socket API上的编程，其实就是应用层编程了，你在TCP报文中所传输的内容就相当于应用层报文，当你制定一个的报文传输和解析的标准与服务，就应用层协议。</p><p>TCP的报文头包含源端口、目标端口、ACK和检验和等等，设计复杂而且与上层应用相关度低，报文的设计为了保障报文传输的安全和可靠，HTTP报文就是TCP报文的正文部分，具体在Java API中的体现就是，Java Socket的inputstream()是TCP的数据报文，或者说TCP报文的正文部分，即应用层报文的全部内容；而HttpURLConnection中的inputstream是HTTP报文的正文部分。</p><p>Tomcat服务器或者说应用层服务器做了什么呢？第一当然是接收TCP请求；第二解析应用层报文；第三提供一组API，让用户方便的获取报文的某个部分，组装报文发送。</p><h4 id="TCP-UDP编程"><a href="#TCP-UDP编程" class="headerlink" title="TCP&#x2F;UDP编程"></a>TCP&#x2F;UDP编程</h4><p>TCP&#x2F;UDP即<strong>传输控制协议</strong>和<strong>用户数据报协议</strong><br>互联网建立在<strong>TCP&#x2F;IP</strong>协议族（包含TCP、IP、UDP、ICMP等协议）基础上，<a href="https://blog.csdn.net/qq_26816591/article/details/53022183">网络报文图</a>，路由器只工作在网络层，只处理IP数据报的分发；<a href="https://zhuanlan.zhihu.com/p/53374516">TCP协议</a>通过三次握手建立连接，四次挥手关闭连接。TCP和UDP是两套端口，在TCP连接的建立过程中，客户端（本地浏览器）和服务器端（HTTPS网站）都需要分配一个端口。服务器端通常使用预定义的端口（在HTTPS的情况下是端口443），而客户端则使用一个临时的、动态分配的端口。</p><p>Java TCP&#x2F;UDP编程 API：<code>ServerSocket、Socket</code>；<code>DatagramSocket、DataGramPacket</code></p><p>TCP编程使用<strong>流</strong>来处理数据，因为它提供了可靠的、有序的数据传输，当客户端<code>new Socket(host, port)</code>时，就建立TCP连接，服务器每<code>serversocket.accpet()</code>到一个新连接，就会开启一个线程，处理socket。而<strong>UDP不使用流</strong>，因为它是基于独立数据包的无连接通信，datagramsocket.send()和receive()方法直接实现用户数据报的收发。</p><h4 id="HTTP客户端的使用"><a href="#HTTP客户端的使用" class="headerlink" title="HTTP客户端的使用"></a>HTTP客户端的使用</h4><p>HTTP是建立在TCP基础上应用层协议，HTTP的端口实际就是指的TCP端口，HTTP报文由<strong>起始行、头部、正文</strong>三部分组成，然后头部和正文之间有空行，请求报文的起始行教请求行，响应报文的起始行叫状态行，常用的头比如Cache-Control、Content-Type、Accept、Cookie、Authorization等</p><p>请求报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br></code></pre></td></tr></table></figure><p>响应报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br></code></pre></td></tr></table></figure><p>HTTP的特性：</p><ol><li><strong>无连接</strong>；即请求时连接，返回响应就释放连接。多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消。</li><li><strong>无状态</strong>：每个HTTP请求是独立的，服务器不会记住之前的请求和响应的状态。所以用<strong>Cookie和Session</strong>来模拟状态信息。</li></ol><p>GET请求参数放在URL中，这部分参数也称params，如果参数是中文，中文字符要编码成UTF-8的字节码，Java中使用<code>URLEncoder.encode(keyword, &quot;UTF-8&quot;)</code>，POST请求：post请求的参数放在报文体中</p><p><code>URL</code>和<code>HttpUrlConnection</code>是Java的HTTP客户端编程传统API，实现了使用HTTP协议的诸多特性，而服务器端HTTP编程是编写Web服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLPostExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">urlString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;<br><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(urlString);<br>        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>        <span class="hljs-comment">// 设置请求方法为POST</span><br>        connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>        <span class="hljs-comment">// 设置请求头内容类型为JSON</span><br>        connection.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json; utf-8&quot;</span>);<br>        <span class="hljs-comment">// 设置请求头接受内容类型为JSON</span><br>        connection.setRequestProperty(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>        <span class="hljs-comment">// 允许输出，以便可以发送请求正文</span><br>        connection.setDoOutput(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 创建请求正文</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonInputString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;title\&quot;: \&quot;Sample Post\&quot;, \&quot;body\&quot;: \&quot;This is a sample post.\&quot;, \&quot;userId\&quot;: 1&#125;&quot;</span>;<br><br>        <span class="hljs-comment">// 将请求正文写入输出流</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> connection.getOutputStream()) &#123;<br>            <span class="hljs-type">byte</span>[] input = jsonInputString.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>            outputStream.write(input, <span class="hljs-number">0</span>, input.length);<br>        &#125;<br><br>        <span class="hljs-comment">// 读取响应状态码</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">responseCode</span> <span class="hljs-operator">=</span> connection.getResponseCode();<br>        System.out.println(<span class="hljs-string">&quot;Response code: &quot;</span> + responseCode);<br><br>        <span class="hljs-comment">// 如果响应状态码为201（HTTP_CREATED），则读取响应内容</span><br>        <span class="hljs-keyword">if</span> (responseCode == HttpURLConnection.HTTP_CREATED) &#123;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(connection.getInputStream()));<br>            String line;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">responseContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                responseContent.append(line);<br>            &#125;<br><br>            reader.close();<br><br>            System.out.println(<span class="hljs-string">&quot;Response content: &quot;</span> + responseContent.toString());<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭连接</span><br>        connection.disconnect();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 11引如了 <code>HttpClient</code> API，基于NIO实现，所以相比基于传统IO实现的HttpURLConnection，HttpClient具有更好的性能和更丰富的功能，如支持HTTP&#x2F;2、自动管理连接池和响应式流等。</p><h4 id="邮件协议（SMTP）"><a href="#邮件协议（SMTP）" class="headerlink" title="邮件协议（SMTP）"></a>邮件协议（SMTP）</h4><p>邮件客户端MUA（Main User Agent）通过<strong>SMTP</strong>协议与自己邮件系统的MTA服务器（Mail Transfer Agent）交互，MTA是SMTP服务器，MTA继续通过SMTP协议传输至收件系统的MTA。</p><p>进入收件人邮件系统后，MTA服务器先投递给MDA服务器（Mail Deliver Agent），MDA将邮件存储到用户的“Mail Box”中，有专门的<strong>IMAP</strong>或<strong>POP3</strong>收件服务器，与收件人邮件客户端直接交互。</p><p>![[邮件协议.png|500]]<br>javax.mail实现了MUA客户端的功能，能够实现收发邮件</p><h4 id="NIO和AIO和操作系统IO模型"><a href="#NIO和AIO和操作系统IO模型" class="headerlink" title="NIO和AIO和操作系统IO模型"></a>NIO和AIO和操作系统IO模型</h4><p>传统TCP编程Socket基于IO流进行数据传输，IO流读写操作是阻塞的，传统IO的read方法，会先让数据在内核缓冲区完全就绪，然后在Memory Copy到Java内存中，整个过程可能随着read的数据大，而导致阻塞时间过长。</p><p>例如，在单线程BIO Socket服务器中，如果客户端数据很大，或者客户端没有关流，这样read或者write过程，网络可能占据更长的耗时，而操作系统进行真正IO的时间其实很少，线程阻塞时间长，其他客户端暂时无法与服务器建立TCP连接。BIO下，如果要实现1个服务器同时处理多个客户端数据，只能增加线程数提高响应性能，这种模式成为<strong>thread-based architecture</strong>。</p><p>NIO（New IO）是从Java 1.4开始的一种<strong>非阻塞IO</strong> API和网络API，相当于传统IO流和传统Socket API的进化版本，应对<strong>高并发</strong>的网络编程出现的，是<strong>事件驱动架构</strong>（event-driven architecture），在API使用上的体现是，Selector去监听系统事件。NIO事件驱动的实现基于操作系统多路复用API（如epoll等），可以在操作系统层面注册四种事件，connect、accept、read、write，如读事件和写事件,只有当操作系统<strong>内核缓冲区内的数据完全就绪</strong>，也就是程序真正可读或者真正可写了，才会被Java程序所监听到，直接进行memory copy，这种就是非阻塞IO，这种事件驱动机制，使得在单个线程可以处理大量的并发连接。</p><p>API方面，NIO使用channel通道和buffer缓冲区进行数据传输，搭配selector轮询器，使单个线程处理多个数据通道；共有4种channel，即SocketChannel、ServerSocketChannel、DatagramChannel、FileChannel。要注意两点的是：</p><ol><li>可以使用FileInputStream.getChannel()获得FileChannel，通过channel去操作文件，如果要进行读写，就需要在inputstream和outputstream的基础上构建两个FileChannel对象，而socketChannel是双通道的，一个socketChannel对象可以进行读和写；</li><li>另外，FileChannel不能切换到非阻塞模式，不能搭配selector使用，而<strong>socketChannel必须使用非阻塞模式搭配selector</strong>。</li></ol><p>简单NIOserver中，selector.register()监听serverSocketChannel的accept事件；轮训selector.select()，没有监听事件时select()会一直阻塞，监听到任意事件，使用selectedKeys()取所有的事件处理；acceptable时，accept()建立新的socketChannel通道，并register监听新socketChannel的READ事件。</p><h4 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h4><p>Reactor和Proactor是两种网络模型</p><p>Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即使用I&#x2F;O多路复用API监听事件，收到事件后，根据事件类型分配（Dispatch）给某个业务线程。NIO是一组API，他可以用来设计成Reactor模式，如Netty</p><ol><li>单Reactor单线程，也就是工作线程直接在Reactor线程上处理，Reactor虽然解决了IO阻塞，但一旦业务操作执行时间长，例如进行部分数据库操作，就会阻塞，单工作线程也不适合CPU密集型工作。采用<strong>单Reactor单线程模式的例如Redis</strong>，业务操作简单，而且完全基于内存，响应速度很快，对CPU依赖度低。</li><li>单Reactor多工作线程，单Reactor负责接收和响应操作系统的所有事件，业务逻辑通过工作线程池处理，解决了单Reactor单线程模式下，易发生业务阻塞和CPU利用率低的问题，但是单Reactor面对瞬时高并发场景，容易成为性能瓶颈，所以就将单Reactor变为多Reactor。</li><li>多Reactor多线程，mainReactor只负责建立网络连接，然后将socketChannel传递给subReactor线程，进行读写响应和业务处理。如Netty、Nginx。Spring 5的异步、Dubbo、RocketMQ等等</li></ol><p>Proactor异步IO模型，AIO就是采用这种模型，性能不一定比NIO高，但处理长耗时IO如文件下载有一定的优势，在Reactor 同步非阻塞IO模式下，JVM会一直使用操作系统IO多路复用API轮训是否就绪可read，最后channel.read()，也就是从内核缓冲区memorycopy到jvm内存的过程是同步的，而Proactor，最后由内核缓冲区到jvm内存的过程也是由内核完成的，最后由操作系统通知。</p><p>到这里，<strong>非阻塞IO是就绪读通知，异步IO是完成读通知</strong>。AIO理论性能会比NIO稍高，但应用非常少，成熟度一般，在Linux支持度一般，netty 5进行过实践弃用。</p><p>参考：<a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？-小林回答</a>、<a href="https://zhuanlan.zhihu.com/p/95662364#:~:text=Reactor%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A2%AB%E5%8A%A8,%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E3%80%82">高性能IO模型分析</a></p><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><p>Netty是JBoss基于NIO封装的开源异步网络API，源码层面很复杂，但是使用上却比NIO简单，需要处理高并发网络、实现自定义协议时更高层次抽象的Netty API，而不是直接使用传统网络编程Socket、NIO网络编程SocketChanel这些API。</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>主流的JavaWeb框架，例如SpringMVC，都是默认处理HTTP请求。</p><p>HTTP服务器首先肯定基于TCP，需要服务端不断的accept()或者其他形式去监听TCP端口，Tomcat服务器就是典型的HTTP服务器，同时Tomcat也是一个Java应用程序容器，部署相应的Java程序，也就相当于服务器支持了相应的网络通讯。</p><p>系统之间的交互，都可以称之为RPC，大部分情况下直接使用HTTP协议交互足够，可以自行协商交互报文，也可以在HTTP上使用标准的RESTful协议用于接口交互。很多RPC框架会觉得应用层通用的HTTP协议，用于系统间的通讯比较冗长，他们自定义了一些协议，例如sofaRPC、 Dubbo、gRPC、Spring Cloud之间，都是自定义协议，这些自定义协议其实就是基于Java Socket API开发的一套应用层协议+应用层服务器，RPC框架实现这些，其实和写一些HTTP服务器大同小异，都是在Socket API之上处理上层协议。</p><ul><li>实现系统间的连接通讯</li><li>实现报文高效的发送、分发和解析</li><li>定义易于理解和维护API规则，或者说应用层报文的规则</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的流</title>
    <link href="/2023/12/09/Java/%E6%96%B0blog/4.Java%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/09/Java/%E6%96%B0blog/4.Java%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!question]- 带着问题<br>因为属于复习了，先思考并整理完我的笔记，再带着具体的问题，向ChatGPT提问，不要没有想清楚自己内心的疑问是什么，就急着让ChatGPT把答案告诉你。甚至你可以带着答案提问，看你的理解，和ChatGPT的理解，有没有思维的碰撞</p><ol><li>Java中的流，也就是InputStreat、OutputStream，到底是什么样的概念，可以对Java中的这些API进行分类吗？</li><li>InputStream或者说Reader中的read()方法，如何完整的将文件读取，如果多次读取，如何拼接读取到的字符或者字节？</li></ol></blockquote><p>“流”是<strong>程序与目标数据源</strong>之间，高效读取和写入的一个抽象概念。建立一个流，具体在Java中的就是建立了一个流的对象，如new FileInputStream(“file”)。<br>流基于程序和目标数据源，那他所有的“输入流”其实都是针对于程序内存，目标数据源有几种</p><ul><li>目标数据源为文件的<strong>文件流</strong>；</li><li>还有一种<strong>网络流</strong>，目标数据源是TCP的客户端或者服务端，如socket、url等API连接产生的流。</li><li>无需存储在磁盘时，在Java程序虚拟出输入流输出流，目标数据源在程序内存的<strong>内存流</strong>（ByteArray流）</li></ul><h4 id="操作流需要注意的几个问题"><a href="#操作流需要注意的几个问题" class="headerlink" title="操作流需要注意的几个问题"></a>操作流需要注意的几个问题</h4><ol><li>IO流无论是**输入流或者输出流结束后都需要手动调用close()**，除非使用了 <strong>try-with-resource</strong> 这个Java 7以后提供的API开启的流，如果不关流，会一直占用操作系统资源，例如文件资源和网络资源。保持最后打开的流先关闭，例如要先关buffered流，再关掉buffered关联的File流，推荐使用try-with-resource。</li><li>需要注意**输出流写入完成后需要进行flush()**，否则有可能出现写入不成功的情况，因为在write时，为减少IO次数，会将数据写入至缓冲区中，只有当写满了缓冲区或者调用flush才会正式将文件写入，即使close流时最后会将缓存中还未完成真正写入的进行文件写入，但是可能close抛出异常导致文件写入不全，反正从规范性上来说，强烈推荐在输出流write()后调用flush()。</li><li>流是单向的，虽然<strong>网络流有两条双工的单向流</strong>，包含流实际操作也是单向的，inputStream就只能read。在网络连接中，可以关闭一条流保持半关闭，而不关闭整个TCP连接，例如使用socket.shutdownOutput()这样就是服务器关闭输出流，保持一种半关闭状态。</li></ol><h2 id="基本IO流"><a href="#基本IO流" class="headerlink" title="基本IO流"></a>基本IO流</h2><p>字节流InputStream和OutputStream，字符流Reader和Writer是Java IO中最重要的基类，而FileInputStream&#x2F;FileOutputStream 与 FileReader&#x2F;FileWriter是他们最重要的子类，操作目标为“文件”，他们的构造方法，需要指定操作的文件，传入<strong>File类对象或者字符串</strong>都可以完成指定，传入字符串会自动转化成File类对象；在输出流的构造方法中，可以传入第二个是否append的参数，为true时，文件追加写入，第二个参数为false或者不传时，文件覆盖写入。<br>基本上所有的IO流都可以用下面的通用API。</p><h4 id="1-核心读取方法："><a href="#1-核心读取方法：" class="headerlink" title="1. 核心读取方法："></a>1. 核心读取方法：</h4><p>通常读取数组后，要将byte数组或char数组转化成String，<strong>请使用String的构造方法将2种数组转化成String</strong>，不要使用数组的toString方法，这是Object方法，会返回类名和哈希值的信息，并不会转化成String。<br>而且推荐使用<code>new String(buffer, 0, readLength)</code>这个构造方法，这样而不是<code>new String(buffer)</code>，这样buffer没有读满时，buffer写入String中不会包含多余的空格。第二个参数代表“读取偏移量”，通常是0，代表从buffer数组的第1个字节开始写入，写入整个buffer，如果你不需要写入整个buffer，可以更改。<br>如果。<br>转化成String时，可能需要多次读取，来拼接最终的数组，拼接字符串一般就使用StringBuilder和StringBuffer，不是多线程环境或者没有线程安全问题，使用StringBuilder的性能略高。</p><ol><li>无参read()，每次读取1个字节&#x2F;字符到返回值，读到末尾会返回-1。使用while循环读取，可以</li><li>有参read(buffer数组)，方法参数传入指定长度的字节数组或字符数组，按数组长度读取字节或字符，同时返回实际读取的字节或字符数，读到末尾时返回-1。这个利用缓冲区来读，一般用这个会更多一点点，但是在边读边写的时候，搭配write(byte[ ] b, int off, int len)使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> Builder();<br><span class="hljs-type">byte</span>[ ] buffer =<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bufferLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>( ( bufferlength = inputstream.read(buffer) ) != -<span class="hljs-number">1</span> )&#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,bufferLength);<br> stringBuilder.append(str);<br>&#125;<br>System.out.println(stringBuilder.toString());<br><br></code></pre></td></tr></table></figure><h4 id="2-核心写入方法"><a href="#2-核心写入方法" class="headerlink" title="2. 核心写入方法"></a>2. 核心写入方法</h4><p>通常写入前需要将String转化成数组，请使用String的实例方法getBytes()和toCharArray()进行转化。这里提一个热知识，编写原生JSON串时，编辑器要求写很多转义符“\”，转义符只存在于Java代码层面，在编译成字节码就不存在了，在内存中处理和控制台打印都是不存在转义符的。</p><p>输出流也有两个常用写入方法，字节流写入byte数组，字符流同理写入char数组，但字符流可以write(String str)：</p><ol><li>write(byte[ ] b)，写入整个数组。</li><li>write(byte[ ] b, int off, int len)，指定写入数组的偏移量和长度，例如写入byte数组，从第10个字节开始，写20个字节。</li></ol><p>日常用普通的write方法足够，但是，和上面的String情况相似，当你的输入流是通过buffer去读取的，而你想直接将读到的buffer块写入时，请搭配可以指定偏移量的write方法，防止在buffer没有读满时，write了我们不需要的空字符串导致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Byte[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>((size = in.read(buffer))!= -<span class="hljs-number">1</span>)&#123;<br>  out.write(buffer,<span class="hljs-number">0</span>,size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-字节字符转化流"><a href="#3-字节字符转化流" class="headerlink" title="3. 字节字符转化流"></a>3. 字节字符转化流</h4><p><code>InputStreamReader</code>、<code>OutputStreamWriter</code>是FileWriter&#x2F;FileReader是的父类，<strong>将字节流转化成字符流</strong>，不能使用FileReader&#x2F;FileWriter接收，可以用Writer&#x2F;Reader或者本身引用接收，将字节流转化成字符流后搭配BufferReader或BufferWriter，进一步使用readLine或者newLine方法，尤其是搭配BuffedReader非常常见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">consoleReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>consoleReader.readLine();<span class="hljs-comment">//和scanner.nextLine()类似</span><br></code></pre></td></tr></table></figure><p><code>PrintWriter</code>也是在网络流中常用的字节字符转化流，字节输出流转Writer，用PrinWriter类接收，独有的封装方法println()，等同使用BufferedWriter的write()加newLine()，抽象程度更高，既有缓存装饰，也能够直接完成字节流转成Writer，他的构造方法可以是File类、Writer、OutputStream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream, <span class="hljs-literal">true</span>);<br>writer.println(userInput);<br></code></pre></td></tr></table></figure><h4 id="4-内存流"><a href="#4-内存流" class="headerlink" title="4. 内存流"></a>4. 内存流</h4><p>ByteArrayInputStream&#x2F;ByteArrayOutputStream也就是内存流，不同于一般的目标数据源是“文件”或者“网络”，在Java程序中，我们虚拟的构造出一个字节流，我们需要借助流操作，就使用内存流。使用场景：</p><ol><li>我个人的理解的第一种用法是临时存储，通过网络输入流或者文件输入流read数据时，有一种后续处理，是我们同步使用输出流write，例如服务器文件的上传与保存；还有一种后续处理，是read后将数据先在Java程序程序，如果是文本数据，我们可以通过StringBuffer来拼接多次read的数据，但如果是二进制数据，我们一般在Java程序中构建一个虚拟的输出流，即<code>ByteArrayOutputStream</code>，read的同时同步write数据，最后使用<code>toByteArray()</code>转化成完整的byte数组，达到临时存储的作用，再统一处理的作用，例如进行加密或者解密等操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 对读取到的数据进行加密</span><br>    <span class="hljs-type">byte</span>[] encryptedData = encryptData(buffer, len);<br>    bos.write(encryptedData, <span class="hljs-number">0</span>, encryptedData.length);<br>&#125;<br><span class="hljs-type">byte</span>[] data = bos.toByteArray();<br>fis.close();<br></code></pre></td></tr></table></figure><ol start="2"><li>搭配对象流，不借助文件在内存中完成对象序列化和反序列化，实现clone()深拷贝，参考下边“装饰流的对象流部分”</li></ol><h2 id="装饰流"><a href="#装饰流" class="headerlink" title="装饰流"></a>装饰流</h2><p>使用装饰流，传入普通的输入流和输出流，让输入输入流有更多的API功能，例如字符缓冲、读写对象和读写二进制。</p><h4 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1. 缓冲流"></a>1. 缓冲流</h4><p>BufferedInputStream&#x2F;BufferedOutputStream 与 BufferedReader&#x2F;BufferedWriter这几个类是缓冲流，Buffered流是字节流字符流基类的装饰器，<strong>他们的构造方法需要接收字节流字符流基类对象</strong>来实现自身实例化，也就是说在使用装饰流时，；相比普通File流，方法使用上没什么区别，但增加了内存缓冲区，多次读取和写入时，减少了IO的次数，尤其可以提高大文件的读写效率。要使用他们本身引用来接受缓冲流对象，会增加一些独有方法：</p><ol><li>BufferedReader中的readline()方法读取一行，返回String，没有下一行返回null</li><li>BufferedWriter的newLine()方法，换行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">inputStreamReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.conf&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(inputStreamReader);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">while</span>((line=bfr.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>bufferWriter.write(line);<br>    bufferWriter.newLine();<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-对象流"><a href="#2-对象流" class="headerlink" title="2. 对象流"></a>2. 对象流</h4><p>对象流就是ObjectOutputStream和ObjectInputStream，对象想要能够通过对象流持久化保存，需要实现下面两种接口，transient关键字用于申明属性不应该被序列化，序列化以后会用默认值序列化。</p><ul><li>实现Serializable空接口，就对对象进行序列化，如果属性是类，也需要实现serializable接口才能完成序列化，序列化版本号用于标记对象版本，不写继承Serializable会根据类的属性进行哈希计算一个。</li><li>实现Externalizable接口，重写writeExternal和readExternal方法，能够更精细化控制序列化的属性，较少使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>; <span class="hljs-comment">// 序列化版本号，建议显式声明</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 序列化对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>oos.writeObject(s);<br>oos.close();<br><br><span class="hljs-comment">// 反序列化对象</span><br><span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) ois.readObject();<br>ois.close();<br>bis.close();<br>bos.close();<br></code></pre></td></tr></table></figure><h4 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3. 数据流"></a>3. 数据流</h4><p>数据流是DataInputStream和DataOutputStream，数据不通过原始字节保存，使用<code>writeInt(1999)、WriteUTF(&quot;String&quot;)、readUTF()</code>等方法，将数据以Java二进制的形式保存或读取，使用方式上和各类装饰流大同小异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> ( <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/file&quot;</span>)) ) &#123; <br>dos.writeInt(<span class="hljs-number">123</span>); <br>dos.writeFloat(<span class="hljs-number">123.45f</span>); <br>dos.writeUTF(<span class="hljs-string">&quot;Java数据流&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的函数式编程</title>
    <link href="/2023/12/06/Java/%E6%96%B0blog/3.Java%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/12/06/Java/%E6%96%B0blog/3.Java%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda和方法引用"><a href="#Lambda和方法引用" class="headerlink" title="Lambda和方法引用"></a>Lambda和方法引用</h2><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p>Java源码中存在很多<strong>单抽象方法的接口</strong>，称函数式接口，通常会用@FunctionalInterface标记，如Comparator、Runnable、Callable、Function。函数式接口作为方法的接收参数时，我们通常通过匿名内部类的形式，直接创建函数式接口的实例化匿名类对象。<br>Java8以后，可以用Lambda表达式来<strong>简化函数式接口的匿名类</strong>编写，编译器会通过lambda表达式推断出函数式接口的匿名实现类，而且性能会比直接编写匿名类更高。<br>编写方式：不需要写传入参数的类型，也不需要写返回值，编译器会自行推断，Lambda表达式实际生成了匿名内部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lamda表达式详写</span><br>Function&lt;String, String&gt; fun = name -&gt; &#123; <br>  <span class="hljs-keyword">return</span> name.toUpperCase();<br>&#125;<br><span class="hljs-comment">// Lambda表达式简写，一行代码时，省略花括号，省略return</span><br>Function&lt;String, String&gt; fun = name -&gt; name.toUpperCase();<br></code></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用可以说是Lambda表达式的子集，因为方法引用一定可以用Lambda表达式表达，但理念和用途上可以说完全不一样，lambda表达式强调一段独立处理，传入的参数可以自由的处理（方法引用只能通过方法签名参数引用），很多函数式接口都可以使用，尤其是Runnable等接口的使用；而方法引用，强调直接关联一个已经存在的方法，需要抽象方法和引用方法之间参数的完全匹配，通常是源码中提供的方法，最常搭配Stream AP使用。</p><p>使用方式：在函数式接口引用要接受数据的情况，可以选择与抽象方法签名匹配的方法，什么叫签名匹配，就是<strong>方法传入参数的数量和类型，以及方法的返回值完全匹配</strong>，这个方法就可以作为方法引用，<strong>这个方法引用，同Lambda表达式一样，实际推导成了匿名内部类对象</strong>。</p><ol><li><p>引用静态方法：显性签名一致，直接可以引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(array, Main::cmp);<br></code></pre></td></tr></table></figure></li><li><p>引用实例方法：</p><ul><li>类实例方法引用：隐性的包含一个自身类型的this引用，作为实例方法签名的第一个参数，例如下面的例子，实际签名可以看为<code>int compareTo(String this,String 0)</code>，所以与需要传入的compare()方法的签名还是匹配的。</li><li>对象实例方法引用：方法签名是不包含对象this的引用<br> 下面map()和forEach()的例子中，明显的表示出这种区别，map需要传入一个Function对象（1个传入参数，1个返回值），toLowerCast是一个无参方法，但类实例方法隐形包含String this.toLowerCast()，Strream流中的参数过来，首先会匹配到String this的位置；与之不同，forEach需要传入一个Consumer对象（1个传入参数，无返回值），println(String x)是一个有参方法，使用对象实例方法引用，Stream流中的参数，会匹配到String x的位置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span> &#125;;<br>Arrays.sort(array, String::compareTo).map(String::toLowerCast).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>引用构造方法时，如：<code>Person::new</code>，虽然构造方法没有return语句，会隐性的包含返回一个Person类型的this对象，所以也要注意匹配</p></li></ol><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream API是一个处理集合和数组的流式API，在处理之前，我们需要先将数据转化成Stream对象，可以使用<code>Stream.of(&quot;a&quot;,&quot;b&quot;)</code>这个静态方法直接构建Stream对象，也可以通过<code>Arrays.stream( arr )</code>这个静态方法，将数组转化成Stream，更多的时候，我们通过<code>list.stream()</code>这个Collection集合的实例方法，将List和Set集合转化成Stream对象。<br>连接两个Stream流：Stream.contact(a,b)合并a和b两个stream，返回成一个Stream<br>处理基本数据类型的数据时候，例如对一个int型数组进行流式操作，我们要使用<strong>IntStream</strong>接收，而不是Stream&lt;Integer&gt;，同理的还有LongStream、DoubleStream，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><p>有了前期的准备工作，我们可以开始进行流式处理，为什么说流式处理，因为中间操作的方法的返回值任然是一个Stream对象，可以连续处理，Stream API的操作分为中间操作和终端操作，<strong>只有终端操作开始，才会真正开始处理</strong>，如果没有执行终端操作，进行中间操作lambda里面的内容是不会执行的。</p><h4 id="常用中间操作"><a href="#常用中间操作" class="headerlink" title="常用中间操作"></a>常用中间操作</h4><ul><li>map，引用为Function接口，方法只有1个入参和返回值且都为泛型。方法内可以写Lambda，也可以写方法引用</li><li>fitter：传入1个泛型参数，返回一个boolean参数。filter一般搭配Lambda定制过滤的规则。 <code>stream.filter(s -&gt; s != null &amp;&amp; !s.isBlank())</code></li><li>sorted：元素实现Comparable就可以直接调用；没有就传入一个比较器</li><li>distinct：需要元素重写equals和hashmap方法</li><li>skip(3)：跳过Stream前三个元素截取</li><li>limit(2)：截取stream流中的前两个元素</li></ul><p>flatmap操作：传入1个泛型参数，返回一个Stream。flatmap用来理嵌套的数据结构，将一个嵌套的流的映射形成一个扁平的流。例如下边的例子中，List::streamList，nestedNames这个Stream中的，list会调用list.stream()，返回到flatMap的主Stream中，最终形成扁平的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; nestedNames = Arrays.asList(<br>        Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>),<br>        Arrays.asList(<span class="hljs-string">&quot;Cathy&quot;</span>, <span class="hljs-string">&quot;David&quot;</span>)<br>);<br><br>Stream&lt;String&gt; flattenedNames = nestedNames.stream().flatMap(List::stream);<br><span class="hljs-comment">// 结果：[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cathy&quot;, &quot;David&quot;]</span><br></code></pre></td></tr></table></figure><h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>1个终端操作之后，不能再进行其他的终端操作，例如<strong>进行了reduce以后，不能再使用collect(Collectors.toList())等方法</strong></p><ol><li><p>reduce：对元素进行聚合计算，比如说累加操作、累乘操作、聚合Map等等，推荐使用带初始值reduce(T identity, BinaryOperator&lt;T&gt; accumulator)，其BinaryOperator的抽象方法，需要传入2个参数，返回1个参数，例如<code>reduce(0, (acc,n) -&gt; acc+n )</code>，BinaryOperator中第1个参数为上次计算的结果，第2个参数stream元素的值。</p></li><li><p>collect操作：**collect(Collectors.toList())**，还可以传入Collectors.toSet()、Collectors.toMap()，要注意toMap()方法有两个参数，需要指定两个Lambda表达式进行两个值的映射。<br> Collectors.groupingBy()，groupingby内的方法引用，1个传入参数，返回1个String。目的让我们写一个Lambda表达式作为分组的Key，默认被Collectors.toList()收集器所收集。<br> 另外还有一个带两个参数的重载方法，可以在groupingBy()方法中输入第2个参数，指定用其他收集器例如Collectors.toSet()或者Collectors.counting()来统计分组的结果。</p></li></ol><p>假设我们从数据库中取到了List&lt;Student&gt;，我们在Java程序中按照班级进行分组，就可以使用Stream API的groupingby功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, List&lt;Student&gt;&gt; grouped = studentList.stream().collect(Collectors.groupingBy(Student: :getClassId,Collectors.toList()));<br></code></pre></td></tr></table></figure><ol start="3"><li>for-each：一般用来循环打印，<code>stream.forEach(System.out: :println)</code>，你也可以在循环体通过Lambda写自己想要循环执行的事情</li><li>count()、anyMatch()</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础语法糖</title>
    <link href="/2023/09/06/Java/%E6%96%B0blog/1.Java%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2023/09/06/Java/%E6%96%B0blog/1.Java%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常是Java源码定义的一组类，当然你也可以继承某些异常基类来自定义异常，反正异常抛出来，代码表示代码出现了“错误”。</p><p>Java中有2大类异常：</p><ol><li><strong>运行时异常</strong>（非受检异常），IDE不需要不捕获的异常。这种异常一般就意味着代码有问题，出现了不应该出现的一些错误，比如空指针异常、数组越界异常，我们应该去修改代码的问题。当我们自定义异常不想要IDE在编译阶段强制我们处理异常时，也可以继承运行时异常作为基类</li><li><strong>检查性异常</strong>（编译时异常），IDE会要求必须捕获也就是必须try-catch的异常。这种异常意味着你对这部分API应该进行容错处理，try-catch就是为了容错处理，万一没有按照要求执行，我们应该如何继续处理，比如IOException、SQLException等，这些操作非常容易没有按照要求继续。</li></ol><p>异常的产生，都是你在调用这些Java API的时候，源码的方法throws了异常，对于运行时异常，IDE不会在编译阶段，让抛出的异常进行try-catch或者throws，但对于检查性异常，这要求我们在编译前必须捕获，如果不捕获，那就必须方法签名再throws给上层调用方。一般来说，如果是执行层面的代码，就一般会try-catch，如果是封装层面的API，throw异常并方法签名throws是一种常规操作，表示你调用我API失败后，必须容错处理。</p><p>对于try-catch，try块捕捉异常对象，catch块决定捕捉异常后的处理方式，要注意try代码块中，抛出异常，后面的代码不再可达。自己去裁定try的范围，需要明细打印问题，可以精细化try-catch处理，自己结合工作实践合理的去划定try的范围，使代码更清晰，可读性更高。然后在try执行代码块中主动throw一个Exception，然后在catch，这是<strong>异常用于流程控制</strong>的一种使用，有些情况相比于if-else，可能更加清晰的标注了“错误”的代码处理逻辑，保持代码的清晰性。</p><p>抛出异常后，在catch中使用e.printStackTrace()，只会在控制台打印堆栈信息，如果要记录在日志中，则需要利用日志工具将堆栈信息印在日志中，大部分日志工具都会提供<code>log.error(&quot;&quot;,e)</code>的方法打印堆栈信息至日志。</p><h2 id="变量和方法的设计"><a href="#变量和方法的设计" class="headerlink" title="变量和方法的设计"></a>变量和方法的设计</h2><p><strong>Java类由成员变量和方法组成</strong>，任何的代码都是从方法内部开始的。</p><p>传入参数到方法时，或者说变量赋值是，基本数据类型是<strong>值传递</strong>，引用类型数据时<strong>引用传递</strong>，此时方法内对参数进行修改，也会影响原始值，这是Java的设计，如果不想改变引用类型数据的值，在方法内部使用clone或者其他方式创造副本再进行操作。</p><p>对于成员变量的设计，除了类标志性的属性可以设置为成员变量，试情况也可以将一些需要外部传入的业务流水号等，设置为成员变量，不需要将所有外部传入的值，全部通过方法参数传入。很多纯逻辑处理的工具类，是没有成员变量的，里边可能就全是static方法。注意成员变量设置的时候一般就全部设置为private访问控制符，很少设置成其他访问控制符。</p><ol><li>（类的）成员变量：定义在方法外的变量，<strong>有默认值</strong>，引用类型的变量默认值是null（**String初始化建议写””**），布尔类型默认值为false，加载在堆内存中，随着对象产生或消亡。</li><li>（方法的）局部变量：定义在方法中的变量，<strong>局部变量无默认值，使用前必须要初始化</strong>。局部变量的创建在栈内存中，随着方法产生和消亡，即随线程产生或消亡。</li><li>静态变量（类变量）：是一种特殊的成员变量，成员变量基础上加用static关键字修饰属性，类加载时产生（class文件读取到内存中）</li></ol><h2 id="流程语法"><a href="#流程语法" class="headerlink" title="流程语法"></a>流程语法</h2><p>break跳出控制语句（switch，for，while等），continue跳出本次循环（用于for循环），return跳出整个函数</p><p>在判断语句中，<strong>单纯判断、char、byte、short、int和String（JDK 7 ）的值情况</strong>可以用switch代替if-else<br>switch效率比if-else高，但是灵活度非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    System.out.println(<span class="hljs-string">&quot;this is one.&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    System.out.println(<span class="hljs-string">&quot;Others.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resource和try-catch-finally"><a href="#try-with-resource和try-catch-finally" class="headerlink" title="try-with-resource和try-catch-finally"></a>try-with-resource和try-catch-finally</h4><p>Java 7以后，数据库连接和流，可以使用try-with-resource代替try-catch-finally，让代码变得更简单，资源会自动关闭，不再需要在finally里调用close方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 读取文件数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-comment">// 处理异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包与访问权限控制"><a href="#包与访问权限控制" class="headerlink" title="包与访问权限控制"></a>包与访问权限控制</h2><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>当我们需要使用<strong>非本包中的类</strong>时，用import关键字导入包的具体类或所有类；或者直接在代码中写类。只有lang包下的类和同一个包下的类不需要导包，可以直接使用类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.zhuxin.*  <span class="hljs-comment">//通配符导入com.zhuxin包中所有的类</span><br><span class="hljs-keyword">import</span> com.zhuxin.Demo<span class="hljs-comment">//导入com.zhuxin包中的Demo类</span><br><span class="hljs-comment">//JDK5后，支持导入静态属性，称静态导入，导入System类中的out属性</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.out<br></code></pre></td></tr></table></figure><h4 id="类、方法和属性的访问权限控制符"><a href="#类、方法和属性的访问权限控制符" class="headerlink" title="类、方法和属性的访问权限控制符"></a>类、方法和属性的访问权限控制符</h4><ul><li><p><strong>类的属性与方法的访问控制</strong></p><p>当你对类有访问权限后（同包类，或者导包后），访问权限控制符，约束了调用类中成员变量和成员方法能否被直接调用，下面访问权限越来越大</p><ol><li><strong>private</strong>：除了在本类，均不能被直接访问，即使是继承了父类的子类，这也是最常使用的权限控制符</li><li>不加修饰符：可以被<strong>同包</strong>的类直接访问，又称为包级访问权限。要注意的是，对于接口，他不是类，所有方法和属性只能是public权限，所以接口不加修饰符，方法和属性就是public，而不是default的同包权限</li><li><strong>protected</strong>：可以被<strong>同包和子类</strong>直接访问，一般来说子类通常可以允许</li><li>public：可被所有包的类访问。</li></ol></li><li><p>类的访问权限，比较少使用</p><ol><li>public：修饰的类在导包后，能在所有包中使用，</li><li>不加权限（包私有类）：修饰的类只能在本包中使用，就算导包也无法访问到类</li></ol></li></ul><h2 id="Java重要的关键字"><a href="#Java重要的关键字" class="headerlink" title="Java重要的关键字"></a>Java重要的关键字</h2><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this关键字是JVM在创建对象后产生的一个<strong>指向对象本身的一个引用</strong>，根据这个原理，得出this的作用</p><ol><li>this.属性&#x2F;方法：<strong>强调本类的成员属性或成员方法</strong>，内部类中的this强调内部类本身的成员属性和方法<br>重写方法后不仅使用方法默认会指向子类重写方法，原父类方法中的this调用的方法也会指向子类重写方法。<br>属性不存在重写，就算子类有一个父类同名属性，父类方法加与不加this都是永远调用的是父类属性，子类方法永远调用的是子类的属性。</li><li>this()：<strong>在构造方法中调用本类的其他构造方法，注意必须写在构造方法第一行</strong><br>场景举例：写一个包含所有字段的构造函数，然后其他部分字段构造函数去调用这个全字段构造函数</li><li>this：单纯<strong>代指当前对象</strong><br>比如父类方法中存在return this，父类对象调用这个方法返回父类对象；子类对象调用这个父类方法，虽然是父类中的this，但是会返回子类对象，这是Java多态性的体现。</li></ol><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ol><li>super.属性&#x2F;方法：当<strong>子父类存在相同的属性或方法时</strong>，super强调当前对象父类中的属性和方法，如果不存在，子类可直接使用父类的属性方法（private修饰除外）</li><li>super()：在子类构造方法中调用父类构造方法。super方法必须写在构造方法的首行，不能和this()一同使用<br>子类构造方法默认在首行使用了super()调用了父类中的无参构造方法，要注意的是，如果父类不存在无参构造方法将会报错，<strong>注意给父类编写带参构造方法后需要注意再编写一个无参构造方法</strong>。</li></ol><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ol><li>被final<strong>修饰的类不能被继承</strong>，为了安全考虑明确禁止继承，一般很少将类设计为final类。</li><li>修饰的变量为不可更改的常量，当修饰基本数据类型值不能改变，<strong>修饰引用类型不能更改指向的对象</strong></li><li>被final<strong>修饰的方法不能被子类重写</strong>，明确禁止子类重写此方法时才用final修饰方法，父类的private方法其实是一种隐式地指定为final方法。</li></ol><h4 id="static关键字（类方法，类属性）"><a href="#static关键字（类方法，类属性）" class="headerlink" title="static关键字（类方法，类属性）"></a>static关键字（类方法，类属性）</h4><p>static修饰的属性（不能修饰局部变量）和方法，成为静态属性或静态方法，静态方法和静态属性属于类，不依赖与某个对象，可以直接<strong>通过类名调用静态属性和静态方法</strong>，但遵循访问权限控制。<strong>静态方法只能直接调用静态变量和静态方法</strong>，所以在Main方法调用的其他方法，要么是静态方法，要么是通过对象调用的普通方法。</p><p>static方法可以重写，但是不支持多态，也可以说<strong>static方法的重写不算重写</strong>，父类引用调用的还是父类中的方法，而不是子类中的同名静态方法，当然这种编写方式也没什么意义。<br>static还有一个地方用法是静态内部类，基本很少用。</p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h4 id="重载-overloadding"><a href="#重载-overloadding" class="headerlink" title="重载(overloadding)"></a>重载(overloadding)</h4><p>重载是方法名不变，<strong>形参的变化形成新的方法</strong>，返回类型可变可不变，也就是说相同的方法名实际代表不同的方法。</p><p>当没有对构造方法进行重载时，默认带一个无参构造方法，当对构造方法重载了一个有参数构造方法后，无参构造方法消失。</p><p>可变长度参数（如String… args）：0个或多个参数。方法的参数列表内可以传入不定长度的参数，只能有一个可变长参数且放于所有参数后面，在要实现不定长度参数的类型后加 **…**。Java的可变参数在编译为字节码后，在方法签名中就是以数组形态出现的（将几个参数打包成数组），所以二者同时不可重载</p><h4 id="重写-override-，也称覆写"><a href="#重写-override-，也称覆写" class="headerlink" title="重写(override)，也称覆写"></a>重写(override)，也称覆写</h4><p>重写方法是继承性的重要性质，子类的重写方法的<strong>行参和返回类型不能改变</strong>，JDK5后子类返回值可以是父类的派生类，子类重写方法<strong>访问权限不能比父类方法严格</strong>。</p><p>重写方法后，调用方法默认会指向子类重写方法，比如父类引用也会调用子类方法（提现Java的多态），同时原父类this调用的方法也会指向子类重写方法。当子类想调用父类方法不调用子类重写方法，使用super关键字调用原父类方法。</p><p>属性不存在重写，就算子类有一个父类同名属性，父类方法加与不加this都是永远调用的是父类属性，子类方法永远调用的是子类的属性。</p><h2 id="Java的几种特殊类"><a href="#Java的几种特殊类" class="headerlink" title="Java的几种特殊类"></a>Java的几种特殊类</h2><p>Java中存在3种类，普通类，抽象类和接口。抽象类在继承方面的特性和普通类一样，单继承类，多继承接口；接口可以多继承接口，当普通类实现子接口时，强制实现类重写子接口和父接口中的所有抽象方法。<strong>抽象方法即abstract方法，用abstract修饰且无方法体的方法</strong></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口定义了规范或者说协议，他是一组抽象方法的集合，public abstract可以省略。我们使用interface声明定义一个接口，然后类使用implement实现接口。<br>接口的属性只能是静态常量并很少使用，默认可以不写public static final。Java8以后，接口方法可以是default方法和static方法，这使得接口和抽象类很像，default一般用于老接口的拓展，他们都可以实现类来调用，一般不推荐在接口中使用这两种方法。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>用<strong>abstract修饰class</strong>即为抽象类，<strong>唯一特征是不能被实例化</strong>，必须被继承才能实例化。抽象类可以有属性，甚至可以没有抽象方法，有抽象方法的抽象类被继承时，子类必须实现抽象方法，要注意<strong>与接口不同，抽象类的抽象方法必须要用abstract声明</strong>；抽象类可以像普通类一样单继承类，多继承接口，继承接口也可以选择不实例化，留给继承抽象类的类实例化。</p><h4 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h4><p>内部类是一个编译时的概念，编译完成以后成为两个不同类。内部类中的this关键字指的内部类成员属性和方法，外部类名.this才是强调外部内的成员属性和方法，<br>内部类特性：可以直接调用外部类的private属性。<br>成员内部类、<strong>匿名内部类</strong>、静态内部类。Runnale接口就常用匿名内部类，这是内部类最重要的部分，其他比较少使用，参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1376414781669409">廖雪峰内部类</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部类实例化依赖于外部类实例化</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><h4 id="1-封装性"><a href="#1-封装性" class="headerlink" title="1. 封装性"></a>1. 封装性</h4><p>面向对象的核心思想之一就是封装性（Encapsulation），封装就是将属性和方法这些具像的东西“装”到一个类中，私有化属性，<strong>提高安全性</strong>，<strong>隐藏实现细节</strong>。<br>我们使用API或者各种框架时，封装性使得我们忽略实现细节，只要去使用即可。</p><h4 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h4><p>子类extents父类，获得父类的属性和方法（除private属性和方法），并<strong>通过重写方法和增加新方法，形成新的类，复用父类的代码</strong>，这就是OOP中的继承性的作用。C++使用多继承，Java支持单继承（Single inheritance）。</p><p>实际证明，继承关系（class-based）确实会带来一些代码量的减少，但是带来了子父类的强耦合，所以更现代的流派更推荐使用组合关系（prototype-based），也就是像Java的接口一样，Go语言已经完全采用prototype-based关系。</p><h4 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3. 多态性"></a>3. 多态性</h4><p>Java中的多态是一个父类类型对不同子类对象同一方法的不同响应，代码解耦合，例如工厂模式，service接口等就是多态的运用。</p><p>实现多态，最基础依赖于继承或者实现（extends&#x2F;implement），当子类方法重写，这是动态多态的基础（运行时多态），后续可以进行向上转型或者向下转型，另外方法的重载也是一种多态，这是静态的多态（编译时多态）。<a href="https://blog.csdn.net/SEU_Calvin/article/details/52191321">多态原理</a></p><ul><li>向上转型（upcast）：父类引用指向子类对象。也可以解释成子类对象转化成了父类，也就是所谓的“向上”</li><li>向下转型（downcast）：父类引用重新强转回子类，当父类对象要调用子类的独有方法时需要向下转型，相当于我们多态父类引用转回原子类。向下转型比较少用，用也搭配<code>instanceof</code>，防止出现类型转化异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCasting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Upcasting</span><br><br>        <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) animal; <span class="hljs-comment">// Downcasting</span><br>            dog.bark(); <span class="hljs-comment">// Outputs: Dog barks</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Java所有类都继承自Object类，同时也会继承到Object类中的方法，如hashcode()、equals()、clone()、notify()、wait()、finalize()，除了equals()和finalize()，其他方法都是native方法（JNI调用），此处重点摘记一下浅拷贝和深拷贝。</p><p>实现浅拷贝：<strong>需要拷贝的类必须implements Cloneable接口，重写clone()方法</strong>，然后对象调用clone()实现浅拷贝，浅拷贝只会复制基本数据类型，复制的属性是引用型数据时，例如类和数组，只会复制内存地址，而不会完全复制一份对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 浅拷贝重写clone()方法</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>而深拷贝就是所有属性都会完全复制一份，自己去实现对象复制，任何可以达到的方式都可以，比较常用的是<strong>使用对象序列化和反序列化实现深拷贝</strong>，整体使用简单，用流先写入到字节内存，然后再读取，特别是属性较多时，不需要一个个赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 将对象写入字节流</span><br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>    oos.writeObject(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// 从字节流中读取对象</span><br>    <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>    <span class="hljs-keyword">return</span> ois.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些方式实现深拷贝，就是clone()方法先拷贝基本数据类型，再逐步实现引用型数据的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>  <span class="hljs-type">int</span> number;<br>  String name;<br>  <span class="hljs-type">int</span>[] arr;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepCopy</span><span class="hljs-params">(<span class="hljs-type">int</span> number, String name)</span> &#123;<br>      <span class="hljs-built_in">this</span>.number = number;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>      <span class="hljs-type">DeepCopy</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> (DeepCopy) <span class="hljs-built_in">super</span>.clone();<br>      copy.arr = arr.clone(); <span class="hljs-comment">// Deep copy of the array</span><br>      <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="int和String的转化"><a href="#int和String的转化" class="headerlink" title="int和String的转化"></a>int和String的转化</h4><p>这几个方法整体性能差不多的：</p><ul><li>**Integer.toString(int a)和Integer.parseInt(String str)**；原型方法</li><li>String.valueOf(int a)和Integer.valueOf(String str)； 对上面2个方法的封装，部分情况下使用更方便，比如是String.valueOf()重载了多种基本数据类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2023/03/07/Java/%E6%96%B0blog/2.Java%E9%9B%86%E5%90%88/"/>
    <url>/2023/03/07/Java/%E6%96%B0blog/2.Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>Java有三种类型的集合，插入有序且元素可重复的List、插入无序且元素不可重复的Set、键值对形式的Map。其中List和Set都继承自Collection，他们公共的且最常用的方法都来自于Collection接口，例如add、remove、isEmpty、contains。</p><p>关于集合插入null值：大部分集合类都允许元素为null，List支持插入多个null值、HashSet、HashMap支持一个null值，TreeSet、TreeMap等要排序的集合不支持插入null值</p><h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>集合是Java提供的一组泛型类，所以讲集合之前，我们先讲一下什么是泛型。</p><p>泛型在集合源码中非常常见，假设我们设计集合不用泛型，要让一个集合类能够兼容所有数据类型，那集合元素就必须设计成是Object类型，通过“向上转型”来接收所有类型数据，但每一次获取数据，需要向下转型，需要强转；要么就为每一种数据类型写一个集合类，就增加了类的编写数量。<br>所以集合引用了泛型，让集合类一种<strong>模板代码</strong>，来适应任意的数据类型，<strong>让我们在实例化的时候才决定了参数的数据类型</strong>，不需要为每一种数据类型都写一个集合类。</p><p>Java的泛型是“擦拭法”实现的，无论实例化成什么类，编译后泛型类中的数据通过Object对象保存，所以泛型类型不能为<code>int</code>等基础数据类型，要使用他们的包装器对象例如<code>Integer</code>；用反射或者Class，<code>List&lt;number&gt;</code>和<code>List&lt;Integer&gt;</code>是同一个Class，他们不存在子父类关系。</p><h4 id="代码引入泛型类型的几种方式"><a href="#代码引入泛型类型的几种方式" class="headerlink" title="代码引入泛型类型的几种方式"></a>代码引入泛型类型的几种方式</h4><ol><li>泛型类：比如ArrayList类，在类的签名中引入泛型<code>&lt;E&gt;</code>，泛型类<strong>在创建对象时指定泛型类型</strong>，不指定泛型类型就默认为Object类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>泛型接口：比如Comparable接口，和泛型类一样，在接口签名中引入泛型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;<br></code></pre></td></tr></table></figure><blockquote><p> 当类继承泛型类或实现泛型接口时，有两种指定泛型类型的时机，第一种是<strong>在类的声明处指定泛型接口的类型</strong>，例如类实现Comparable接口的用法；另一种形式，类变成泛型类，后期实例化再决定数据类型，取决于具体的设计来选择。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;  <span class="hljs-comment">//类实现泛型接口需要指定数据类型</span><br></code></pre></td></tr></table></figure><ol start="3"><li>泛型方法：<strong>在方法签名的返回值前用<code>&lt;T&gt;</code>单独声明泛型类型</strong>，不依赖于类或者接口带来的泛型类型。泛型方法被调用时，可以显示声明泛型方法的类型，如 <code>demo.&lt;String&gt;run(str1,str2)</code> ，也可以不声明参数类型，编译器会根据你传入的参数类型自行推断<br>静态方法不能通过泛型类和泛型接口引入来的泛型类型，编译会报错，必须使用泛型方法才能引入泛型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> <br></code></pre></td></tr></table></figure><h4 id="类型参数边界（type-parameter-bound）"><a href="#类型参数边界（type-parameter-bound）" class="headerlink" title="类型参数边界（type parameter bound）"></a>类型参数边界（type parameter bound）</h4><p>当我们的设计的API，让泛型类&#x2F;泛型接口引用作为方法的参数，通常来说我们要指定泛型引用具体的类型，例如<code>List&lt;Number&gt;</code>，但我们很多时候设计API，想让API中传入泛型类型<strong>适用于某一个基类及其派生类或者他的超类</strong>。由于泛型类型不存在子父类关系，例如虽然Integer是Number的子类，但<code>List&lt;Number&gt;</code>和<code>List&lt;Integer&gt;</code>这两种泛型类型并不存在父子类关系，所以我们不能够通过向上转型，让<code>List&lt;Number&gt;</code>接收<code>List&lt;Integer&gt;</code>，我们想要API的编写支持这样的形式，需要使用<strong>通配符”?“，搭配extends关键字或者super确认泛型的上下界</strong>，例如<code>List&lt; ? extends Numbers&gt;</code>就可以达到我们接受子类的要求。</p><p><strong>泛型的上下界</strong>，参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265105920586976">廖雪峰的泛型上下界</a></p><ul><li>上界：<code>? extends Number</code>，传入的泛型数据类型必须为Number类或他的下级类。<strong>extends上界在方法内允许泛型类的读取方法，但不允许调用泛型类的写入类方法（除非写入null）</strong>，否则编译无法通过。<br>因为Number可以安全的接收传入的任意下界类数据，但是写入，就算方法内写入的是比较小的Integer类型数据，但是传入的泛型类型，可能是和Integer平级的Double，甚至是更下级的数据类型，Integer无法安全的写入到泛型类型数据中。</li><li>下界：<code>? super Integer</code>，传入的泛型数据类型必须为Integer类或他的上级类。<strong>super下界允许在方法内调用泛型类的写入方法，但不允许泛型类读取类方法（除非使用Object类接受）</strong>，否则编译无法通过。<br>不能被读取的原因是，Integer类来接受，但是我们泛型类的读取方法，返回的类型会是任意上界类数据，Integer无法接收比他上级的类的；可以写入，因为泛型类的写入方法可以接受Integer类型。<br>总结就是，上界（extends）用于读取，下界用于写入（super），其实核心原因是因为Java向上转型安全，向下转型不安全的。通过上下界，可以更加精巧的设计API，让编译器来保证数据不被进行写入或读取等我们不想要的操作，Collections类中关于List复制的Copy方法就是源码中最好的一个实现，我们当然可以不用super或extends，但是会让你的API更加高级，健壮度更高。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>              <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i); <span class="hljs-comment">// src是producer</span><br>              dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="List类集合"><a href="#List类集合" class="headerlink" title="List类集合"></a>List类集合</h2><p>List类集合是用的最多的集合，相当于可变长的数组，元素有序可重复，当list里的元素是对象，如果要确保集合contains()方法的有效性，要重写对象equals()方法。</p><h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h4><p>ArrayList底层采用数组，从JDK 8开始，默认数组长度从10变到了0，由于底层是数组，所以ArrayList读取快，但在开头或者中间位置插入或删除数据，后面元素位置都要移动，所以相比于LinkedList，ArrayList整体进行增删的效率低一些，但是通常对集合开始和中间段的修改比较少，进行最多就是add和遍历，所以ArrayList仍然是使用最频繁的List。</p><p>ArrayList的线程是不安全的，容易出现两种情况：</p><ul><li>致元素覆盖和有元素为null值。add()方法中的<code>elmentData[size++] = e</code>导致</li><li>数据越界异常。add()方法中同时判断数组长度无需拓容</li></ul><h4 id="2-LinkedList（双向链表实现）："><a href="#2-LinkedList（双向链表实现）：" class="headerlink" title="2. LinkedList（双向链表实现）："></a>2. LinkedList（双向链表实现）：</h4><p>LinkedList底层采用双向链表，实现了Deque接口（双向队列），所以也就<strong>实现了队列</strong>（FIFO，先进先出线性表）<strong>和栈</strong>（LIFO，后进先出线性表）两种数据结构。插入和删除操作快，但读取遍历慢</p><p>LinkedList当成普通List来使用时，推荐使用add()&#x2F;remove()等方法；LinkedList当成stack栈使用时，push()栈顶压栈，pop()栈顶出栈；当成queue队列使用时，offer()队尾入队，poll()队头出队，peek()取列表头部元素；当成双向队列Deque使用时，可以操作两头，offerLast()&#x2F;offerFirst()，pollFirst()&#x2F;pollLast()。</p><h4 id="3-其他List接口实现类"><a href="#3-其他List接口实现类" class="headerlink" title="3. 其他List接口实现类"></a>3. 其他List接口实现类</h4><p>Vector类：相当于方法<strong>同步版的ArrayList</strong>，所以也是一种数组型的集合</p><p>Stack类：基于Vector类动态数组实现的Java栈类，有锁的开销，用Deque的实现类代替Stack类实现更高效率的栈</p><p>Deque接口，是Queue接口的子接口，的实现类有两个常用的，基于循环数组实现的<strong>ArrayDeque</strong>，和基于双向链表实现的<strong>LinkedList</strong></p><h2 id="Set类集合"><a href="#Set类集合" class="headerlink" title="Set类集合"></a>Set类集合</h2><p>当我们存储数据时，如果要求数据不能重复，或者需要存储大量数据，再或者需要进行很多的排序，这个时候用Set集合</p><h4 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h4><p>HashSet底层基于HashMap，也就是HashMap-Key的存储形式，可以当成没有value的HashMap。集合元素为自定义对象时，需要重写元素类的hashCode()和equals()方法，HashSet重写频率会比HashMap高，因为HashMap的key一般是String不需要重写，而HashSet有更大概率存储自定义实体类。</p><ul><li>重写hashcode()方法：可以取成员属性的值作为hashcode，如<code>this.name.hashcode()</code>。String的hashcode是通过String每一个字符✖️31计算。</li><li>重写equals()方法：参考String的写法，先判断内存地址，在instance of判断属于的类，再比较每个属性的值，如<code>this.name.equals(obj.name)&amp;&amp;this.no==obj.no</code></li></ul><p>HashSet add元素，首先根据hashCode值和数组的长度进行计算出存储的下标；如果下标的位置无元素，那么直接存储；如果有元素，那么使用要存入的元素和该元素进行equals方法，如果结果为真，哈希表对应位置上的Set元素被替换了（不管相不相等）；如果不相等，以链表形式新加节点存储。</p><h4 id="2-TreeSet"><a href="#2-TreeSet" class="headerlink" title="2. TreeSet"></a>2. TreeSet</h4><p>TreeSet基于TreeMap，存储形式为二叉树，适合大量数据的存储。</p><p>Tree类型的Set或者Map，都需要强制排序，意味着使用TreeSet存储类型为对象时，要么这个<strong>类继承Comparable接口，重写compareTo()方法</strong>；要么在<strong>实例化集合的过程中</strong>，构造方法传入一个的<strong>Comparator比较器对象</strong>。默认<code>o1-o2</code>这种形式呢，就是升序排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化Tree型集合，元素需要强制排序，使用Lambda表达式推断匿名内部类，然后实例化了一个Comparator对象 </span><br>TreeSet&lt;Student&gt; studentSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((o1, o2) -&gt; o1.getAge()- o2.getAge());<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_25827845/article/details/53870329">Java 8 String的compareTo()</a>：返回从左到右第一个不同的字符的ASCII码差，长字符和短字符相同，返回两个字符的length差。</p><h2 id="Map类集合"><a href="#Map类集合" class="headerlink" title="Map类集合"></a>Map类集合</h2><h4 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h4><p>HashMap是一个<strong>储存Entry对象的数组</strong>，在数组的基础上是链表+红黑树的组合（Java 8后）。HashMap插入hashcode相等并且equlas放回返回true的key值时，此时新<strong>Entry会替换</strong>老Entry元素，在HashMap体现为value值被替换，HashSet中元素被替换。而LinkedHashMap相比HashMap，底层用链表代替数组，按顺序存储，迭代顺序与存储顺序一致，而HashMap随机存储，也导致LinkedHashMap读写性能差一点。</p><p>HashMap底层是哈希表，值的位置是算出来的，数组桶的数量有限的，所以经过了扰动函数让哈希值尽可能的均匀，也会冲突，哈希表解决冲突有三种，再哈希法、开放寻址法和<strong>分离链表法</strong>，HashMap采用最后一种。</p><p>同ArrayList一样，在 Java 8后，只有当HashMap调用put()方法时，才将HashMap数组长度初始化为16；当链表长度大于等于8时，当前桶的链表将转成红黑树，红黑树元素小于等于6时，转化成链表，除此之外链表转红黑树实际还有一个隐性条件，就是Node数组长度要大于等于64，在64之前，会有限哈希表数组拓容</p><p>调用put()方法的源码过程：首先会调用扰动函数，右移使将高位值参与计算，让哈希值分布更均匀：<code>（h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>作为最后的哈希值，然后根据常规的哈希规则去插入，插入桶的位置通过按位与运算（取余运算）获取，即<code>index = hash&amp;(length-1)</code>，使得高位参与运算，等同于十进制取余hash%length。length-1&#x3D;2^n-1，二进制是n个1，这样取余，结果取决于hashcode，而不是链表，高位hashcode取余完全等于hashcode最后几位。</p><blockquote><p>[!question] 二进制运算复盘：右移和左移、按位运算、逻辑运算、异或运算的学习</p></blockquote><p>插入后，进行判断，当<code>++size &gt; thresholds</code>时（threshold等于capacity✖️loadfactory），执行resize()方法拓容，拓容2倍，反正数组的长度会是2的幂。拓容后调用transfer方法，将元素rehash到新数组中。<br>关于size++和++size的区别：++size会返回size+1后的值，而size++的返回值是size，虽然两者都实现了size加1，再执行判断或者返回的时候，请使用++size。</p><h4 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2. TreeMap"></a>2. TreeMap</h4><p>TreeMap就是一个树结构，每一个树节点都是Entry对象，Entry类型成员变量除了本身的key和value以外，还包括左节点、右节点和父节点三个同为Entry类型的成员变量，这样从根节点Entry对象开始，逐步递归存储，这种存储形式可以叫做“<strong>自引用</strong>”，自树和链表的数据结构中，经常使用。</p><p>TreeMap底层是红黑树（二叉查找树），自定义对象作为key时，需要重写compareTo()方法或者给TreeMap集合传递一个Comparator对象。需要排序时，用TreeMap结构，迭代器输出默认就是自然排序。在这里引申了解几个树相关的概念，满二叉树：一共有2^K-1个节点。完全二叉树：满二叉树基础上，只有h-1可以度小于2，只有一个叶必须在最左边。红黑树的性质：和前两种树一样也是一种二叉树，根和叶（NIL节点）是黑色节点，路径上两个红色节点点不能相连，<strong>根节点到所有NIL节点经过的黑色节点相同</strong>，这种规格使得树的高度维持，查询的最差时间复杂度控制在logn。</p><p>put()时源码解析：首先判断根是否为空，为空则将元素放到根节点，不是则元素从根节点开始compare()，如大于0，继续和根的右子树比较，直至取不到右子树了，就放到当前比较节点的右节点了，remove()整体流程也差不多，插入或者删除节点以后，会调用fixAfterInsertion()进行节点的变色、左旋和右旋完成红黑树调整。一般简单了解红黑树会进行变色、左旋（A左旋，相当于A变成右子节点的左节点，原右子节点的左节点变为A的右节点）、右旋是怎么回事就行了，详细的红黑树调整规则，插入后的调整规则已经清楚了，删除一般会转化成叶子节点，然后再用规则进行删除，如果想要详细了解调整规则，参考<a href="https://zhuanlan.zhihu.com/p/166319823">插入和删除后红黑树的修复</a>。</p><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><h4 id="并发Map"><a href="#并发Map" class="headerlink" title="并发Map"></a>并发Map</h4><p>高并发下的HashMap线程并不安全，高并发下，很多场景都会有线程安全问题，例如一个线程还未插入完成，另一个线程刚好resize到新的数组，元素可能就会覆盖；再比如rehash阶段两个线程并发可能会形成<strong>链表环</strong>，此时get()某元素到环状链表所在的桶，但并不存在equals相等的元素时，会出现死循环，会一直遍历链表去查找。</p><p>给每个Segment上锁，size()方法，所有segment的元素加起来，所有segment的修改次数加起来，Java 8已经不用segment了。</p><p><a href="https://zhuanlan.zhihu.com/p/31614308">ConcurrentHashMap</a>是高并发的，就使用HashTable（同步版HashMap，性能低较少使用）</p><p>ConcrrentHashMap用了Segment，将HashMap分块，降低了锁的粒度。</p><h4 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h4><p>不存储元素，只用于判断元素是否存在过。加入元素时，多个哈希函数计算后映射到位数组上的位置，值设置为“1”，判断元素是否存在过时，必须满足三个哈希值在位数组上的映射都为1。网络爬虫是一个最常见的场景，因为网页中有很多重复URL，需要判断是否已经爬取过。谷歌的Guava BloomFilter是一个常见的实现。</p><h4 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h4><p>创建集合是一个泛型类的实例化，<strong>在JDK 1.7以后，泛型类实例化，右边的构造方法不再需要指定泛型的类型</strong>，编译器会根据上下文推断类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>集合通过增强for和迭代器遍历集合。List和Set集合都继承自Collection接口，他们的实现类重写了Collection借口中的iterator()方法，所以他们都可以通过iterator()方法获取自身的迭代器；而Map的遍历，无法直接使用增强for或者iterator迭代器，需要现将map转化成**entrySet()、keySet()或values()**，然后再使用迭代器&#x2F;增强for，实现Map的循环</p><p>在增强for循环体中，不允许add或者remove元素，如果我们要在遍历过程中增删元素，需要使用迭代器提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>  System.out.println(iterator.next(););<br>  it.remove();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h4><p>List和Set集合需要排序，如果存储的元素本身就是支持排序的基础数据类型，直接调用Collections.sort()方法，就能对list&#x2F;set&#x2F;map集合实现排序；如果集合元素是对象，如果需要实现排序，就有两种方式</p><ol><li>使用两个参数的Collections.sort()重载方法，第二个参数中<strong>传入一个Comparator比较器，充血比较器的compare()方法</strong>，通常来说，会写成匿名内部类的实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>            &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>另一种方法是是<strong>对象类实现Comparable接口，重写compareTo()方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Student类中实现Comparable接口，重写compareTo方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age-o.age;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 使用排序</span><br>  List&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">3</span>));<br>  students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jackson&quot;</span>,<span class="hljs-number">5</span>));<br>  students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jessi&quot;</span>,<span class="hljs-number">1</span>));<br>  <span class="hljs-comment">// students集合将会被排序</span><br>  Collections.sort(students);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge/Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁和事务</title>
    <link href="/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/2.%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/2.%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>事务是一组原子性的SQL语句，MySQL中只有Innodb引擎才支持事务，锁是针对事务来说的，比如，在执行当前事务时，拿到了锁，才能进行update，事务提交。就释放了记录的锁。</p><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><p>InnoDB基本不使用表级锁，除了在Alter table时，会自动加上表锁，我们在SQL层面操作主要还是下面<strong>两种行锁</strong>，要注意的是，select默认情况下不加锁，update和delete默认加X排他锁。数据库锁以事务为单位，同一个事务下锁可重入，也就是说数据锁是可重入锁，主要有两种显示的悲观锁。</p><ol><li><strong>排他锁</strong>（X锁，Exclusive Lock）：for update。</li><li><strong>共享锁</strong>（S锁，Shared Lock）：lock in share mode</li></ol><p>除了常规行锁，还有两种隐藏的锁，一种是<strong>GAP间隙锁</strong>，例如对一个索引字段使用范围查询（如BETWEEN、&lt;、&gt;等），如SELECT … WHERE … FOR UPDATE ，会在索引区间上加上GAP间隙锁，不允许其他事务新插入或删除索引区间内的数据。</p><p>另一种是RR级别下独有的Next-Key锁，在以索引字段为条件，进行当前读&#x2F;update&#x2F;delete时，当前记录加入行锁，两边区间加入GAP间隙锁，统一形成叫Next-Key锁。你可以理解为在RR中，用索引进行update&#x2F;delete，会比RC级别形成更多GAP锁，RC级别只在用索引进行范围操作时产生GAP锁。</p><p>GAP间隙锁和Next-Key锁，都能降低当前事务出现“<strong>幻读</strong>”的几率，幻读是值指同一个事务内多次查询返回的结果集不一样，比如事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录。</p><p>对于数据库悲观锁，基于数据库版本号的乐观锁其实就是CAS乐观锁</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>由于MySQL事务是默认自动提交的，注意使用<code>SET AUTOCOMMIT=0</code>关闭MySQL事务自动提交。</p><p>另外MySQL DML可以像Oracle数据库一样隐式开启事务，但是更推荐使用BEGIN或者START TRANSCATION显式开启事务，保持更好的可读性，并使用COMMIT提交事务。</p><p>不同隔离级别下的加锁方式是不同的。<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">mysql事务下的锁机制(美团)</a></p><p>数据库事务遵循ACID的设计原则，即原子性（要么都执行，失败回滚）、隔离性（并发事务隔离）、一致性（一个状态转化另一个状态，但数据完整性一致）、持久性（事务完整，数据库改动是永久的）。</p><p>MySQL存在4中事务隔离级别，可以说是4种类型的事务等级，其中<strong>Innodb默认事务隔离级别是可重复度</strong>，实际上，数据库并发的优化，或者说这些隔离级别之间的差异，就是针对“读”。</p><ol><li><p>READ-UNCOMMITTED（未提交读）：任何情况都不加锁，也就意味着，事务没有提交，新值就可以被其他事务所读取，这就叫出现“<strong>脏读</strong>”。</p></li><li><p>READ-COMMITTED（提交读）：读不加锁，增删改加排他锁；不会再出现脏读，其他事务如果提交，当前事务就可能够读取最新的版本，这就是所谓的RC会出现“<strong>不可重复读</strong>”，也就是指“在一个事务内，多次读取同一数据可能会结果”。因为RC的MVCC（多版本并发控制），在每次<strong>快照读</strong>，都会生成一个基于当前已提交的生成新一致性视图，可能其他人进行了update或delete并提交了，造成两次读取不一致。</p></li><li><p>REPEATABLE-READ（可重复读）：<strong>读不加锁，增删改加排他锁</strong>；RC的MVCC在快照读在第一次读，就生成了一个全局的一致性视图，这就不会再出现“不可重复读”。</p></li><li><p>SERIALIZABLE（串行化）：完全使用悲观锁，读用读锁，写用写锁。解决了幻读的问题</p></li></ol><p>为了防止数据库死锁有几种措施，比如事务之间保持数据更新的顺序；业务允许的情况下，尽量降低事务的粒度，或者降低事务级别到RC级别，防止gap锁造成死锁；添加合理的索引，不走索引会全表加GAP锁，更容易死锁。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几种常见查找日志命令的比较</title>
    <link href="/2023/02/23/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/7.%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/"/>
    <url>/2023/02/23/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/7.%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>推荐使用：</p><ol><li><p><code>tail -f -n 20 file</code>，-f实时查看，-n 20是查看末尾20行，不加-n默认是只看10行</p></li><li><p><code>less -N file</code>，分页打开文件，-N表示显示行号，然后使用<code>/keyword</code>匹配关键字。less也支持像tail命令一样实时查看日志<code>less +F file</code></p><ul><li>匹配关键字后，n查找下一个匹配，N查找上一个匹配。</li><li>分页操作：space下翻一页、b上翻一页、上翻一行(↑) 下翻一行（↓）、跳转末尾G、跳转开头g</li></ul></li><li><p><code>grep -C 10 &quot;keyword&quot; file</code>，大日志查看时，效率最高的，而且支持递归查找文件，如果要打印行号，可以加-n参数，注意tail和grep是-n，less是-N</p></li></ol><p>低频率使用:</p><ol><li><code>cat file ｜ grep &quot;keyword&quot;</code>，打印文件在控制台。只适合直观查看小文件，用管道搭配grep效率低，且无法利用grep的多个参数精确查找，直接用grep就可以。</li><li>vi&#x2F;vim打开日志文件，然后使用<code>/keyword</code>匹配关键字，匹配后n查找下一个匹配的关键字，N查找上一个匹配，使用与less类似，但要加载整个文件，less翻页更方便。</li><li>head file 头10行，more和less类似，但不支持往前看，也基本不用于查找日志</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库加索引</title>
    <link href="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>数据库有3种方式创建索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 这种方式建立索引最简单，但是表中需要有数据，否则索引建立失败<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> lmt_crdt_app <span class="hljs-keyword">ADD</span> INDEX idx_cust_name(cust_name);<br># 通过<span class="hljs-keyword">create</span> INDEX<br><span class="hljs-keyword">CREATE</span> INDEX idx_cust_name <span class="hljs-keyword">ON</span> lmt_crdt_app(cust_name);<br># 可以在建表时，在所有字段的最后，加上索引 INDEX idx_cust_name(cust_name);<br></code></pre></td></tr></table></figure><p>最常见的是普通索引（<strong>INDEX</strong>），上面代码中创建的就全是普通索引</p><p>还有一种索引是唯一索引（<strong>UNIQUE INDEX</strong>），创建唯一索引在普通索引的INDEX前加一个UNIQUE标识就行了。他的值必须要唯一，如给“电子邮件”这个字段加上唯一索引，那么每一个电子邮件都不能够重复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用brew去管理一些后台进程</title>
    <link href="/2022/03/24/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/6.brew/"/>
    <url>/2022/03/24/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/6.brew/</url>
    
    <content type="html"><![CDATA[<p>brew对于命令行的程序，起到一个打包编译的作用，ARM版的brew通常只能安装ARM版的程序。</p><p>brew常用的命令brew list&#x2F;search&#x2F;info&#x2F;intall&#x2F;unintall&#x2F;deps&#x2F;outdated&#x2F;update&#x2F;upgrade等。</p><p>在命令前加入<code>arch -x86_64</code>模拟x86环境运行。</p><p>建议brew安装mysql&#x2F;redis，且推荐安装以后使用<code>brew services</code>来管理服务的启动和关闭。以mysql为例，<code>brew services start mysql</code>和<code>mysql.server start</code>同样可以启动mysql，要注意brew的启动在重启后不会失效，使用brew有利于统一多服务的管理。</p><h3 id="macOS多版本-node"><a href="#macOS多版本-node" class="headerlink" title="macOS多版本 node"></a>macOS多版本 node</h3><p>可以使用nvm和n这样常用的node管理工具来管理安装，也可以使用node link&#x2F;unlink不同的node版本</p>]]></content>
    
    
    <categories>
      
      <category>Mac相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GIT要注意的几个问题</title>
    <link href="/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/4.GIT/"/>
    <url>/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/4.GIT/</url>
    
    <content type="html"><![CDATA[<p>Git的commit版本是整个库的版本，不是单独具体到某个文件的版本，处于不同commit的文件，可能就是相同的。</p><p>Git有三大分区，工作区、暂存区和版本库。文件add后，存在于stage区中（暂存区），通过commit到版本库。</p><h4 id="关于切换分支的问题"><a href="#关于切换分支的问题" class="headerlink" title="关于切换分支的问题"></a>关于切换分支的问题</h4><p>切换分支时，如果暂存区中有文件在修改，会有两个情况。第一种是两个分支里的文件内容相同时，checkout切换分支会将暂存区中的修改内容保留；第二种情况是两个分支里的文件就不同时，会提示禁止checkout（-f 强制切换时，会丢失修改内容），此时不想commit，可以使用<code>git stash push</code>，临时存储暂存区修改，push通常省略，使用<code>git stash pop</code>恢复最后一次stash的暂存区。</p><h4 id="pull、push"><a href="#pull、push" class="headerlink" title="pull、push"></a>pull、push</h4><p>pull相当于fetch+merge操作。</p><p>本地和远程的相同分支，本质上是两个分支，pull相当于现将远程分支merge到本地merge，合并规则和本地之间的不同分支是相同的。</p><p><strong>与远程分支同步时</strong>，如果本地有暂存区修改，一定要<strong>先commit，再pull，再push</strong>。</p><p>merge过程中，暂存区不会修改，IDEA的merge过程，远程分支别人已经修改过一版，此时pull正常merge到本地，再commit，可能会将别人的代码覆盖而Git不会出现任何提示，而先commit，再pull，过程中Git会提示解决冲突。本地解决完冲突后，最好再次pull，再push。</p>]]></content>
    
    
    <categories>
      
      <category>GIT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/5.HTTP/"/>
    <url>/2022/03/09/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/5.HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP报文由起始行、头部、正文三部分组成，请求报文的起始行教请求行，响应报文的起始行叫状态行，然后头部和正文之间有空行。</p><p>请求报文：</p><p>响应报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Server: nginx<br>Date: Mon, <span class="hljs-number">20</span> Feb <span class="hljs-number">2017</span> 09:<span class="hljs-number">13</span>:<span class="hljs-number">59</span> GMT<br>Content-Type: text/plain;charset=UTF-<span class="hljs-number">8</span><br>Vary: Accept-Encoding<br>Cache-Control: no-store<br><br>&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>无连接</strong>；即请求时连接，返回响应就释放连接。多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消。</p></li><li><p><strong>无状态</strong>：每个HTTP请求是独立的，服务器不会记住之前的请求和响应的状态。所以用<strong>Cookie和Session</strong>来模拟状态信息。</p></li></ol><p>Cookie：会话保存在客户端，Cookie只能保存是字符串（4KB），切勿保存重要数据，<strong>默认浏览器关闭时清除session</strong>，除非服务端设置setMaxAge。一个cookie对象中最重要的成员变量就是name和value，在Javaweb中，使用request.getCookies()获得一个cookie数组，request.getName()获得cookie的name，getValue获得cookie的value</p><p>Session：会话保存在服务器，在调用getSession时创建，判断cookie中有无sessionid，无就生成sessionID，定义一个会话状态，并将sessionid通过Cookie发送给浏览器。</p><p>restful的前后端分离项目中一般会使用 access_token，因为前后端分离项目跨域，使用cookie里的sessionID不方便认证状态，这个token和session_id是一个意思。<a href="https://juejin.im/entry/5bd921fce51d45686d40b2d6">分离Cookie参考</a></p><p><a href="https://blog.csdn.net/hxfghgh/article/details/82840613">关于Cookie</a></p><h4 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1. HTTP 请求报文"></a>1. HTTP 请求报文</h4><p>请求行–HTTP头字段–空行–正文</p><ol><li>**GET请求：放在请求行(URL)**，会暴露在地址栏，有长度限制，会被主动Cache，只有默认编码。</li><li><strong>POST请求：放在报文体</strong>，无长度限制，可以传输中文。POST请求也可以在请求行中写入数据，这时候类似GET请求，但一般没人会在form action或ajax url中加入这种处理</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html?name=kelvin&amp;password=123456</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,en;q=0.6<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br><span class="language-ini"></span><br></code></pre></td></tr></table></figure><h4 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2. HTTP 响应报文"></a>2. HTTP 响应报文</h4><p>状态行–HTTP响应头–空行–正文（body）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-HTTP-Header"><a href="#3-HTTP-Header" class="headerlink" title="3. HTTP Header"></a>3. HTTP Header</h3><p>HTTP Header中有四种Header Filed：</p><p>通用头：请求头和响应头都可使用字段</p><p><strong>Cache-Control</strong>、Pragma、Date、Via</p><p>Connection：keep-alive&#x2F;close</p><p>实体头：用于定义Entity Body（数据）的一些信息的头字段</p><p>Location（重定向跳转就设置了这个）、</p><p><strong>Content-Type</strong>、Conetent-Encoding（响应内容的压缩）、</p><p>Expire、Allow、Etag（资源标识符）、Last-Modify</p><p><strong>请求头：</strong></p><p>User-Agent、Host、Referer、<strong>Accept</strong>（希望接收的类型）</p><p><strong>响应头：</strong></p><p>Age（在代理服务器中缓存秒数）、Server（提供服务器信息）、Vary</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP缓存也称为Web缓存，主要就是客户端本身的<strong>浏览器本地缓存</strong>和代理服务器缓存（正向代理和反向代理）。<strong>只能缓存GET请求</strong>的内容，缓存css、js、HTML等静态资源</p><p><a href="https://juejin.im/post/5c417993f265da61285a6075">缓存Cache-Control参考</a></p><p>在HTTP1.0时代，pragma和Expires两个头字段可以设置缓存策略。</p><p>到了HTTP1.1以后，又有<strong>Cache-Control</strong>设置缓存策略，HTML meta、动态网页中可以设置。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span>：允许客户端和代理服务器缓存<br><br>private（<span class="hljs-keyword">GET</span>请求默认）：允许客户端缓存<br><br>**<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>**：允许客户端缓存，但每次快取需要由服务器请求缓存是否过期，未过期返回<span class="hljs-number">304</span>。协商缓存<br><br>**<span class="hljs-keyword">no</span>-store：不允许缓存。**<br><br>**max-age=<span class="hljs-number">60</span>**：允许缓存保留<span class="hljs-number">60</span>秒（自带<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>），没有这个属性就会去查找expire。强缓存<br><br>must-revalidate<br></code></pre></td></tr></table></figure><p>这些设置缓存的头字段时通用头字段，当request和response都设置时，Apache或nginx等服务器可以设置听哪个request还是response的。</p><p><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/">浅谈在代理环境中的 DNS 解析行为</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/</url>
    
    <content type="html"><![CDATA[<p>mybatis是一个简单工具根据项目调整编写风格。如何写resultmap也是一个比较简单的，模仿性很强的，学习更好的代码。</p><p>mybatis的作用，我认为最关键的就是结果集映射，将数据库结果集，映射到实体类。两种形式resultType和resultMap。mybatis能算得上是最好的方式吗？</p><h4 id="一对一关联association"><a href="#一对一关联association" class="headerlink" title="一对一关联association"></a>一对一关联association</h4><p>对象一对一依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.Emp&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1. 通过左外连接，连接子表的结果返回到这个association的resultMap里。</span><br><span class="hljs-comment">  如果返回的结果用association中用自定义的映射代替resultMap，association要带一个javaType属性，代表属性类型--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Departments.deptMap&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 2. 通过嵌套查询，将查询的结果返回到这个里面来 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;department_id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;Departments.selectById&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="一对多关联Collection"><a href="#一对多关联Collection" class="headerlink" title="一对多关联Collection"></a>一对多关联Collection</h4><p>对象一对多依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1. 需要在collection里指定resultMap（可以自定义）和ofType，接受左外连接传来的数据</span><br><span class="hljs-comment">使用连接查询，里面不能使用分页，否则collection里数据截断。</span><br><span class="hljs-comment">默认javatype是List，可省略List</span><br><span class="hljs-comment">如果ResultMap的type写util.Map(很少)的话，此时必须指定collection的JavaType--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.mybatis.model.RoleInfo&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;entity.Menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createdate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modifydate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifydate&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select <br>  ram.roleid as id,<br>  ro.name as name,<br>  me.id as menuid,<br>  me.name as menuname,<br>  me.description,<br>  me.parent,<br>  me.createdate,<br>  me.modifydate <br>  from roleandmenu ram<br>  left outer join role ro on ram.roleid=ro.id<br>  left outer join menu me on ram.menuid=me.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 使用嵌套查询，会用column指定的列，作为第二次查询的参数，在这个查询里指定resultType或者ResultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;entity.Role&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select id,name from role<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.mybatis.model.Menu&quot;</span>&gt;</span><br>  select m.id,m.name<br>  from menu m join roleandmenu ram on m.id=ram.menuId<br>  where ram.roleId=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mahoking/article/details/46811865">批量增删改</a></p><h4 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h4><p>mysql<a href="https://blog.csdn.net/mytt_10566/article/details/74279105">主键自增长</a>生成：使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”Employee_id”**，在SQL语句中不写自增长字段。</p><p>可以不用<a href="https://blog.csdn.net/death05/article/details/53098328?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">trim</a>，插入为空就不插入了，但是要指定jdbcType。用trim+if判断空值，不需要指定jdbcType。批量插入parameterType依然写类（类地址？）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;department_id&quot;</span>&gt;</span> <br>  insert into departments(default, department_name) values (#&#123;department_id&#125;,#&#123;department_name&#125;) <br>  // 或者insert into departments(department_name) values (#&#123;department_name, jdbcType=varchar&#125;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="update元素"><a href="#update元素" class="headerlink" title="update元素"></a>update元素</h4><p>不修改的值保持原值，传入一个对象。字符串写判断是否为空字符串或null，传入对象时要带其id</p><p><strong>基本数据类型和对象等数据只需要判断是否为null</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Employee&quot;</span>&gt;</span><br>update employee <br>  //set同样会帮我们忽略最后的“，”<br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    //注意if中的first_name是对象中，不是数据库中<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt;</span><br>      first_name = #&#123;first_name&#125;,<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary!=null &quot;</span>&gt;</span> <br>      salary = #&#123;salary&#125;, <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span> <br>  where employee_id = #&#123;employee_id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="元素"><a href="#元素" class="headerlink" title="&lt;delete&gt;元素"></a>&lt;delete&gt;元素</h4><p>一般使用单ID删除，可以在service层循环ID，带调用单删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parametertyep</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>delete from employee where employee_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int[]&quot;</span>&gt;</span> <br>  delete from employee where employee_id in <br>  <span class="hljs-comment">&lt;!-- collection只能写array或者list，即数组或集合，但是orderIDs --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="元素-1"><a href="#元素-1" class="headerlink" title="&lt;select&gt;元素"></a>&lt;select&gt;元素</h4><p>条件查询，用Map&lt;String, Object&gt;作为传入参数，可以不写parameter</p><p>where 1&#x3D;1？</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;mapper namespace=<span class="hljs-string">&quot;com.lee.Mapper.Employee&quot;</span>&gt;<br>  &lt;select id=<span class="hljs-string">&quot;select&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;Employee&quot;</span>&gt; <br>    select * from employee e left outer join Dept d on e.deptno=d.deptno<br>    <span class="hljs-comment">// 可以用where，mybatis会自动帮我们忽略</span><br>    &lt;trim prefix=<span class="hljs-string">&quot;where&quot;</span> prefixOverrides=<span class="hljs-string">&quot;and | or&quot;</span>&gt; <br>      &lt;!-- first_name是Map中的Key，用#&#123;first_name&#125;获取到value --&gt; <br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> #&#123;first_name&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;job_id!=null and job_id!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">job_id</span> <span class="hljs-operator">=</span> #&#123;job_id&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt; <br>    &lt;/trim&gt; <br>&lt;<span class="hljs-type">if</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;index!=null&quot;</span>&gt;<br>      limit #&#123;index&#125;,#&#123;pageSize&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt; <br>  &lt;/select&gt;<br>  &lt;!-- 计数--&gt;<br>  &lt;select id=<span class="hljs-string">&quot;count&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>    select <span class="hljs-title function_">count</span><span class="hljs-params">(*)</span> from employee<br>    &lt;where&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;firstName !=null and firstname!=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> # &#123;firstName&#125;<br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>  &lt;/select&gt;<br>  <br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h4 id="SQL块"><a href="#SQL块" class="headerlink" title="SQL块"></a>SQL块</h4><p>用SQL块代替常用于字段，一个表中的字段可能很多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empSql&quot;</span>&gt;</span><br>  first_name,job_id,salary,department_id <br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--字段用include动态SQL块代替，类似于alias --&gt;</span><br>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empSql&quot;</span>/&gt;</span> from employe<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js的函数和方法的区别</title>
    <link href="/2021/04/12/front/3.js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/12/front/3.js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天偶尔看到，JS中的函数和方法这两个概念竟然有些许差别😅，在我印象中，大部分编程语言里，函数和方法没有任何区别，大概的意思就是通过名字调用的一段代码，只是C&#x2F;C++中，习惯称为函数（function），Java中习惯称方法（method），而在JS中，我们知道也习惯称function，即函数。</p><p>在vue.js中，经常的一种写法就是，将函数绑定到对象上，大概就是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-attr">getMessage</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>getMessage</code>就是对象hua的一个函数，更确切的，这种<strong>绑定到对象上的函数就是方法</strong>，需要通过<code>hua.getMessage</code>或者<code>hua.getMessage()</code>去调用。ES6对于书写这种函数，推荐写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>今日学习随机</title>
    <link href="/2021/03/30/front/2.js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/03/30/front/2.js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>声明变量作用域方面，var定义的变量作用域是函数级，但是代码块里声明的var变量，代码块外又允许访问（所以var有很多不合理的地方）。let是升级版的var，用来代替var，作用域为标准的代码块级。const是代码块级作用域的常量。</li><li>var能够重复声明变量，而let和const不允许被重复声明。</li><li>并且var声明的变量存在<strong>变量提升</strong>，即在用var声明变量代码之前，函数就可以调用这个变量，默认值为undefined，而let&#x2F;const声明的变量，则会提示变量not defined（let）或者error（const）。</li></ol><h2 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h2><p>在模块化出现之前，js通过script标签直接引入另一个js，引入顺序必须固定，而维护成本高，现在主要的两种js模块化规范。</p><ul><li><p>Common JS模块化规范（nodejs）：require&#x2F;exports</p></li><li><p>ES6模块化规范：<a href="https://www.jianshu.com/p/541256d8abb3">import&#x2F;export</a>。</p></li></ul><p>export你需要导出的变量或者函数，import时需要带{}，而export default导出的变量不需要带{}。export可以导出未声明变量或者函数，export default只能导出已声明的变量、函数、或者匿名模块，一个文件中只能使用一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> name;<br><span class="hljs-keyword">export</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  data : &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br>---<br>b.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">import</span> random,&#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(random.<span class="hljs-property">data</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>在学习vue或者初次看到vue项目时，有一些疑问，比如vue组件、实例、vue文件之间的区别是什么new Vue()操作产生vue实例，组件类似于是可被Vue实例反复引用的。</p><p>vue组件是可复用的vue实例。类似于自定义标签，template属性为编写组件的必须项，props和data属性也较为常用。</p><p>注意编写vue组件时，因为html的自定义属性不能大写，会自动转化成小写，所以注册组件props中的变量，要用小写。</p><p>Vue.component()方法用于全局注册的vue组件，全局组件可以用于所有文件中的new Vue()创建的Vue根实例</p><h3 id="JS驱动vue-js"><a href="#JS驱动vue-js" class="headerlink" title="JS驱动vue.js"></a>JS驱动vue.js</h3><p>此时Vue实例用el元素直接绑定HTML。引入vue.js文件，通过js去直接驱动。用component注册全局组件，组件包含template。</p><p>template中的内容是需要有根节点的</p><h5 id="模块化驱动vue-js"><a href="#模块化驱动vue-js" class="headerlink" title="模块化驱动vue.js"></a>模块化驱动vue.js</h5><p>在js文件中可以import单Vue文件，将Vue文件渲染到的Vue实例上，挂载到指定的HTML上。一般模块化开发中我们只写一个vue根实例。</p><h5 id="单文件组件的优势"><a href="#单文件组件的优势" class="headerlink" title="单文件组件的优势"></a>单文件组件的优势</h5><p>模版语法高亮、全局定义命名不能重复、不支持CSS，而单文件的设置stype的scope属性，css只对单文件生效</p><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><ul><li>默认插槽和具名插槽</li></ul><p>将内容分发权限放到调用的父级，将复杂内容放到父级。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">--- vue 2.6之前:<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>--- vue 2.6后:<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:pre-icon</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中预设位置<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>作用域插槽</li></ul><p>让父组件访问子组件的值的一种插槽，弥补父组件无法获取到子组件变量值的情况。</p><p>（具名&#x2F;默认插槽）和（作用域插槽）是并列关系，是同时可以使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">--- 父组件从子组件中取数据，vue 2.6之前<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>--- vue 2.6后<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中slot绑定变量<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="compute、method、watch"><a href="#compute、method、watch" class="headerlink" title="compute、method、watch"></a>compute、method、watch</h5><p>计算属性能做的，watch都能做。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用npm和yarn遇到的问题</title>
    <link href="/2021/03/29/front/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/29/front/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="使用npm和yarn遇到的问题"><a href="#使用npm和yarn遇到的问题" class="headerlink" title="使用npm和yarn遇到的问题"></a>使用npm和yarn遇到的问题</h4><ol><li><p>关于包管理器npm和yarn</p><p>yarn是在npm的基础之上的包管理器，根据情况选用一个工具即可，都是去读取package.json文件，在一个项目中两者可以同时存在，但是每次构建项目后（初次npm install后），需要固定使用yarn，或者或者npm，当要切换包管理器管理项目时，需要删除node_modules文件夹。</p><p>不同版本的npm管理同一个项目，一般不会出现太大的问题，但是遇到构建问题时，也可以选择删除node_module文件夹和package-lock.json文件。</p><p>遇到一个问题，npm 7构建node旧项目时，会出现构建依赖树冲突问题。</p></li><li><p>node-sass在离线机器上的安装问题</p><p>node-sass还会绕过设置的本地仓库去GitHub去获取，获取不到时会在本地编译，本地编译在win下又依赖python和C++环境，这个问题给我整吐了，怎么也不好解决，尝试过多种方法也无济于事后，找同事在能运行的机器上，拷贝了整个项目先启动看看，后期再去解决npm install安装的问题。</p></li><li><p>vue-cli工具：vue-cli、@vue&#x2F;cli。</p><ul><li>vue init webpack demo。npm run dev</li><li>vue create demo。@vue&#x2F;cli构建的项目，会在本地加入vue-cli-serivice这样的依赖npm serve</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传下载</title>
    <link href="/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>表单上传：type为file类型的input标签<strong>和enctype&#x3D;multipart&#x2F;form-data</strong>上传数据，不做处理，是同步上传。</p></li><li><p>ajax上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#myinput&quot;</span>).<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-comment">// 这两个必写</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>($(<span class="hljs-string">&#x27;#uploadForm&#x27;</span>)[<span class="hljs-number">0</span>]),<br><span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-Servlet纯流方式-SmartUpload或Apache-FileUpload"><a href="#1-Servlet纯流方式-SmartUpload或Apache-FileUpload" class="headerlink" title="1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload"></a>1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload</h4><p>Servlet直接读区获取字节流存储在文件夹，但是无法同时区分普通控件和上传文件</p><p>在Servlet中都能实现上传文件功能简化，实现业务数据和上传的文件同时获取，并且直接write（不需要手动outputStream）</p><p><a href="https://www.jianshu.com/p/e7837435bf4c">FileUpload文件上传参考</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">// 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isMultipart</span> <span class="hljs-operator">=</span> ServletFileUpload.isMultipartContent(req);<br>  <span class="hljs-comment">// 如果不满足要求就立即结束对该请求的处理</span><br>  <span class="hljs-keyword">if</span> (!isMultipart) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// FileItem 是表单中的每一个元素的封装</span><br>    <span class="hljs-comment">// 创建一个 FileItem 的工厂类</span><br>    <span class="hljs-type">FileItemFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskFileItemFactory</span>();<br>    <span class="hljs-comment">// 创建一个文件上传处理器（装饰设计模式）</span><br>    <span class="hljs-type">ServletFileUpload</span> <span class="hljs-variable">upload</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletFileUpload</span>(factory);<br>    <span class="hljs-comment">// 解析请求</span><br>    List&lt;FileItem&gt; items = upload.parseRequest(req);<br>    <span class="hljs-keyword">for</span> (FileItem fileItem : items) &#123;<br>      <span class="hljs-comment">// 判断空间是否是普通控件</span><br>      <span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;<br>        <span class="hljs-comment">// 普通控件</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 上传控件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> fileItem.getContentType();<br>        <span class="hljs-keyword">if</span> (!contentType.startsWith(<span class="hljs-string">&quot;image/&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 实现简单的错误提示</span><br>          req.setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;亲，您上传的文件格式不正确，请重新上传！&quot;</span>);<br>          req.getRequestDispatcher(<span class="hljs-string">&quot;upload.jsp&quot;</span>).forward(req, resp);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果不是图片类型则不再对请求进行处理</span><br>        &#125;<br>        <span class="hljs-comment">// 随机命名文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + <span class="hljs-string">&quot;.&quot;</span> + FilenameUtils.getExtension(fileItem.getName());<br>        <span class="hljs-comment">// 将上传的文件保存到服务器</span><br>        fileItem.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:/&quot;</span>, fileName));<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件上传"><a href="#2-SpringMVC文件上传" class="headerlink" title="2. SpringMVC文件上传"></a>2. SpringMVC文件上传</h4><p>SpringMVC的上传功能封装了FileUpload组件的功能</p><ol><li>配置FileUpload和common-io的依赖、在SpringMVC配置文件中配置MultipartResover（上传解析器）</li><li>SpringMVC Controller：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span><br><span class="hljs-comment">// 使用MultipartFile类，String ename是其他控件信息，request用于获取绝对路径</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile img, Emp emp ,String ename, HttpServletRequest request)</span>&#123;<br><span class="hljs-comment">// img存储到文件夹相对路径(Web程序的部署路径)</span><br><span class="hljs-comment">//1. 获得上传文件的名字,方便在下载时还原这个名字（3.jpg）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> img.getOriginalFilename(); <br><span class="hljs-comment">//.当前应用程序的部署绝对路径下的upload文件夹</span><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-comment">// 判断文件夹是否存在</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br><span class="hljs-keyword">if</span>(!file.exists())&#123;<br>file.mkdir(); <br>  &#125;<br> <br>  <span class="hljs-comment">//3.应付存储文件的名字重复，为文件重命名</span><br>  <span class="hljs-comment">// 先获得文件的后缀名</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">extendsName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>); <br>  <span class="hljs-keyword">if</span>(index!=-<span class="hljs-number">1</span>)&#123;<br>  extendsName = name.substring(index); <br>  &#125;<br>  <span class="hljs-comment">// 生成唯一的名字</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extendsName; <br>  <br>  <span class="hljs-comment">//4.MultipartFile.transferTo方法代替流输入</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file,fileName);<br>  <span class="hljs-keyword">try</span> &#123;<br>    img.transferTo(savePath); <br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(); <br>  &#125;<br><span class="hljs-comment">// 5 存储数据库，这个照片是员工的属性</span><br>  <span class="hljs-comment">// 保存到相对路径</span><br>  emp.setFilePath(<span class="hljs-string">&quot;/upload/&quot;</span>+fileName); <br>  emp.setFileName(name);<br>empService.save(emp);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件下载："><a href="#文件下载：" class="headerlink" title="文件下载："></a>文件下载：</h2><p>a标签在h5的download属性可以通过URL访问到，单独的用控制器下载其实比价少用，真的用的时候可以用流下载</p><p>FormData两种方式定义，append(“myimage”, $(“#myfile”).get(0).files[0]) ）<a href="https://harttle.land/2016/07/04/jquery-file-upload.html">异步上传</a></p><p>cache、processData和contentType为false，防止JQ转码</p><h4 id="1-Servlet纯流方式"><a href="#1-Servlet纯流方式" class="headerlink" title="1. Servlet纯流方式"></a>1. Servlet纯流方式</h4><p><a href="https://www.jianshu.com/p/f450da30f594">纯流文件下载参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">String dataDirectory=req.getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/data&quot;</span>);<br><span class="hljs-comment">// 通过service查询到</span><br>File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dataDirectory, <span class="hljs-string">&quot;secret.pdf&quot;</span>);<br><span class="hljs-keyword">if</span>(file.exists())&#123;<br>  resp.setContentType(<span class="hljs-string">&quot;application/pdf&quot;</span>);<br>  resp.addHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=secret.pdf&quot;</span>);<br>  <span class="hljs-type">byte</span>[] buffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>  FileInputStream fis=<span class="hljs-literal">null</span>;<br>  BufferedInputStream bis=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span>&#123;  <br>    <span class="hljs-comment">// BufferInputStream每次读一块字节相比读一个字节对于文件速度更快。</span><br>    fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>    bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    <span class="hljs-type">int</span> i=bis.read(buffer);<br>    <span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>      os.write(buffer,<span class="hljs-number">0</span>,i);<br>      i=bis.read(buffer);<br>    &#125;<br>  &#125;<span class="hljs-keyword">catch</span>(IOException ioe)&#123;<br>    System.out.println(ioe.toString());<br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-keyword">if</span>(bis!=<span class="hljs-literal">null</span>)&#123;<br>      bis.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fis!=<span class="hljs-literal">null</span>)&#123;<br>      fis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件下载"><a href="#2-SpringMVC文件下载" class="headerlink" title="2. SpringMVC文件下载"></a>2. SpringMVC文件下载</h4><p> 使用spirng 自带的<strong>ResponseEntity</strong>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException&#123;<br>  <span class="hljs-comment">//获取你文件的文件夹，一般从数据库读区，这里模拟service已经取到路径</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getSession().getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1168701023208865792.jpg&quot;</span>; <br>  <span class="hljs-comment">// 1. 获取文件路径</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path,filename); <br>  <span class="hljs-comment">//设置header里的ContentDisposition字段，以attachment(下载框方式)打开图</span><br>  <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>(); <br>  headers.setContentDispositionFormData(<span class="hljs-string">&quot;attachment&quot;</span>, downloadFielName);<br>  <span class="hljs-comment">// 2. ResponseEntity返回，返回application/octet-stream : 二进制流数据(最常见的文件下载)。</span><br>  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-type">byte</span>[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/10/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/2.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/10/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/2.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>^a以a开始</p><p>a$以a结束</p><h4 id="字符代表符号（匹配符）"><a href="#字符代表符号（匹配符）" class="headerlink" title="字符代表符号（匹配符）"></a>字符代表符号（匹配符）</h4><p>[a-z]小写字母、[a-zA-Z0-9]字母和数字</p><p>. 除换行符以外的任意单字符</p><p>\d数字。</p><p>\D非数字</p><p>\w数字，字母或下划线</p><p>\s特殊字符</p><h4 id="数量限定符"><a href="#数量限定符" class="headerlink" title="数量限定符"></a>数量限定符</h4><p>{5}： 前面的一个字符出现5次{1,}：1次以上。{1,3}：1次到3次</p><p>*前面的一个字符出现0次以上</p><p>+前面的一个字符出现1次以上</p><p>？前面的一个字符出现0次或1次</p><h3 id="前瞻和后顾"><a href="#前瞻和后顾" class="headerlink" title="前瞻和后顾"></a>前瞻和后顾</h3><p>正则表达的前后，还未解析字符的称为前面，解析过的称为后面</p><p>a(?&#x3D;b)前瞻，匹配a，且a必须在b的前面</p><p>a(?!b)负前瞻，匹配a，且a的前面不是b</p><p>(?&lt;&#x3D;b)a后顾，匹配a，且a的后面b</p><p>(?&lt;!b)a负后顾，匹配a，且a的后面不是b</p><p>|分成两段，或者</p><p>()圈定一个子串</p><h2 id="JS使用正则表达式"><a href="#JS使用正则表达式" class="headerlink" title="JS使用正则表达式"></a>JS使用正则表达式</h2><p><strong>var regexp &#x3D; &#x2F;正则表达式&#x2F;修饰符</strong>，</p><p>修饰符有i（不区分大小写）和g（全局匹配）</p><p><strong>匹配：regexp.test(str)</strong></p><h2 id="Java使用正则表达式"><a href="#Java使用正则表达式" class="headerlink" title="Java使用正则表达式"></a>Java使用正则表达式</h2><p>Pattern.complile(“”)创建正则对象</p><ul><li><p>匹配验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^[0-9a-zA-Z]\\.&#123;5,10&#125;@[0-9a-zA-z]&#123;2,7&#125;(\\.com|.cn)&quot;</span>)<br>p.matcher(str).matches() <span class="hljs-comment">//Match对象</span><br></code></pre></td></tr></table></figure></li><li><p>以一个正则表达式拆分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br>String[ ] s = p.split(str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>  System.out.print(s[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>  结果为ABCDEF<br></code></pre></td></tr></table></figure></li><li><p>替换里面的字符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(str);<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> m.replaceAll(<span class="hljs-string">&quot;-&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本编码</title>
    <link href="/2020/10/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/1.%E7%BC%96%E7%A0%81/"/>
    <url>/2020/10/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/1.%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>通常所说的乱码问题，是指文本文件乱码（非二进制文件），文本乱码的本质是解析的字符编码与文本本身字符编码不匹配导致的。</p><h2 id="1-字符集和字符编码"><a href="#1-字符集和字符编码" class="headerlink" title="1. 字符集和字符编码"></a>1. 字符集和字符编码</h2><ol><li><p>文本文件：通过字符编码（如UTF-8）保存的文件，如数字64，文本文件会将64解析成’6’和’4’两个字符，再根据字符集编码，再存储到硬盘中</p></li><li><p>二进制文件（狭义上的非文本文件）：保留数据本身二进制的文件，数字64，如Java的int型数字64，直接储存64的二进制到硬盘中</p></li></ol><p>字符集规定了字符在字符表的位置，在文本文件的存储过程中，文本会依靠字符集规则转化成字符，其中最著名的就是ASCII字符集和Unicode字符集。</p><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>ASCII既是世界上第一个字符集（charset），同时又规定了字符编码（encoding）。</p><p>ASCII字符编码用一个字节（7位容器）来表示一个字符，ASCII中一共有127个字符（0-126）。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>地球上字符太多，ASCII字符集的单字节无法表示，所以出现了Unicode字符集。最初时UTF-16编码来实现Unicode字符集，用2个或4个字节来保存。</p><ul><li><p>UTF-16：用两个或者四个字节（<strong>Java char类型用的2字节的UTF-16 LE</strong>），四字节称为UTF-16 BE</p></li><li><p>UTF-32：用四个字节</p></li><li><p>UTF-8：1～4个字节，1个字节时与ASCII编码相同，常见<strong>汉字一般3字节</strong></p></li></ul><h3 id="ISO-8859-1-（Latin-1）"><a href="#ISO-8859-1-（Latin-1）" class="headerlink" title="ISO-8859-1 （Latin 1）"></a>ISO-8859-1 （Latin 1）</h3><p>同样是ASCII码的超集，用一个字节（8位容器）实现255节。在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。mysql默认就采用他</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>一般汉字2字节。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html">Java中存在的编码问题</a></p><h2 id="2-Content-Type与前后编解码"><a href="#2-Content-Type与前后编解码" class="headerlink" title="2. Content-Type与前后编解码"></a>2. Content-Type与前后编解码</h2><p>开发过程中，设定HTTP请求和返回报文中的Content-Type是保证文本不乱码正常解析的最重要保障。</p><h3 id="浏览器解码顺序："><a href="#浏览器解码顺序：" class="headerlink" title="浏览器解码顺序："></a>浏览器解码顺序：</h3><ol><li><p>根据服务器返回的Content-Type中指定的编码解码。</p></li><li><p>根据meta标签的charset。</p></li><li><p>根据浏览器设定的编码解码（跟随浏览器设定，一般中文系统为GBK）</p></li></ol><h3 id="浏览器编码顺序和Content-Type："><a href="#浏览器编码顺序和Content-Type：" class="headerlink" title="浏览器编码顺序和Content-Type："></a>浏览器编码顺序和Content-Type：</h3><ul><li><p>POST请求的编码：默认UTF-8，<strong>ajax请求强制数据为UTF-8编码，即使在contentType中设置的编码也不生效</strong>，所以对于发送ajax请求，直接写application&#x2F;json，然后设置服务器对所有请求数据使用UTF-8解析：request.setCharactorEncoding(“UTF-8”)。</p><ul><li><p>Ajax POST默认contentType: application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8。</p></li><li><p>form POST默认的contentType: application&#x2F;x-www-form-urlencoded</p><p><strong>form POST的编码也是UTF-8，但是不会在Content-Type中声明</strong></p></li></ul></li><li><p>GET请求的编码：默认UTF-8（不指定Content-Type，一般传输不了中文）</p></li></ul><h3 id="服务器解码顺序："><a href="#服务器解码顺序：" class="headerlink" title="服务器解码顺序："></a>服务器解码顺序：</h3><ol><li><p>使用requst.setCharactorEncoding( )指定的编码解码。</p></li><li><p>根据客户端发送的Content-Type中的编码解码。</p></li><li><p>使用默认的UTF-8解码</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 设置Content-Type作用与于GET请求<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">useBodyEncodingForURI</span> = <span class="hljs-string">&quot;true&quot;</span> &gt;</span> <br> // 设置GET请求使用UTF-8解码, Tomcat 8以后这个默认值已经是UTF-8，<br> // 注意：request.setCharactorEncoding对GET请求不生效。<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">URIEncoding</span> =<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span> <br></code></pre></td></tr></table></figure><h3 id="服务器编码顺序和Content-Type："><a href="#服务器编码顺序和Content-Type：" class="headerlink" title="服务器编码顺序和Content-Type："></a>服务器编码顺序和Content-Type：</h3><ol><li><p>response.setContentType(“application&#x2F;json; charset&#x3D;UTF-8”)，respnse.setCharactorEncoding()</p></li><li><p>Servlet response的默认编码是UTF-8</p></li><li><p>JSP会默认Content-Type：</p><p>JSP的编码只受到Page指令的contentType&#x2F;pageEncoding命令约束，而且这两个命令对于JSP生成的Content-Type决定权最高。</p><p>response.setCharactorEncoding方法：设置返回数据的编码</p><p>response.setContentType方法：设置Servlet返回数据的编码和返回数据的Content-Type。<strong>setContentType方法优先级最高</strong>，在此方法前后出现setCharactorEncoding()，数据会按照Content-Type编码。</p></li></ol><ul><li>注解设置注解设置：@RequestMapping(value &#x3D; “”, <strong>produces&#x3D;”application&#x2F;json;charset&#x3D;UTF-8”</strong>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乱码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
