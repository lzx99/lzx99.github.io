<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/21/%E5%85%B6%E4%BB%96/9.%20%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%86%E6%80%9D%E8%80%83/"/>
    <url>/2023/02/21/%E5%85%B6%E4%BB%96/9.%20%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%86%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库加索引</title>
    <link href="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/2022-12-12-%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93/2022-12-12-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>数据库有3种方式创建索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 这种方式建立索引最简单，但是表中需要有数据，否则索引建立失败<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> lmt_crdt_app <span class="hljs-keyword">ADD</span> INDEX idx_cust_name(cust_name);<br># 通过<span class="hljs-keyword">create</span> INDEX<br><span class="hljs-keyword">CREATE</span> INDEX idx_cust_name <span class="hljs-keyword">ON</span> lmt_crdt_app(cust_name);<br># 可以在建表时，在所有字段的最后，加上索引 INDEX idx_cust_name(cust_name);<br></code></pre></td></tr></table></figure><p>最常见的是普通索引（<strong>INDEX</strong>），上面代码中创建的就全是普通索引</p><p>还有一种索引是唯一索引（<strong>UNIQUE INDEX</strong>），创建唯一索引在普通索引的INDEX前加一个UNIQUE标识就行了。他的值必须要唯一，如给“电子邮件”这个字段加上唯一索引，那么每一个电子邮件都不能够重复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/14/Java/SSM/"/>
    <url>/2022/11/14/Java/SSM/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h4 id="Spring思想"><a href="#Spring思想" class="headerlink" title="Spring思想"></a>Spring思想</h4><p>源于EJB（Enterprise JavaBean），传统JavaEE的EJB现在已被Spring家族淘汰，Spring基于IOC思想开发。是一个IoC和AOP容器框架，松耦合+少入侵。<a href="https://zhuanlan.zhihu.com/p/66790602">Spring中设计模式</a></p><ul><li>IOC（Inversion of Control，控制反转）</li><li>DI（Dependency Injection，依赖注入）</li><li>AOP（Aspect Oriented Programming，面向切面编程）：鉴定权利、日志打印跟事务处理。</li></ul><h4 id="开启Spring容器"><a href="#开启Spring容器" class="headerlink" title="开启Spring容器"></a>开启Spring容器</h4><ol><li>编写Spring的配置文件</li></ol><p>Spring配置文件（习惯命名applicationContext.xml）的作用在于配置注解扫描（也可以用类上声明@Configuration+@Bean注册），和注册Bean</p><ol start="2"><li>加载配置资源，创建BeanFactory</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1.Application接受Spring容器，是BeanFactory的子类，创建时就初始化所有Bean，类路径/绝对路径</span><br>ApplicationContext context = <span class="hljs-keyword">new</span><span class="hljs-constructor">ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)</span>;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">FileSystemXmlApplicationContext(<span class="hljs-string">&quot;c:/applicatioContext.xml&quot;</span>)</span>;<br>UserService UserService = (Userservice)context.get<span class="hljs-constructor">Bean(<span class="hljs-string">&quot;userServiceImpl&quot;</span>)</span>;<br><span class="hljs-comment">//2. XmlBeanFactory+ClasspathResource获取（过时），getBean时才初始化</span><br>BeanFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XmlBeanFactory(<span class="hljs-params">newClassPathResource</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)</span>;);<br><span class="hljs-comment">//读取注解配置类：</span><br>ctx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AnnotationConfigApplicationContext(ApplicationContextConfig.<span class="hljs-params">class</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h4><ul><li><p><strong>@Component、@Controller、@Service、@Repository</strong>，注册Bean，默认Bean的ID&#x3D;小写的类名。</p><p>Repository注解很少使用，因为经常用MapperScanner给我们扫描了dao层，注册到了容器中</p></li><li><p>注册Bean：<strong>id和class属性（类的位置，不是接口位置）</strong>是必须属性，尤其是class。</p><p>xml注册Bean、注解注册Bean、类注册（@configuration注解放在配置类上，@Bean注解放在返会类对象的方法上）</p></li></ul><h4 id="Spring注入"><a href="#Spring注入" class="headerlink" title="Spring注入"></a>Spring注入</h4><p>spring的注入是指在启动spring容器加载Bean配置的时候，<strong>完成对对变量的赋值行为</strong>。常见的spring注入的方式有两种，分别是设值注入和构造注入。</p><ol><li><p>值注入</p></li><li><p><strong>@Value：</strong>可以从配置文件读取时，如@Value(“${driver.name}”)</p></li><li><p>xml配置的设值注入依赖于setter，在注册Bean里设置property，视图解析器等等Bean已经配过很多次了</p></li><li><p>依赖注入</p></li><li><p>@Autowired：按byType自动装配，如果在容器中装配的类型有多个bean，自动再按名字自动装配。</p><p>@Resource ：优先按定义的属性名byName自动装配，后按照type匹配。多个实现时，@Resource(name&#x3D;”car”)，等于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name=&quot;cookFish&quot;)</span><br><span class="hljs-comment">// 等于</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-meta">@Qualifier(&quot;cookFish&quot;)</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 写在这个属性的setter方法上（需要有）</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setCar</span>(<span class="hljs-params">IVehicle car</span>) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = car;<br>&#125;<br><span class="hljs-comment">// 写在构造器参数前面，当我们调用这个构造方法创建Bean时</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Driver</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-meta">@Autowired</span> <span class="hljs-title class_">IVehicle</span> vehicle) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = vehicle;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Bean设置里的设置property的ref就是依赖注入整个对象，需要setter。也可以通过xml构造器依赖注入。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;eDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;empdao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 或者 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;edao&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;empdao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><strong>xml自动依赖注入</strong>，在bean标签中，设置<strong>autowire</strong>&#x3D;”byName”或者autowire&#x3D; “byType”（还有constructor和default，一般不用）<br>例如：bean中有一个属性是IPerson类型，如果配置了按类型装配，就会到容器中找类型是IPerson的bean,注入到属性中，但是IPerson有多个实现类时，会报错。</li></ol><p>类型自动装配缺点：容器中只能有一个该类型的bean（Ivehicle属性只能有一个继承类） ，多个继承类，会出现下面的异常：</p><ol start="3"><li>更改默认无参构造器</li></ol><p>从Spring默认通过反射调用<strong>无参构造器获取对象</strong>。可以使用自定义的构造器注入一部分值和属性（比较少用），在Bean注册中用constructor-arg指定多个<strong>构造器参数</strong>，index指定参数的位置，type制定参数类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oracle.Driver&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;老张&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br> <span class="hljs-comment">&lt;!--构造器依赖注入 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;car&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>Spring容器中的Bean默认都是单例的（取多次都是同一个对象），bean的scope属性设为<strong>prototype</strong>，Bean变成多例，</p><p>request：request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</p><p>session：session表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session</p><p>globalsession：global session作用域类似于标准的HTTP Session作用域，仅仅在基于portlet的web应用中才有意义</p><ul><li>@Scope ：xml里bean元素的scope属性，设定Bean的作用范围，也可以放在方法上。默认单例，Spring容器加载时就创建对象，prototype每一次获取Bean就创建</li><li>xml设置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.oracle.Driver&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h4><p>在bean创建，或销毁时设置一个方法（很少用）</p><ul><li><p><strong>@PostConstruct和@PreDestroy</strong> ：Bean生命周期方法的注解（等于bean属性配置init-method&#x3D;”init”）</p></li><li><p>xml设置生命周期方法：在bean中设置属性一个<strong>init-menthod</strong>等于对象中的哪个方法</p></li><li><p>Spring配置</p></li></ul><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>Spring AOP默认基于动态代理的，<strong>当类（切面）没有从一个接口继承而来时，会使用cglib代理</strong> 。SpringAOP是运行时进行编译生成代理类。AspectJ则是编译时织入，将切面织入到代码，没有使用代理模式</p><p>MenthodInterceptor是CGLIB代理。InvocationHandler接口是JDK代理，Spring本质上也是实现他们。</p><p>三种角色：真实对象、代理对象、角色</p><h4 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h4><p><a href="https://blog.csdn.net/github_34889651/article/details/51321499">AOP术语参考</a></p><p><strong>切面（aspect）</strong>、<strong>切入点（pointcut）</strong>、<strong>通知（advice）</strong>： 、<strong>织入（weaving）</strong></p><p>确定切面（哪个Bean），编写通知，设置通知的切入点（方法，角色），spring帮我们完成织入，生层代理对象</p><p>SpringAOP依赖于AspectJ的aspectjrt和aspectjweaver两个依赖，因为我们依赖与AspectJ框架的一些注解，一般不需要使用到AspectJ AOP框架，Spring AOP足够用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect-antoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>五种通知：begin、after（无论是否方法成功或失败）、around（包含被通知方法）、after-retuning（成功）、after-throwing（在这个方法抛出异常以后执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Aspect注解标一个切面（aspect），是通知advice和切点pointcut的集合。并用Componet注解注册到容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaoAspect</span> &#123;<br>  <span class="hljs-comment">// 定义一个切入点，供通知引用</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * tmall.controller.*.*Controller.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 直接在通知中配置切入点</span><br>    <span class="hljs-meta">@Before(&quot;execution(* com.oracle.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开启事务&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;execution(* com.oracle.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;提交事务&quot;</span>);<br>    &#125;<br>  <span class="hljs-comment">// 这种配置切入点也可以</span><br>    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 代表原方法</span><br>            joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            throwable.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>xml配置切面的通知和切入点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 配置aspect切面里的切入点和通知--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;timeHandler&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- HelloWorld类下的所有方法，任意参数，..代表0个以上参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addTime&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printTime&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;addTime&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printTime&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;addTime&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logHandler&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;printLog&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;LogBefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;printLog&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;LogAfter&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;printLog&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果一类应用了多个通知，执行顺序：</p><p>先执行所有前置通知，再执行所有后置通知，而且顺序相反，也就是如果一个类执行了A前置通知再执行了B前置通知，执行完方法后，先执行B后置通知，在执行A的后置通知</p><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><p>Spring中，两种事务处理</p><ol><li>编程式事务： 通过代码来处理事务，如transactionManager.commit()，代码侵入性强</li><li>声明式事务：通过@Transaction注解或者xml处理事务，各有优缺点</li></ol><p>配置事务管理器的Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 核心事务管理器配置到spring（依赖数据源）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>xml配置</li></ol><p>可以设置切点，注解是方法级别的，关于<a href="https://juejin.im/post/5e6d993cf265da575b1bd4af#comment">Spring事务面试题</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 事务管理器切面的设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;txManager&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 对insert,create,update,modify,delete,remove 开头的方法进行事务管理,只要有异常就回滚，propagation定义Spring事务传播级别， --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>  <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>  <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>  <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>  <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;modify*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>  <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span>  <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remove*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;java.lang.Throwable&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- find,get,select,count开头的方法,开启只读,提高数据库访问性能 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;select*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;count*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 对其他方法 使用默认的事务管理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- AOP配置切面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--配置切入点--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerServiceOperation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.oracle.service.*ServiceImpl.*(..))&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!--advisor配置器：通知和切入点绑定--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;customerServiceOperation&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>注解配置</li></ol><p>@Transcational注解指定哪个方法或者类用事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 由Annotation调度事务管理Bean  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;txManager&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SprintMVC基本原理：浏览器发送请求，交给**核心控制器(DispatcherServlet)**，查找HandlderMapping中是否有对应的地址映射，如果存在要访问映射的控制器，先经过HandlerAdapter做类型自动转换、处理请求参数，访问Controller，Controller将模型数据和视图地址封装为ModelAndView对象交换给核心控制器，通过视图解析器为视图的地址添加前缀和后缀，向指定的视图层跳转。</p><h2 id="接收请求参数（URL编码）"><a href="#接收请求参数（URL编码）" class="headerlink" title="接收请求参数（URL编码）"></a>接收请求参数（URL编码）</h2><p>SprintMVC请求参数一定要在前端进行格式化，类型不匹配时则无法自动设值注入，返回400错误。</p><p>handle方法写什么就自动传入什么，如写HttpServeltRequest</p><h4 id="1-参数名映射"><a href="#1-参数名映射" class="headerlink" title="1. 参数名映射"></a>1. 参数名映射</h4><p>handle的方法参数和请求参数名字自动匹配，自动完成值注入</p><ol><li>情况一： 请求参数的名字 和方法参数的名字一致 ，直接就注入到方法参数中<ul><li>不写RequestParam时，引用类型没有传入参数时，不会报错，默认值为null；基本数据类型必须要传入参数</li><li>写RequestParam时，默认required时true。所有类型必须要参数，即User&#x2F;list?name&#x3D;?pwd&#x3D;，参数可以为空。</li></ul></li></ol><p>例如，访问的URL为：<a href="http://localhost:8080/controller/hello?name=tom&age=20">http://localhost:8080/controller/hello?name=tom&age=20</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@RequestMapping(&quot;/hello&quot;)<br><span class="hljs-built_in">public</span> String hello(String <span class="hljs-type">name</span>,<span class="hljs-type">int</span> age)&#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;hello World:&quot;+<span class="hljs-type">name</span>+&quot;,age:&quot;+(age+<span class="hljs-number">1</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>情况二：请求参数的名字和方法参数的名字不致 ，通过**@RequestParam**（写在参数前面）指定名字映射</li></ol><p>例如，访问的URL为：<a href="http://localhost:8080/controller/hello?name=tom&a=20">http://localhost:8080/controller/hello?name=tom&a=20</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(String name,<span class="hljs-meta">@RequestParam(&quot;a&quot;)</span> <span class="hljs-type">int</span> age)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello World:&quot;</span>+name+<span class="hljs-string">&quot;,age:&quot;</span>+(age+<span class="hljs-number">1</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-对象名映射"><a href="#2-对象名映射" class="headerlink" title="2. 对象名映射"></a>2. 对象名映射</h4><ol><li>将请求参数注入到一个对象中，<strong>请求参数的名字和对象的属性名相同</strong>即可完成值的注入，不需要完整的对象属性</li></ol><p>例如 url：<a href="http://localhost:8080/controller/hello?empno=110&ename=tom&tel=1234567">http://localhost:8080/controller/hello?empno=110&ename=tom&tel=1234567</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(Emp e)</span>&#123;<br>e.getEmpno();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>请求参数包含多个对象匹配</li></ol><p>参数重写多个对象，下面是一个对象带依赖</p><p>表单中包含员工数据和部门的数据 ，想把所有保存在Emp中，前端的依赖对象的name写<strong>依赖对象.属性，</strong>自动完成设值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/controller/hello&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;empno&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ename&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tel&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>      部门id：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;d.deptno&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;保存&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  @RequestMapping(&quot;/hello&quot;)<br>  public String hello(Emp e)&#123;<br>自动我们设置e对象中的d.deptno<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Map貌似不能接受数据"><a href="#3-Map貌似不能接受数据" class="headerlink" title="3. Map貌似不能接受数据"></a>3. Map貌似不能接受数据</h4><h2 id="接受JSON数据"><a href="#接受JSON数据" class="headerlink" title="接受JSON数据"></a><strong>接受JSON数据</strong></h2><p>需要映射的前面加**@RequestBody**注解，可以有四种修饰，一般用下面的前两种</p><p>将请求体中的JSON&#x2F;xml字符串绑定到相应的bean上或绑定到对应的字符串上（会根据Content-Type，JSON、XML）），<strong>只能修饰最后一个参数</strong></p><p>如add（提交操作）时一般使用Ajax（好让前端提示添加失败，不会重置窗口），这是一般使用PO类来接受（尤其是单表）</p><p>list（页面动态信息）页面时，一般直接对应</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript">   浏览器服务器 <br>  <span class="hljs-title class_">JSON</span>：&#123;属性名:属性值&#125;对象/<span class="hljs-title class_">Map</span><br>  [&#123;属性名:属性值&#125;,&#123;属性名:属性值&#125;]    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">User</span>&gt;<br>  数组：[<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>] <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;<br>  <span class="hljs-title class_">StringString</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">login</span>(<span class="hljs-meta">@requestBody</span> <span class="hljs-title class_">String</span> userName, <span class="hljs-meta">@requestBody</span> <span class="hljs-title class_">String</span> pwd)<br>  <span class="hljs-title class_">JSON</span>：&#123;<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;lee&quot;</span>, <span class="hljs-string">&quot;pwd&quot;</span>:<span class="hljs-string">&quot;123&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="向view传数据"><a href="#向view传数据" class="headerlink" title="向view传数据"></a><strong>向view传数据</strong></h2><ol><li><p>直接使用request对象（不推荐），下面这些方法设值的原理是核心控制器（dispatcherServlet）给我们request.setAttribute。</p></li><li><p>在Controller的方法参数中<strong>定义Map参数</strong>（最常用），不用request.setAttribute主要是为了做到和servlet-API的松耦合，可以脱离servile进行单元测试。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-built_in">RequestMapping</span>(<span class="hljs-string">&quot;/test1&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-type">String</span> name, Map map)</span></span>&#123;<br> map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;toms&quot;</span>);<br> map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);<br> map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;emp&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Emp</span>());<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在Controller的方法参数中<strong>定义Model&#x2F;ModelMap参数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/test1&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, Model model</span>)&#123;<br> model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;toms&quot;</span>);<br> model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);<br> model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;emp&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>());<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 会在进入访问该控制器的所有方法前，设定model的值</span><br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">model</span>(<span class="hljs-params">Model model</span>) &#123;<br>   model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;注解成功&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>封装到ModelAndView对象中，ModleAndView对象可以放在参数当中生成</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/test2&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)&#123;<br> <span class="hljs-title class_">ModelAndView</span> modelAndView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;/fail&quot;</span>);<br> modelAndView.<span class="hljs-title function_">addObject</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;toms&quot;</span>);<br> modelAndView.<span class="hljs-title function_">addObject</span>(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);<br> modelAndView.<span class="hljs-title function_">addObject</span>(<span class="hljs-string">&quot;emp&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>());<br> <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="向view跳转"><a href="#向view跳转" class="headerlink" title="向view跳转"></a><strong>向view跳转</strong></h2><p>Controller的状态和handler返回值有关，默认跳转。ServletController不做操作时返回空白到字符串。</p><ul><li>**return ResponseEntity&lt;byte[]&gt;**：用于文件下载</li><li>带ResponseBody注解，向浏览器发送JSON数据：</li></ul><h3 id="return跳转"><a href="#return跳转" class="headerlink" title="return跳转"></a>return跳转</h3><p>两种方式，无论是哪种 ，核心控制器获得的都是ModelAndView</p><ol><li><p>直接return 字符串：跳转的地址</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/test1&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/succ.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接return ModelAndView对象 ，跳转的地址封装到这个对象中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/test2&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;/fail.jsp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>return void时，必须resp向浏览器返回数据或用request跳转</strong>，否则返回404&#x2F;500</p></li></ol><p>⚠️：默认forward，如果在地址字符串中包含 forward: 或 redirect:  就不经过视图解析器</p><ul><li>请求转发跳转 jsp : 不写forward</li><li>重定向jsp ： “redirect: uri”</li><li>请求转发跳转 Controller : 地址的字符串中 “forward: controller的uri”</li><li>重定向 Controller : “redirect: uri”</li></ul><p>SpringMVC拦截器</p><h2 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a><strong>SpringMVC拦截器</strong></h2><p>要HandleMapping映射成功才会进入拦截器</p><h3 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h3><ul><li>过滤器是用来拦截jsp、servlet请求的，拦截器用来拦截<strong>SpringMVC框架中Controller</strong></li><li>过滤器依赖Servlet容器中，不依赖servlet，因为SpringMVC Controller是在Spring容器中的</li><li>通过调用chain.doFilter方法执行后续内容，拦截器是通过return true&#x2F;false 决定是否执行后续内容。</li><li>过滤器基于函数回调，过滤器基于动态代理，要继承HandleInterception</li><li>拦截器能获得参数，并修改参数（净网活动）</li></ul><p><a href="https://blog.csdn.net/fjnmbb12/article/details/74001567">拦截器参考</a></p><h3 id="拦截器三个方法"><a href="#拦截器三个方法" class="headerlink" title="拦截器三个方法"></a>拦截器三个方法</h3><p>preHandle顺向，postHandle和afterCompletion逆向，主要是拦截Controller</p><p><strong>继承HandlerInterceptorAdapter或者实现HandlerInterceptor</strong>，<strong>推荐继承</strong>，这样可以选择想要的重写的方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyInterceptor implements HandlerInterceptor&#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * preHandle方法在Controller的handler方法前进行调用。</span><br><span class="hljs-comment">  * 如有多个Interceptor，SpringMVC会根据声明的前后顺序一个接一个的执行，</span><br><span class="hljs-comment">  * 主要用于身份认证（验证非法登陆）</span><br><span class="hljs-comment">  */</span><br> @Override<br> <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> preHandle(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse, <span class="hljs-keyword">Object</span> <span class="hljs-keyword">handler</span>) throws <span class="hljs-keyword">Exception</span> &#123;<br>   //闸门<br>   startTime = <span class="hljs-keyword">System</span>.currentTimeMillis(); <br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * postHandle在Interceptor的preHandle方法返回值为true的时候才会执行 </span><br><span class="hljs-comment">  * 在Controller的方法调用之后，在DispatcherServlet进行视图的渲染之前执行</span><br><span class="hljs-comment">  * 在这个方法中可以对ModelAndView统一定制。比如菜单导航</span><br><span class="hljs-comment">  */</span><br> @Override<br> <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> postHandle(HttpServletRequest httpServletRequest, HttpServletResponse<br>                        httpServletResponse, <span class="hljs-keyword">Object</span> o, ModelAndView modelAndView) throwsException &#123;<br>   <span class="hljs-keyword">object</span> o可以获得请求对象的参数，和设置<br>     //Controller 执行完毕后 要执行的代码 endTime = <span class="hljs-keyword">System</span>.currentTimeMillis(); <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(endTime-startTime);<br>&#125;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * preHandle方法的返回值为true时才会执行。</span><br><span class="hljs-comment">  * 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图后执行。</span><br><span class="hljs-comment">  * 该方法可用于清理一些资源：统一的异常处理，日志处理</span><br><span class="hljs-comment">  */</span><br> @Override<br> <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> afterCompletion&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="spring-xml配置"><a href="#spring-xml配置" class="headerlink" title="spring xml配置"></a>spring xml配置</h1><h2 id="扫描注解"><a href="#扫描注解" class="headerlink" title="扫描注解"></a>扫描注解</h2><p>xml需要加上context的xml命名空间和context的schema验证文件，Springboot不需要配置Spring注解的扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.oracle&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;regex&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.oracle.intelagr.controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 可以用调整包括范围 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:including-filter</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 不推荐使用，这个只配置了普通的context:componetscan代替--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="读取properties文件"><a href="#读取properties文件" class="headerlink" title="读取properties文件"></a>读取properties文件</h2><p>通过类似于EL表达式的${ }，在XML或者Spring注解中，引入properties文件里面的值。另外习惯性通过资源文件（加载Locale读取不同配置文件）国际化</p><p>添加Spring配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath：applicationContext.properties&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--多个时，可以选择这种方式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;propertyConfigurer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;location&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application.properties<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc.properties<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h2><p>Spring无缝整合SpringMVC，主要需要整合mybatis到Spring中。</p><p>mybatis-Spring包，SpringDate里的：sqlSessionTemplate()模板类。</p><h3 id="数据源-x2F-连接池"><a href="#数据源-x2F-连接池" class="headerlink" title="数据源&#x2F;连接池"></a>数据源&#x2F;连接池</h3><p>数据源是数据库的抽象映射，一个数据源对应一个数据库，连接池是数据库的代理，每一次增删改，都要连接一次，非常耗时间，很多容器都给我们提供了<strong>连接池代替数据源</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这里使用DriverManager使用JDBC数据源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/cmp?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="sqlSessionFactory"><a href="#sqlSessionFactory" class="headerlink" title="sqlSessionFactory"></a>sqlSessionFactory</h3><p>将mybatsi的<strong>SqlSession工厂注册到Spring容器中</strong>，<strong>注入数据源到Mybatis</strong>，设值注入要扫描实体包的包位置。这个是必须配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- sqlSessionFactory注册在Spring容器中，同时注入数据源Bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 扫描实体类所在的包，将实体类别名包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.oracle.ssm.entity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="Mapper扫描器"><a href="#Mapper扫描器" class="headerlink" title="Mapper扫描器"></a>Mapper扫描器</h3><p>注册Mapper扫描器，配置扫描Mapper接口的包位置（<strong>Mapper接口和Mapper.xml名字的包要一致</strong>），自动创建Mapper接口的代理对象（以前通过getMapper方法）。Mapper的代理对象(dao层)已经在Spring容器中，只需要我们用注解注入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mapperScanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 过时：&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt; --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.oracle.cmp.mapper&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>除了使用mapper扫描器，自动完成接口绑定和mapper代理类的生成。</p><p>也可以使用sqlsessiontemplate完成、</p><h3 id="数据库事务管理器"><a href="#数据库事务管理器" class="headerlink" title="数据库事务管理器"></a>数据库事务管理器</h3><p>需要的业务方法或者业务类由@Transcation调度</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">*</span>&quot;<span class="hljs-attr">dataSource</span>&quot; <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 由Annotation调度事务管理Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">*</span>&quot;<span class="hljs-attr">txManager</span>&quot; /&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="SpringMVC配置文件"><a href="#SpringMVC配置文件" class="headerlink" title="SpringMVC配置文件"></a>SpringMVC配置文件</h2><p>可以使用<a href="https://juejin.im/post/5dcd0c8851882510a3712f72">类配置SpringMVC</a>，做到类似于SpringBoot（不推荐）</p><ol><li><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置监听器，项目一加载，就加载Spring容器，并加载Spring配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-comment">&lt;!-- content-param在启动时会存在servletContext对象(application)中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置springmvc 核心控制器DispatcherServlet，并指定dispatcherServlet配置文件的路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置springmvc配置文件的位置，如果配置文件名改了名，必须要配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 拦截所有带斜杠的请求，以前是配置/*.do、/*.xhtml，防静态资源，但是非Rest风格 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 用Springweb给我们提供的字符过滤器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>配置MVC的dispatcherServlet，servletname名字随便起，默认是servlet名-servlet.xml</p><p><a href="https://blog.csdn.net/qq_30038111/article/details/79722624">关于SpringMVC静态资源的处理</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拓充MVC的注解 请求参数的注解和装载数据注解等等 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- MVC需要单独扫描Controller  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.oracle.controller&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- SimpleUrlHandlerMapping，Controller的Bean配置，一般用注解扫描代替 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;controller.HelloController&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simpleUrlHandlerMapping&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mappings&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;/hello&quot;</span>&gt;</span>helloController<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  指定项目的静态资源注册到SimpleUrlHandlerMapping，</span><br><span class="hljs-comment">   **表示路径映射两级文件夹，打破了传统文件夹只能放在web根目录下的限制，</span><br><span class="hljs-comment">   mapping代表映射后的路径，并且可以设置cacheControl</span><br><span class="hljs-comment">   默认配置静态资源：，&lt;mvc:default-servlet-handler /&gt; </span><br><span class="hljs-comment">   表示没有mapping，就去默认路径找，但是不能指定任意位置   --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/js/&quot;</span> <span class="hljs-attr">cache-period</span>=<span class="hljs-string">&quot;31556926&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/style/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/style/&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/upload/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/upload/&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 拦截器，SpringMVC提供的类似Filter的工具，用来拦截handler，可以不写--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span> &gt;</span><br>    <span class="hljs-comment">&lt;!-- 拦截哪个Controller，优先级高 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testController&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oracle.common.MyInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span> &gt;</span>                            <br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/test*&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oracle.common.MyInterceptor2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置viewResolver视图解析器，thymeleaf需要配置view.ThymeleafViewResolver这个解析 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/pages/&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 文件上传解析器 multipart --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 上传文件大小上限，单位为字节（10MB）,可选 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10485760<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br><span class="hljs-comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，可选 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h1><p><a href="https://blog.csdn.net/Thinkingcao/article/details/86613066">SpringBoot静态目录</a>、<a href="https://blog.csdn.net/u011144425/article/details/79225864">静态目录</a>、<a href="http://wuwenliang.net/2018/07/10/Springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%AD%94%E6%B3%95%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89starter/">SpringBoot starter原理</a></p><h3 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a><a href="https://zhuanlan.zhihu.com/p/53848414">thymeleaf</a></h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置JSP，不推荐</span><br><span class="hljs-attr">spring.view.prefix</span>=<span class="hljs-string">/WEB-INF/views/</span><br><span class="hljs-attr">spring.view.suffix</span>=<span class="hljs-string">.jsp</span><br><span class="hljs-comment"># 默认配置，可以选择不配置：</span><br><span class="hljs-attr">spring.thymeleaf.mode</span>=<span class="hljs-string">HTML5</span><br><span class="hljs-attr">spring.thymeleaf.encoding</span>=<span class="hljs-string">UTF-8</span><br><span class="hljs-attr">spring.thymeleaf.content-type</span>=<span class="hljs-string">text/html;charset=&lt;encoding&gt;</span><br><span class="hljs-attr">spring.thymeleaf.prefix</span>=<span class="hljs-string">classpath:/templates/</span><br><span class="hljs-attr">spring.thymeleaf.suffix</span>=<span class="hljs-string">.html</span><br><span class="hljs-comment"># 一般缓存设置为false, 这样修改之后马上生效，便于调试</span><br><span class="hljs-attr">spring.thymeleaf.cache</span>=<span class="hljs-string">false</span><br><br></code></pre></td></tr></table></figure><ul><li>变量名同样用用{}EL表达式，文件路径src用@{}</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;s:$&#123;students&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;s.id&#125;&quot;</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;s.name&#125;&quot;</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 当students集合为空则显示提示信息,用了thymeleaf内置工具#list的isEmpty方法，</span><br><span class="hljs-comment"> 可以用$&#123;num == 6&#125;或者$&#123;!empty user&#125;直接EL逻辑运算--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;#lists.isEmpty(students)&#125;&quot;</span>&gt;</span>studnets集合为空！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 当students集合不为空时才会显示下面的元素 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;not #lists.isEmpty(students)&#125;&quot;</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$&#123;status.even&#125;?&#x27;even&#x27;:&#x27;odd&#x27;&quot;</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../../webapp/static/js/thymeleaf.js&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/static/js/thymeleaf.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>  <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/static/js/thymeleaf.js&#125;&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> stu = [[$&#123;student&#125;]];</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;/&quot;</span> + stu.<span class="hljs-property">id</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>定义fragment组件： th:fragment&#x3D;”footer1”、th:include&#x3D;”include::footer1”、th:replace&#x3D;”include::footer1”、layout:decorator、layout:fragment</p><h3 id="SpringBoot-MVC"><a href="#SpringBoot-MVC" class="headerlink" title="SpringBoot MVC"></a>SpringBoot MVC</h3><p>实现WebMvcConfigurer，作为配置类，不要继承WebMvcConfigurerAdapter，相当于@Configuration+@Enablespringmvc。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><span class="hljs-meta">@Autowired</span><br>  LoginIneerceptor loginInterceptor; <br>  <span class="hljs-comment">//重写addInterceptor方法配置拦截器的地址，SpringBoot常用autowired+component注入Interceptor</span><br>  <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(LoginInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br> &#125;<br>  <span class="hljs-comment">//重写addCorsMappings配置全局CORS；也可以注入一个CorsFilter的一个Bean来配置</span><br> <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;  <br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)  <br>                .allowCredentials(<span class="hljs-literal">true</span>)  <br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)  <br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)  <br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/26/Java/Java%E5%9F%BA%E7%A1%802/"/>
    <url>/2022/05/26/Java/Java%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>通过IO流实现在内存，硬盘或不同平台间文件的传输。</p><p><strong>进行IO流操作后需要关流，否则会一直占用资源</strong>，当其他请求访问时将会发生Runtime异常。另外字符流不close或者不flush，会导致当前写入或者读取失败，因为字符流使用了缓冲区，不关流或flush是无法将数据传送到硬盘或者读取到内存的。</p><p>IO流常用方法：write(数据)、read(接收返回数据)。<br><strong>无参read方法返回一个字节&#x2F;字符，读到底了，返回-1；有参read方法读取数据到参数并返回的字符&#x2F;字节长度</strong></p><p>输出流默认构造方法会覆盖原文本文件，加true表示追加到文本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Writer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file,<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>InputStream和OutputStream是字节流父类，是抽象方法，必须通过子类实例化。</p><p>字节流写入字节数据，没有缓冲区，直接保存或读取硬盘字节文件。</p><h4 id="1-FileInputStream-x2F-FileOutputStream"><a href="#1-FileInputStream-x2F-FileOutputStream" class="headerlink" title="1. FileInputStream&#x2F;FileOutputStream"></a>1. FileInputStream&#x2F;FileOutputStream</h4><p>与<strong>硬盘有关</strong>的操作使用<strong>File型输入输出流</strong>。</p><p>写入字符数据时，需要我们手动将内存中的字符编码成字节（str.getBytes(“UTF-8”)），再写入字节数组到硬盘，可以直接write整个字节数组，也可以循环字节数组，一个一个写入。</p><p>可以在构造方法传入要操作的<strong>文件路径字符串</strong>，也可以用<strong>File类对象（推荐）</strong>，两种方法指定的<strong>路径不存在时自动创建文件</strong>。File类：抽象的方式表示一个文件路径，用来操作文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br> <br><span class="hljs-comment">// 读取方法1，直接读取全部</span><br>Byte[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>];<br> in.read(bytes);<br><br><span class="hljs-comment">// 读取方法2（最常用！！！！！）</span><br>Byte[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>((temp=in.read())!= -<span class="hljs-number">1</span>)&#123;<br>   bytes[len] = (<span class="hljs-type">byte</span>)temp;<br>   len++;<br> &#125;<br><br><span class="hljs-comment">// 读取方法3用for循环，只适用于已知文件的字节长度（很少使用，不推荐）</span><br>Byte[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[(<span class="hljs-type">int</span>)file.length()];<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;bytes.length; i++)&#123;<br>bytes[i]=(<span class="hljs-type">byte</span>)in.read();<br> &#125;<br></code></pre></td></tr></table></figure><p>实现文件复制：<strong>将一个文件用输入流read，返回的字节或字节数组， 直接用另一个文件的输入流直接write，而不需要构建一个字节数组去接收</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/Users/lee/Desktop/a.png&quot;</span>);<br>out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/Users/lee/Desktop/b.png&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>((temp = in.read())!= -<span class="hljs-number">1</span>)&#123;<br>  out.write((<span class="hljs-type">byte</span>)temp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-BufferedInputStream"><a href="#3-BufferedInputStream" class="headerlink" title="3. BufferedInputStream"></a>3. BufferedInputStream</h3><p>比如下载文件，从服务器文件中一次读一块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>OutputStream os=resp.getOutputStream();<br><span class="hljs-type">int</span> i=bis.read(buffer);<br><span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">// write，读取buffer，从buffer的0到i</span><br>  os.write(buffer,<span class="hljs-number">0</span>,i);<br>  i=bis.read(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-BufferedOutputStream"><a href="#4-BufferedOutputStream" class="headerlink" title="4. BufferedOutputStream"></a>4. BufferedOutputStream</h3><p>一次写一块，socket中</p><h3 id="对象流（序列化）"><a href="#对象流（序列化）" class="headerlink" title="对象流（序列化）"></a>对象流（序列化）</h3><p>ObjectInputStream和ObjectOutputStream，接受普通流，方法writeObject和readObject</p><p>对象中定义一个一个静态常量的序列号，比较好还原</p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader和Writer是所有字符流父类，是最普通基础的。</p><p><strong>字符流只能读取和写入字符，使用了缓冲区，并在底层帮我门封装了编码和解码过程。</strong><br>底层写：将内存字符（Unicode形式）进行编码（UTF-8），再通过字节流保存到硬盘<br>底层读：读取字节并解码成字符数组，返回给read(接收的字符数组)。</p><h3 id="1-FileWriter-x2F-FileReader"><a href="#1-FileWriter-x2F-FileReader" class="headerlink" title="1. FileWriter&#x2F;FileReader"></a>1. FileWriter&#x2F;FileReader</h3><p>File类字符输入流和输出流用来对文件进行读写：默认底层用UTF-8解码</p><p>具体的读写方法和字节流一样。</p><h3 id="字节转字符流"><a href="#字节转字符流" class="headerlink" title="字节转字符流"></a>字节转字符流</h3><p>网络编程中字符流一般很少去直接读，默认都按操作系统编码去读。怕编码不一致，一般都是用字节流读，在程序中转化成字符流</p><ol><li><p>InputStreamReader（常用）</p><p>字节输入流按照编码转化成字符输入流，如下面代码，将字节流数据，用GBK编码解码成字符流。一般还会将这个流转化成BufferedReader。</p></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">InputStreamReader <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InputStreamReader(<span class="hljs-params">req</span>.<span class="hljs-params">getInputStream</span>,<span class="hljs-string">&quot;GBK&quot;</span>)</span><br><br></code></pre></td></tr></table></figure><ol><li><p>OutputStreamWriter</p><p>字节输出流，按照编码转化成字符输出流，比较少用，也通常转化成BufferedWriter</p></li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">OutputStreamWriter osw = <span class="hljs-keyword">new</span> <span class="hljs-type">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileOutputStream</span>(<span class="hljs-string">&quot;a.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br></code></pre></td></tr></table></figure><h3 id="3-BufferedReader（常用）"><a href="#3-BufferedReader（常用）" class="headerlink" title="3. BufferedReader（常用）"></a>3. BufferedReader（常用）</h3><p>缓冲字符流，将普通字符流转户成缓冲字符流。返回一个字符串，不需要我们去定义字符串长度</p><p>普通字符流每次read操作都会从底层获取字节转化一次，而BufferedReader则会有缓存区，所以有<strong>多次read操作时，推荐将先创建基础的额FileReader或InputStreamReader再转化成BufferedReader</strong></p><p>核心方法：readline()，一行一行读取，返回String，没有下一行了返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bfr</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.conf&quot;</span>))<br> <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br> <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br> <span class="hljs-keyword">while</span>((temp=bfr.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>strBuffer.append(temp);<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">    <br>### <span class="hljs-number">4.</span> BufferWriter<br>    <br></code></pre></td></tr></table></figure><pre><code class="hljs">bufferWriter.write(message)：在message中，默认一次写一行<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>## 泛型<br><br>如果用object类型作为容器的接受，接受所有数据。这样取回来需要强制类型转化。<br><br>### <span class="hljs-number">1.</span> 泛型类和泛型接口<br><br></code></pre></td></tr></table></figure></code></pre><p>public class Demo<T>{}<br>public interface Demo<T>{}</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>泛型类，<span class="hljs-strong">**创建对象时指定参数类型。**</span><br><br></code></pre></td></tr></table></figure><p>List<Integer> list &#x3D; new ArrayList<Integer></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>泛型接口<br><br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; 用泛型接口创建普通类，在类编写时指定参数类型，编写借口的方法全设为T，比较少用<br>  class EmployeeDao implements baseDao<Employee>{<br>        接口中的方法中的参数全变成了Employee<br>  }<br>  &#x2F;&#x2F; 用泛型接口创建泛型类，在创建对象时指定类型<br>  class Demo<T> implements Generator<T> {}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">2.</span> 泛型方法<br><br>方法中使用泛型不一定是泛型方法，**只有在方法访问权限和返回值中间加入泛型声明，此方法成为泛型方法**。一般是static方法<br><br></code></pre></td></tr></table></figure><p>public static <T extents Serialize> t out(Class<T>){}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">3.</span> 泛型通配符？<br><br></code></pre></td></tr></table></figure><p>List<?> list;public void out（Info<?> info）{}   表示可以传入任何类型的Info泛型类<br>public void out(Demo&lt;? extents Math&gt;) 传入Demo泛型对象必须是Math的子类          </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><span class="hljs-meta">### 4. 泛型上下界</span><br><br>可以在**泛型声明中加入<span class="hljs-keyword">extends</span>**，来规定能够使用类型的上界：代表的传入的泛型类型只能是这个类或者这个类的子类。**<span class="hljs-keyword">super</span>关键字**则是传入当前类或当前类的父类<br><br>泛型类和泛型方法使用上下界：<br><br></code></pre></td></tr></table></figure><p>public void out(Demo&lt;? extents Math&gt;) 传入Demo泛型对象必须是Math的子类<br>public class Demo<T extents Math>{ }这个泛型类只能指定Math的子类类型<br>public <T extents Math> void out(T t){}   这个泛型方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment"># 集合</span><br><br>[常问基础题](https:<span class="hljs-regexp">//</span>juejin.im<span class="hljs-regexp">/post/</span><span class="hljs-number">5</span>e18879e6fb9a02fc63602e2<span class="hljs-comment">#heading-3)</span><br><br>- Iterator迭代器<br><br>是Collection类的父接口，容器对象通过iterator方法获取自身的迭代器，用于取出自身的元素。[集合数据结构](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_29631809/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">72599708</span>)<br><br></code></pre></td></tr></table></figure><p>Iterator<String> iterator &#x3D; list.iterator();<br>while(iterator.hasNext()){<br>  System.out.println(iterator.next(););<br>  it.remove();<br>}</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">## List接口</span><br><br><span class="hljs-keyword">add</span>，<span class="hljs-keyword">set</span>(<span class="hljs-built_in">int</span>)，<span class="hljs-keyword">get</span>(<span class="hljs-built_in">int</span>)，<span class="hljs-keyword">remove</span>(<span class="hljs-built_in">int</span>)，contains(obj)<br><br>（有序可重复）元素按照索引有序排列，元素值可以重复，**按照索引取值**<br><br>- 对于contains方法，对list的每一个元素调用了<span class="hljs-keyword">equals</span>(obj)，如果是对象，需要重写<span class="hljs-keyword">equals</span>方法才能生效。比如我们经常验证id相等就算作同一对象。字符串也有contains方法<br><br><span class="hljs-meta">### **1. ArrayList**</span><br><br>因为[底层](https:<span class="hljs-comment">//blog.csdn.net/zxt0601/article/details/77281231)采用数组，所以在开头或者中间位置插入或删除数据，后面元素位置都要移动，**增删慢**。[线程不安全](https://blog.csdn.net/u012859681/article/details/78206494)</span><br>数组决定了ArrayList随机读取快，**查询快或者说遍历快**，JDK <span class="hljs-number">8</span>将ArrayList的初始创建长度，由<span class="hljs-number">10</span>该到了<span class="hljs-number">0</span>，创建List更快。<br><br>list允许元素为<span class="hljs-literal">null</span>。Vector（Stack是Vector的一个FIFO栈子类）到JCL中的CopyOnWriteArrayList<br><br>[直接用LinkedList构建链栈](https:<span class="hljs-comment">//blog.csdn.net/top_code/article/details/8650910)</span><br><br>可以用LinkedList来模拟栈（先进后出）和队列（先进先出）<br><br><span class="hljs-meta">### 2. LinkedList（双向链表实现）：</span><br><br>底层采用双向链表（可以用queue），所以插入和删除数据，其他元素都不会变化，时间复杂度永远是O(<span class="hljs-number">1</span>)<br><br>插入删除块，读区遍历慢。<br><br>- LinkedList的<span class="hljs-keyword">add</span>/<span class="hljs-keyword">remove</span>就是一个队列。<span class="hljs-keyword">add</span>/offer入栈，<span class="hljs-keyword">remove</span>/pool出栈（removeFirst）<br><br>  peek取头部节点，push/pop相当FIFO栈<br><br>  Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;()<br><br><span class="hljs-meta">## Set接口</span><br><br><span class="hljs-keyword">add</span>，contains，<span class="hljs-keyword">remove</span>，<span class="hljs-keyword">set</span>集合不能根据索引获取值，只能利用迭代器迭代所有数据<br><br><span class="hljs-meta">### **HashSet**</span><br><br>HashSet底层基于HashMap，存储形式为哈希表，重写hashCode和<span class="hljs-keyword">equals</span>：大体根据hashCode值和数组的长度进行计算出存储的下标；如果下标的位置无元素，那么直接存储；如果有元素，那么使用要存入的元素和该元素进行<span class="hljs-keyword">equals</span>方法，如果结果为真，则已经有相同的元素了，**直接不存（HashMapKey不变，覆盖<span class="hljs-keyword">value</span>）**；如果不相等，那么进行存储，以链表的形式存储。<br><br>- 重写<span class="hljs-keyword">equals</span>方法。先判断内存地址，在判断属于的类，再比较属性的值。<br>- 重写hashcode()方法：<span class="hljs-keyword">this</span>.name.hashcode()<br><br><span class="hljs-meta">### TreeSet</span><br><br>TreeSet基于TreeMap，存储形式为二叉树，适合大量数据的存储，<span class="hljs-number">30</span>几层就<span class="hljs-number">10</span>亿数据多了，**必须继承Comparable接口，重写compareTo方法**，否则第二次插入直接报错。<br><br><span class="hljs-keyword">add</span>方法调用TreeMap的put（key，PRESENT），存到Entry&lt;k,v&gt;(key,<span class="hljs-keyword">value</span>,parent)，第一个parent为<span class="hljs-literal">null</span>，这个节点就成为根。**对象所属的类需要实现Comparable接口，或者给TreeSet集合传递一个Comparator接口对象**。<br><br><span class="hljs-meta">## Map接口</span><br><br>put（key，<span class="hljs-keyword">value</span>），<span class="hljs-keyword">get</span>(key)，containsKey，containsValue，<span class="hljs-keyword">remove</span>，<span class="hljs-function">entrySet</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"><span class="hljs-string">&quot;key&quot;</span></span>)</span>==<span class="hljs-literal">null</span>也可以实现containsKey的效果。如果**插入重复的key，key值保持原来的，<span class="hljs-keyword">value</span>将会覆盖**<br><br><span class="hljs-meta">### HashMap</span><br><br>基于哈希表实现，对象作为键时，必须在对象类中重写hasCode和<span class="hljs-keyword">equals</span>方法。<br><br>JDK <span class="hljs-number">8</span>当调用put方法时才将数组长度初始化为<span class="hljs-number">16</span>；链表长度大于<span class="hljs-number">8</span>，数组长度大于<span class="hljs-number">64</span>时，此个索引位置全部使用红黑树进行存储<br><br>[遍历map](https:<span class="hljs-comment">//blog.csdn.net/zdb292034/article/details/80665364?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)的方法：（Map基本不用来遍历）转化成set，然后用set的for或者迭代器遍历</span><br><br>```java<br><span class="hljs-number">1.</span> 用entrySet返回entrySet集合，然后调用Set的迭代器或者<span class="hljs-keyword">for</span> each循环。<br>Set&lt;Entry&lt;Person,String&gt;&gt; entrySet = map.entrySet();<br><br><span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span>(<span class="hljs-params">Entry&lt;Person,String&gt; entry : entrySet</span>)</span>&#123;<br>  System.<span class="hljs-keyword">out</span>.println(entry.getKey()+<span class="hljs-string">&quot;---&quot;</span>+entry.getValue());<br>&#125;<br><span class="hljs-number">2.</span> 用keySet将key返回成一个<span class="hljs-keyword">set</span>集合，迭代这个<span class="hljs-keyword">set</span>集合的同时通过<span class="hljs-keyword">get</span>(key)打印<span class="hljs-keyword">value</span><br>   Set&lt;String&gt; keySet = map.KeySet();<br><span class="hljs-keyword">for</span>(String key:keySet)&#123;<br>    sout(map.<span class="hljs-keyword">get</span>(key));<br>  &#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>HashTable（淘汰，<a href="https://zhuanlan.zhihu.com/p/31614308">ConcurrentHashMap</a>替代）：是HashMap的线程安全类，不允许null key（hashmap允许）。</p><p>HashMap多个线程同时put的时候会线程不安全，给每个Segment上锁，size()方法，所有segment的元素加起来，所有segment的修改次数加起来</p><p>ConcrrentHashMap用了Segment，将HashMap分块，降低了锁的粒度</p></li><li><p>LinkedHashMap是HashMap子类，底层用链表代替HashMap的数组，相比HashMap迭代更慢（插入也稍慢），但是因为是链表，插入顺序得以保存，输出顺序和输入顺序相同</p></li></ul><h3 id="哈希表存储"><a href="#哈希表存储" class="headerlink" title="哈希表存储"></a>哈希表存储</h3><p>哈希主要是为了找方便，哈希函数的结果会是一个地址区间。哈希算法，尽量降低冲突。一般来说先重写equals，重写HashMap。哈希的Contains&#x2F;get(key)是最快的（查找，直接去算的），但是Hash底层是数组，而数组最大长度是int，所以Hash算法不适合千万级数据，这时候我们用tree来解决查找问题</p><p>0.75的负载因子，在<a href="https://zhuanlan.zhihu.com/p/50479555">时间复杂度和空间复杂度</a>之间的平衡（加载因子低，冲突低，查找性能高。加载因子高，）<a href="https://zhuanlan.zhihu.com/p/31614195">高并发的哈希</a></p><ul><li><p>String重写了hashcode()：31*h+val[off++]，包装器重写hashcode()：(int)Value</p><p>我们重写hashcode时和<a href="https://blog.csdn.net/javazejian/article/details/51348320">equals</a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重写equals,String底层用的比较String长度，然后再挨个比较字符数组</span><br><span class="hljs-number">1.</span> 判断是否内存地址相等<br><span class="hljs-number">2.</span> 判断obj instance of 类<br><span class="hljs-number">3.</span> <span class="hljs-built_in">this</span>.name.equals(obj.name)&amp;&amp;<span class="hljs-built_in">this</span>.no==obj.no;<br><span class="hljs-comment">//重写hashcode()，String底层用了31*字符ACSII吗</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashcode</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.hashcode()+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integet</span>(no).hashcode;<br>  <span class="hljs-comment">// 或者直接no也可以</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>HashMap底层：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扰动函数，JDK8只扰动1次了</span><br>Static <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span>&#123;<br>  <span class="hljs-keyword">return</span> (h=<span class="hljs-built_in">this</span>.hashcode())^(h&gt;&gt;&gt;<span class="hljs-number">16</span>)<br>&#125;<br>hash = hash(key.hashcode)<br><span class="hljs-comment">// 我觉得这种位运算设计非常精妙，一般通过十进制取余运算达到均匀分配，按位与就是二进制的取余运算，2^n（0+N个1，结果完全取决于hashcode后几位）结果会和取余一致（0-15之间）</span><br>indexFor()&#123;<span class="hljs-keyword">return</span> hash&amp;(length-<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//等同与hash%length</span><br>  按位与得到的数，小于两个数之间的最小值，结果永远不会超过数组长度。<br>  length是<span class="hljs-number">16</span>的倍数，这样让按位与运算结尾是<span class="hljs-number">1</span>（奇数），计算结果可以偶，可以是奇数。可以实现奇偶平均分配。取值比较广<br><span class="hljs-comment">// 达到边界就拓容，防止哈希冲突严重</span><br>拓充空间：resize&#123;size++ &gt; threshold&#125;     length直接就扩大两倍，ArrayList拓容<span class="hljs-number">1.5</span>倍<br>拓容的边界值：capacity*loadfactory。    容量（<span class="hljs-number">16</span>倍数）*加载因子（默认<span class="hljs-number">0.75f</span>），<br>    <br><span class="hljs-comment">// resize，在高并发情况下，同时resize形成带环链表，让下一次读形成死循环</span><br>  执行 transfer方法<br><br></code></pre></td></tr></table></figure><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>底层是二叉树，put自定义对象作为key，对象所属的类需要实现Comparable接口，或者给TreeMap集合传递一个Comparator接口对象。需要排序、大数据存储数据时，用到Map结构。<strong>treemap.descendingSet可以返回降序set</strong></p><p>重写compareTo方法，和equals一样，判断传入对象obj是否属于这个对象，是则强转为该类型。然后就是调用String里的compareTo方法</p><ul><li><p><a href="https://blog.csdn.net/qq_25827845/article/details/53870329">String重写的compareTo方法</a>：返回从左到右第一个不同的字符的ASCII码差，长字符和短字符相同，返回两个字符的length差。</p><p>我们可以通过</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//  如果要实现对象里的字符串排序，直接调用String的排序就可以了,自定义CompareTo</span><br>Student s = (Student)obj;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.name.compareTo(s.name)==<span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-comment">// 数字按差值比比较，相等时，再按名字</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stuno-obj.stuno;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(obj.name);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二叉树存储"><a href="#二叉树存储" class="headerlink" title="二叉树存储"></a>二叉树存储</h3><p>降低查找的复杂度，有序（排列有序，升序）。</p><p>第一个元素，那么直接存入，作为根节点，下一个元素通过compareTo的返回值（返回值为0时，底层认为相同元素），在底层决定往左右哪边查找，正数向节点的右边查找，负数向节点左边超招，等于节点就不存储。直到有他的位置存储为止</p><ul><li><p>第一次put，判断根是否为空，为空，将第一个元素存为根节点</p></li><li><p>第二次，造型（向上转型）成Comparable，设置parent &#x3D; t那个entry，执行K.compareTo(root.key)</p><p>每一个Treeset里的元素调用CompareTo方法与obj比较，比obj大，返回正数（TreeSet底层再把比较元素放到obj前面），比obj小，返回-1。</p></li></ul><p><strong>完全二叉树</strong>：只有h-1可以度小于2，h-1如果有叶，在最左边、满二叉树：一共有2^n-1个节点。</p><p><strong>红黑树</strong>：根是黑，叶是黑，红相连的两个节点是黑，任何一个节点到叶子经过的黑色节点相同。满足这个性质，左右子树会非常平衡</p><p><strong><a href="https://www.jianshu.com/p/fc5e16b5c674">TreeSet算法：</a></strong></p><p>实现了Map.Entry，boolean color &#x3D; black；</p><p>新插入的节点永远是红色，看父节点是不是黑色，如果黑，左旋</p><p>比较器排序：额外自定义一个类实现Comparetor接口&lt;对象泛型&gt;，重写compare方法，然后在创建 TreeSet 的时&#96;候，把比较器对象作为参数传递给 TreeSet。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Set&lt;Person&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">TreeSet</span>&lt;Person&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">Comparetor</span>&lt;Person&gt;)<br>Collections.sort(list,<span class="hljs-keyword">new</span> <span class="hljs-type">Comparator</span>&lt;Person&gt;()&#123;<br>  <span class="hljs-keyword">public</span> int compare(Person2 o1, Person2 o2)<br>            &#123;<br>            <span class="hljs-keyword">if</span>(o1 == <span class="hljs-literal">null</span> || o2 == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>            &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>集合操作类，全是静态方法，排序、搜索、替换</p><ul><li>addALL(list,a,b,c )方法：将多个参数同时add到list集合中</li><li><a href="https://blog.csdn.net/u013256816/article/details/50899416">Comparator</a>方法：自定义类实现Comparator，重写Compare方法，优先于自然排序（CompareTo）</li><li>把Set转化成Lis</li></ul><p>考试加油，同昨日进步，共勉，这不算打扰（我说了算），劳资溜了，不用回</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用brew去管理一些后台进程</title>
    <link href="/2022/03/24/%E5%85%B6%E4%BB%96/8.%20brew/"/>
    <url>/2022/03/24/%E5%85%B6%E4%BB%96/8.%20brew/</url>
    
    <content type="html"><![CDATA[<p>brew对于命令行的程序，起到一个打包编译的作用，ARM版的brew通常只能安装ARM版的程序。</p><p>brew常用的命令brew list&#x2F;search&#x2F;info&#x2F;intall&#x2F;unintall&#x2F;deps&#x2F;outdated&#x2F;update&#x2F;upgrade等。</p><p>在命令前加入<code>arch -x86_64</code>模拟x86环境运行。</p><p>建议brew安装mysql&#x2F;redis，且推荐安装以后使用<code>brew services</code>来管理服务的启动和关闭。以mysql为例，<code>brew services start mysql</code>和<code>mysql.server start</code>同样可以启动mysql，要注意brew的启动在重启后不会失效，使用brew有利于统一多服务的管理。</p><h3 id="macOS多版本-node"><a href="#macOS多版本-node" class="headerlink" title="macOS多版本 node"></a>macOS多版本 node</h3><p>可以使用nvm和n这样常用的node管理工具来管理安装，也可以使用node link&#x2F;unlink不同的node版本</p>]]></content>
    
    
    <categories>
      
      <category>Mac相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GIT要注意的几个问题</title>
    <link href="/2022/03/09/%E5%85%B6%E4%BB%96/5.%20GIT/"/>
    <url>/2022/03/09/%E5%85%B6%E4%BB%96/5.%20GIT/</url>
    
    <content type="html"><![CDATA[<p>Git的commit版本是整个库的版本，不是单独具体到某个文件的版本，处于不同commit的文件，可能就是相同的。</p><p>Git有三大分区，工作区、暂存区和版本库。文件add后，存在于stage区中（暂存区），通过commit到版本库。</p><h4 id="关于切换分支的问题"><a href="#关于切换分支的问题" class="headerlink" title="关于切换分支的问题"></a>关于切换分支的问题</h4><p>切换分支时，如果暂存区中有文件在修改，会有两个情况。第一种是两个分支里的文件内容相同时，checkout切换分支会将暂存区中的修改内容保留；第二种情况是两个分支里的文件就不同时，会提示禁止checkout（-f 强制切换时，会丢失修改内容），此时不想commit，可以使用<code>git stash push</code>，临时存储暂存区修改，push通常省略，使用<code>git stash pop</code>恢复最后一次stash的暂存区。</p><h4 id="pull、push"><a href="#pull、push" class="headerlink" title="pull、push"></a>pull、push</h4><p>pull相当于fetch+merge操作。</p><p>本地和远程的相同分支，本质上是两个分支，pull相当于现将远程分支merge到本地merge，合并规则和本地之间的不同分支是相同的。</p><p><strong>与远程分支同步时</strong>，如果本地有暂存区修改，一定要<strong>先commit，再pull，再push</strong>。</p><p>merge过程中，暂存区不会修改，IDEA的merge过程，远程分支别人已经修改过一版，此时pull正常merge到本地，再commit，可能会将别人的代码覆盖而Git不会出现任何提示，而先commit，再pull，过程中Git会提示解决冲突。本地解决完冲突后，最好再次pull，再push。</p>]]></content>
    
    
    <categories>
      
      <category>GIT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/03/09/%E5%85%B6%E4%BB%96/6.%20HTTP/"/>
    <url>/2022/03/09/%E5%85%B6%E4%BB%96/6.%20HTTP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>HTTP协议</p><p>在<strong>TCP&#x2F;IP四层网络结构（应用层，传输层TCP&#x2F;UDP，网络层IP，网络接口层）</strong>中。OSI七层</p><p>发送端在层与层间传输数据时，每经过一层都会被加上网络层的首部信息，接收端每经过一层都会删除一条当前网络层的首部信息。</p><p>HTTP1&#x2F;2是<strong>基于TCP&#x2F;IP</strong>应用层的协议（<a href="https://zhuanlan.zhihu.com/p/68012355">HTTP3基于UDP</a>），最初只用来传输HTML且只有GET方法，97年的1.1版本用了将近20年，2015年诞生了HTTP 2。</p><ul><li><p><strong>无连接</strong>；<strong>即请求时连接，请求完释放连接</strong>，服务器收到请求，返回响应，服务器收到应答，断开连接。</p><p>无连接设计之初目的是为了不占用网络资源，如果一个网页有包含许多请求（如很多图片），多次连接降低了网络效率，所以在HTTP 1.1时，产生了<strong>Connection: Keep-Alive</strong>，默认开启，使客户端和服务器在keep-alive规定时间内保持连接TCP连接，只有设置Connecttion：false时取消</p></li><li><p><strong>无状态</strong>：<strong>每个HTTP报文是独立的</strong>，服务器对于前面请求处理的信息，后面请求不能直接获取到前面请求中的信息。</p><p>设计之初降低了服务器的压力，但是在动态Web时代，无状态特性阻碍了应用程序的实现。于是产生了记录状态的<strong>Cookie和Session</strong>。</p><p><strong>Cookie</strong>：会话保存在客户端，Cookie只能保存是字符串（4KB），切勿保存重要数据，<strong>默认浏览器关闭时清除session</strong>，除非服务端设置setMaxAge。一个cookie就是一个（String，String），使用request.getCookies()获得一个cookie数组，getName()获得cookie的name，getValue获得cookie的value</p><p><strong>Session</strong>：会话保存在服务器，在调用getSession时创建，判断cookie中有无sessionid，无就生成sessionID，定义一个会话状态，并将sessionid通过Cookie发送给浏览器。</p><p>restful的前后端分离项目中一般会使用 access_token，因为前后端分离项目跨域，使用cookie里的sessionID不方便认证状态，这个token和session_id是一个意思。<a href="https://juejin.im/entry/5bd921fce51d45686d40b2d6">分离Cookie参考</a></p><p><a href="https://blog.csdn.net/hxfghgh/article/details/82840613">关于Cookie</a></p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/24860273">TCP和UDP</a></p><h2 id="HTTP报文解析"><a href="#HTTP报文解析" class="headerlink" title="HTTP报文解析"></a>HTTP报文解析</h2><p><strong>Start line 起始行 — Header Filed 头部字段 — 空行 — Entity Body 实体主体</strong></p><p>起始行和头部字段构成HTTP报文头部（Headers）</p><h3 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1. HTTP 请求报文"></a>1. HTTP 请求报文</h3><p><strong>请求行–HTTP头字段–空行–请求体</strong></p><p>浏览器只支持POST和GET这两种请求方法，实际上还有HEAD，TRACE，PATCH，PUSH等请求方法。一般纯查询请求可以使用GET，其他请求用POST。由于只能是ASCII编码，所以GET不能传输中文</p><ol><li>**GET请求：放在请求行(URL)**，会暴露在地址栏，有长度限制，会被主动Cache，只有默认编码。</li><li><strong>POST请求：放在报文体</strong>，无长度限制，可以传输中文。POST请求也可以在请求行中写入数据，这时候类似GET请求，但一般没人会在form action或ajax url中加入这种处理</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/mix/76.html?name=kelvin&amp;password=123456</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.fishbay.cn<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) <br><span class="hljs-attribute">Conetent-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JASSDHUHFUBSIUFHI=232DWUFHI<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,en;q=0.6<br><br><span class="language-ini"><span class="hljs-attr">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span></span><br><span class="language-ini"></span><br></code></pre></td></tr></table></figure><h3 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2. HTTP 响应报文"></a>2. HTTP 响应报文</h3><p><strong>状态行–HTTP头–空行–响应体</strong></p><p>这个http响应的响应正文时纯文本，可以时html等等</p><p>Etag，Vary: User-Agent，Cache-Control等都是常用的响应头设置</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 20 Feb 2017 09:13:59 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain;charset=UTF-8<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><span class="hljs-attribute">Pragrma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Thu, 01 Jan 1970 00:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Proxy-Connection</span><span class="hljs-punctuation">: </span>Keep-alive<br><br><span class="language-css">&#123;&quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-number">200</span>,<span class="hljs-string">&quot;notice&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;follow&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;forward&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;comment&quot;</span>:<span class="hljs-number">0</span>&#125;</span><br><span class="language-css"></span><br></code></pre></td></tr></table></figure><h3 id="3-HTTP-Header"><a href="#3-HTTP-Header" class="headerlink" title="3. HTTP Header"></a>3. HTTP Header</h3><p>HTTP Header中有四种Header Filed：</p><p>通用头：请求头和响应头都可使用字段</p><p><strong>Cache-Control</strong>、Pragma、Date、Via</p><p>Connection：keep-alive&#x2F;close</p><p>实体头：用于定义Entity Body（数据）的一些信息的头字段</p><p>Location（重定向跳转就设置了这个）、</p><p><strong>Content-Type</strong>、Conetent-Encoding（响应内容的压缩）、</p><p>Expire、Allow、Etag（资源标识符）、Last-Modify</p><p><strong>请求头：</strong></p><p>User-Agent、Host、Referer、<strong>Accept</strong>（希望接收的类型）</p><p><strong>响应头：</strong></p><p>Age（在代理服务器中缓存秒数）、Server（提供服务器信息）、Vary</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP缓存也称为Web缓存，主要就是客户端本身的<strong>浏览器本地缓存</strong>和代理服务器缓存（正向代理和反向代理）。<strong>只能缓存GET请求</strong>的内容，缓存css、js、HTML等静态资源</p><p><a href="https://juejin.im/post/5c417993f265da61285a6075">缓存Cache-Control参考</a></p><p>在HTTP1.0时代，pragma和Expires两个头字段可以设置缓存策略。</p><p>到了HTTP1.1以后，又有<strong>Cache-Control</strong>设置缓存策略，HTML meta、动态网页中可以设置。</p><pre><code class="hljs">public：允许客户端和代理服务器缓存private（GET请求默认）：允许客户端缓存**no-cache**：允许客户端缓存，但每次快取需要由服务器请求缓存是否过期，未过期返回304。协商缓存**no-store：不允许缓存。****max-age=60**：允许缓存保留60秒（自带no-cache），没有这个属性就会去查找expire。强缓存must-revalidate</code></pre><p>这些设置缓存的头字段时通用头字段，当request和response都设置时，Apache或nginx等服务器可以设置听哪个request还是response的。</p><p><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/">浅谈在代理环境中的 DNS 解析行为</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA出现</title>
    <link href="/2022/03/09/%E5%85%B6%E4%BB%96/7.IDEA%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/09/%E5%85%B6%E4%BB%96/7.IDEA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>出现找不到常量符号的报错，本次做的是删除target下的文件夹，更改编译版本到7</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础整理</title>
    <link href="/2022/03/07/Java/1.%20Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/07/Java/1.%20Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="流程语法"><a href="#流程语法" class="headerlink" title="流程语法"></a>流程语法</h2><ul><li><p>break跳出控制语句（switch，for等），continue跳出本次循环（用于for循环），return跳出整个函数</p></li><li><p>在判断语句中，<strong>单纯判断、char、byte、short、int和String（JDK 7 ）的值情况</strong>可以用switch代替if-else<br>switch效率比if-else高，但是灵活度非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    System.out.println(<span class="hljs-string">&quot;this is one.&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    System.out.println(<span class="hljs-string">&quot;Others.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="包与访问权限"><a href="#包与访问权限" class="headerlink" title="包与访问权限"></a>包与访问权限</h2><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>包是为了管理类而存在，不同包可以存在相同的类名，包的逻辑结构代表class文件的文件夹逻辑结构。当我们需要使用非本包中的类时，用<strong>import关键字</strong>导入包中的类，导包<strong>可以导入包中的具体类或者用通配符导入所有类</strong></p><ul><li><p>普通导入</p><p>import com.zhuxin.*导入com.zhuxin包中所有的类<br>import com.zhuxin.Demo导入com.zhuxin包中的Demo类</p></li><li><p><strong>静态导入</strong>（JDK5），导入后直接可使用静态属性，而不用使用System.out这样调用属性</p><p>import static java.lang.System.out 导入System类中的out属性</p><p>import static java.lang.Integer.* 导入Integer类中的所有静态属性</p></li></ul><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ul><li><p><strong>类的访问权限</strong>，比较少使用，default权限的类，导包后也无法使用</p><ol><li>不加权限（default）：修饰的类只能在本包中使用</li><li>public：修饰的类在导包后，能在所有包中使用</li></ol></li><li><p><strong>属性与方法的访问权限</strong></p><p>约束成员在其他类中建立对象以后，对象能否调用其方法和属性看其属性和方法的访问权限，方法定义的局部变量是不能被访问权限控制的。</p><ol><li><p>private：除了在本类中，均不能被访问(即使是继承了父类的子类)</p></li><li><p>不加权限（default&#x2F;friendly）：可以被同包的类访问，又称为包级访问权限</p><p>普通类&#x2F;抽象类的方法和属性不写时默认都是包级访问权限</p></li><li><p>protected：可以被同包类和不同包子类访问</p></li><li><p>public：可被所有包的类访问</p><p>接口中的所有方法（抽象，default，static）和属性只能是public权限，默认不写</p></li></ol></li></ul><h2 id="Java常用关键字"><a href="#Java常用关键字" class="headerlink" title="Java常用关键字"></a>Java常用关键字</h2><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this关键字是JVM在创建对象后产生的一个指向对象本身的一个指针，根据这个原理，得出this的作用</p><ol><li><p>this.属性&#x2F;方法：<strong>强调本类的成员属性或成员方法</strong>，内部类中的this强调内部类本身的成员属性和方法</p><p>子类重写父类方法后，父类的this.方法会指向子类重写过的方法（不加this也是）。</p><p>子类覆盖父类属性后，父类的this.属性始终指向父类属性（不加this也是）</p></li><li><p>this()：<strong>在构造方法中调用本类的其他构造方法，注意必须写在构造方法第一行。</strong></p><p>场景举例：写一个包含所有字段的构造函数，然后其他部分字段构造函数去调用这个全字段构造函数</p></li><li><p>this：<strong>代指当前对象</strong>，返回调用this的实例对象</p><p>比如父类方法中存在return this，父类对象调用这个方法返回父类对象，子类对象调用这个方法，返回子类对象</p></li></ol><h3 id="Super关键字"><a href="#Super关键字" class="headerlink" title="Super关键字"></a>Super关键字</h3><ol><li><p>super.属性&#x2F;方法：当子类和父类中存在<strong>相同的属性或方法</strong>时，<strong>强调当前对象父类中的属性和方法</strong></p></li><li><p>super()：<strong>在子类构造方法中，调用父类构造方法。super方法必须写在构造方法的首行，不能和this()一同使用</strong></p><p>子类构造方法默认在第一行使用了super()调用了父类中的无参构造方法。如果父类不存在无参构造方法将会报错，注意给父类编写带参构造方法后需要注意再编写一个无参构造方法。</p></li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol><li>被final<strong>修饰的类不能被继承</strong>，一般很少将类设计为final类，除非真的不需要继承或者为了安全考虑。</li><li>修饰的变量为不可更改的常量（修饰基本数据类型值不能改变，修饰引用类型不能更改指向的对象，引用不是对象，String对象值不能改变说的就是这个理）</li><li>被final<strong>修饰的方法不能被子类重写</strong>，明确禁止子类重写此方法时才用final修饰方法，类的private方法会隐式地被指定为final方法。</li></ol><h3 id="static关键字（类方法，类属性）"><a href="#static关键字（类方法，类属性）" class="headerlink" title="static关键字（类方法，类属性）"></a>static关键字（类方法，类属性）</h3><p>static修饰的属性（不能修饰局部变量）和方法，成为静态属性或静态方法，静态方法和静态属性属于类，不依赖与某个对象，可以直接<strong>通过类名调用静态属性和静态方法</strong>，但遵循访问权限控制。<strong>静态方法只能直接调用静态变量和静态方法</strong>，所以在Main使用方法，要么是静态方法，要么是通过对象调用的普通方法。</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ol><li><p><strong>全局变量：定义在方法外的变量，有默认值</strong>，分为成员变量和静态变量：</p><ul><li>*成员变量（实例变量）**定义在类的所有方法外。加载在堆内存中，随着对象产生或消亡；</li><li><strong>静态变量（类变量）</strong>，成员变量基础上加用static关键字修饰属性，类加载（class文件读取到内存中）时产生，存在时间比所在对象本身还要久。</li></ul></li><li><p><strong>局部变量：定义在方法中的变量，如main方法中定义的变量就是局部变量，无默认值，使用前必须要初始化。</strong></p><p>局部变量的创建在栈内存中，随着方法产生和消亡，即随线程产生或消亡</p></li></ol><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><h4 id="重载-overloadding"><a href="#重载-overloadding" class="headerlink" title="重载(overloadding)"></a>重载(overloadding)</h4><p><strong>返回值和方法名不变，参数变化形成新的方法。</strong></p><p>当没有对构造方法进行重载时，默认带一个无参构造方法，当对构造方法重载了一个有参数构造方法后，无参构造方法小时，</p><p>可变长度参数（如String… args）：0个或多个参数</p><p>使方法的参数列表内可以传入不定长度的参数，只能有一个可变长参数且放于所有参数后面，在要实现不定长度参数的类型后加 **…**。Java的可变参数在编译为字节码后，在方法签名中就是以数组形态出现的（将几个参数打包成数组），所以二者同时不可重载</p><h4 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h4><p>重写方法是继承性的重要性质，重写的方法<strong>返回值，方法名和形参都不能改变，子类重写方法访问权限不能比父类方法严格</strong>。</p><p>重写方法后不仅使用方法时会指向子类重写方法，而且子类和父类的方法（加不加this都是）调用都指向子类的重写方法，即使在父类方法中使用this.方法。</p><p>属性不存在重写，一般说覆盖，覆盖后父类方法（加与不加this都是）永远调用的是父类属性，子类方法调用的是子类的属性。</p><h1 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h1><h2 id="1-封装性"><a href="#1-封装性" class="headerlink" title="1. 封装性"></a>1. 封装性</h2><p>面向对象的核心思想之一就是封装性（Encapsulation），封装就是将属性和方法这些具像的东西“装”到一个类中，私有化属性，<strong>提高安全性</strong>，<strong>隐藏实现细节</strong>。</p><p>我们使用API或者各种框架时，封装性使得我们忽略实现细节，只要去使用即可。</p><h2 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h2><p>子类extents父类，获得父类的属性和方法（除private属性和方法），并<strong>通过重写方法和增加新方法，形成新的类，复用父类的代码</strong>，这就是OOP中的继承性的作用。C++使用多继承，Java支持单继承（Single inheritance）。</p><p>静态方法没有重写，类似于属性写了一个同名属性</p><p>实用证明，继承关系（class-based）确实会带来一些代码量的减少，但是带来了子父类的强耦合，所以更现代的流派更推荐使用组合关系（prototype-based），也就是像Java的接口一样，Go语言已经完全采用prototype-based关系。</p><h4 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h4><p>内部类是一个编译时的概念，<strong>编译完成以后成为两个不同类</strong>。内部类增强了Java多重继承功能。内部类中的this关键字指的内部类成员属性和方法，外部类名.this才是强调外部内的成员属性和方法。<strong>内部类可以直接调用外部类的private属性。</strong></p><p><strong>成员内部类</strong>、局部内部类（写在方法中）、<strong>匿名内部类（创建的时候，只能用外部的final属性）</strong>、</p><p><strong>静态内部类（static关键字，只能访问外部类static属性，可以脱离外部类创建）</strong>。</p><p>当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现（）。</p><p>在外部类方法中使用new关键字创建内部类对象。</p><p>外部类.内部类 对象名 &#x3D; new 外部类( ).new 内部类( )</p><p>内部类 对象名 &#x3D; 外部类对象.new 内部类( )</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是特殊的类，用abstract声明，<strong>至少含一个抽象方法</strong>。由于没有足够的信息来构造一个具体的对象时，所以与普通类的区别是<strong>不能被直接实例化</strong>，<strong>必须被继承才能实例化</strong>，但是可以像普通类一样<strong>单继承类，多继承接口</strong>。</p><p><strong>抽象方法：用abstract修饰方法且无方法体的方法（可以为protect和public）</strong>，抽象类可以没有抽象方法，有抽象方法的抽象类被继承时，子类必须实现抽象方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口也是一种特殊的类，用interface声明接口类，用implement来声明实现接口。</p><p>接口是功能的集合，<strong>接口的设计是主要为了多态性</strong>，应该选择接口来实现多态性，。</p><p><strong>接口的属性只能静态全局常量</strong>（默认不写public static final），接口方法<strong>一般是公有抽象方法</strong>（默认可写public abstract）。</p><p>Java8以后，接口方法可以是<strong>default method和static method</strong>，这使得接口和抽象类很像，default一般用于老接口的拓展。static方法一般通过接口类来调用。一般不推荐再方法中使用这两种方法</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>Java中存在3种类，普通类，抽象类和接口。抽象类在继承方面的特性和普通类一样。</p><ul><li><p>普通类&#x2F;抽象类只能继承一个普通类&#x2F;抽象类（单继承），但可以实现多个接口（多继承）</p><p>抽象类实现接口时，<strong>不强制抽象类实现接口中的抽象方法</strong>，留给继承这个抽象类普通类去实现。</p></li><li><p>接口可以多继承接口，<strong>当普通类实现子接口时，强制实现类重写子接口和父接口中的所有抽象方法</strong></p><p>Java接口继承层级越多，功能就越多。</p></li></ul><p>实例化子类时，会先初始化父类（非实例化创建对象，那调用的时什么方法），继承的父类的属性和方法是相对独立存在的</p><h2 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3. 多态性"></a>3. 多态性</h2><p>Java中的多态是一个父类类型对不同子类对象同一方法的不同响应，解耦合</p><ul><li><strong>对象 instanceof 类</strong>：返回布尔值 对象是这个类或者类的子类时，返回true</li><li>各种地方（工厂、IO、Service）多态父类或者父接口接受子类对象，就实现了去耦合。只需要改他的实现</li><li>向下转型（downcast）：父类引用重新强转回子类。当父类对象要调用子类的独有方法时需要向下转型</li></ul><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52191321">多态原理</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务</title>
    <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>事务是一组原子性的SQL语句，在 MySQL 中只有使用了Innodb 数据库引擎才支持事务。Java中编程式事务connection&#x2F;sqlsession来操作事务</p><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p>一次增删改，加排他锁（一般行锁）和GAP锁（间隙锁，innodb_locks_unsafe_for_binlog），并且会自动提交事务，事务完毕，才会释放锁给其他拿到。</p><p>乐观锁和悲观锁是一种思想，乐观锁适合读多写少，悲观锁适合写多读少。<a href="https://juejin.im/entry/5b63d9056fb9a04fcb5b7ff9">mysql悲观锁</a>：</p><ul><li><p>行锁，拿行锁之前，数据库会自动拿到<a href="https://www.zhihu.com/question/51513268">意象锁</a>，表级锁</p><p>共享锁&#x2F;读锁（S锁，Shared Lock）：lock in share mode</p><p>排他锁&#x2F;写锁（X锁，Exclusive Lock）：for update</p></li></ul><p>禁止&#x2F;开启自动提交：<strong>SET AUTOCOMMIT&#x3D;0&#x2F;1</strong></p><p>显式的开启事务：<strong>BEGIN</strong>或者<strong>START TRANSCATION</strong>；写SQL；<strong>COMMIT</strong></p><p>设置保存点：<strong>SAVEPOINT 保存点名</strong>：</p><p>回滚：<strong>ROLLBACK</strong>：未commit前使用，回滚到事务最开始的地方。ROLLBACK TO 保存点名：可以回退到位置</p><p>设置隔离级别：SET session&#x2F;global <strong>TRANSCATION ISSOLATION LEVEL</strong> ，</p><p>查看事务隔离级别：SELECT @@tx_isolation;</p><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><p>不同隔离级别下的加锁方式是不同的。<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">mysql事务下的锁机制(美团)</a>、<a href="https://blog.csdn.net/lemon89/article/details/51477497">参考文2</a>、<a href="https://dbaplus.cn/news-11-2518-1.html">数据库的锁机制</a></p><ul><li><p>READ-UNCOMMITTED：最低隔离级别</p><p>任何情况都不加锁，并且其他事务没有提交前就可以被读到值</p></li><li><p>READ-COMMITTED：</p><p>读不加锁，但其他事务增删改需要commit以后才能读到值；增删改加排他锁（条件有索引加行级锁，无索引加表级锁）</p></li><li><p>REPEATABLE-READ：Innodb默认级别，可重复读取本次事务中多次读同一个数据时，</p><p>普通读（MVVC快照读）不加锁，如果事务内没有增删改操作，则不会刷新读的版本</p><p>update &#x2F;select …… for update（当前读）&#x2F;delete 这些操作，进行的是当前读，然后加锁。</p><p>三种锁（默认都X锁）：Record行级锁、GAP间隙锁、Next-Key锁</p><p>唯一索引，只对记录加行锁；非唯一索引加三种锁；where &lt;、&gt;和between，只会加GAP锁；</p></li><li><p>SERIALIZABLE：串行级别</p><p>数据库完全使用悲观锁，读用读锁，写用写锁。</p></li></ul><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据可能会不同，因为其他人提交。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h3 id="ACID事务"><a href="#ACID事务" class="headerlink" title="ACID事务"></a>ACID事务</h3><p>原子性（要么都执行，失败回滚）、隔离性（并发事务隔离）、一致性（一个状态转化另一个状态，但数据完整性一致）、持久性（事务完整，数据库改动是永久的）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库复杂查询</title>
    <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>数据库查询最常用的是连接查询，格式上类似<code>select * from A left join B on A.no=B.no</code>，连接的A表和B表也常为子查询</p><p>本金、利息、罚息（逾期后，本金*罚息利率）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/</url>
    
    <content type="html"><![CDATA[<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><h4 id="resultType和resultMap："><a href="#resultType和resultMap：" class="headerlink" title="resultType和resultMap："></a>resultType和resultMap：</h4><p>select方法取到的结果集可以直接被映射，两种形式resultType和resultMap。</p><h4 id="一对一关联association"><a href="#一对一关联association" class="headerlink" title="一对一关联association"></a>一对一关联association</h4><p>对象一对一依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.Emp&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1. 通过左外连接，连接子表的结果返回到这个association的resultMap里。</span><br><span class="hljs-comment">  如果返回的结果用association中用自定义的映射代替resultMap，association要带一个javaType属性，代表属性类型--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Departments.deptMap&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 2. 通过嵌套查询，将查询的结果返回到这个里面来 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;department_id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;Departments.selectById&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="一对多关联Collection"><a href="#一对多关联Collection" class="headerlink" title="一对多关联Collection"></a>一对多关联Collection</h4><p> 对象一对多依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1. 需要在collection里指定resultMap（可以自定义）和ofType，接受左外连接传来的数据</span><br><span class="hljs-comment">使用连接查询，里面不能使用分页，否则collection里数据截断。</span><br><span class="hljs-comment">默认javatype是List，可省略List</span><br><span class="hljs-comment">如果ResultMap的type写util.Map(很少)的话，此时必须指定collection的JavaType--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.mybatis.model.RoleInfo&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;entity.Menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;menuname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createdate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modifydate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifydate&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select <br>  ram.roleid as id,<br>  ro.name as name,<br>  me.id as menuid,<br>  me.name as menuname,<br>  me.description,<br>  me.parent,<br>  me.createdate,<br>  me.modifydate <br>  from roleandmenu ram<br>  left outer join role ro on ram.roleid=ro.id<br>  left outer join menu me on ram.menuid=me.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2. 使用嵌套查询，会用column指定的列，作为第二次查询的参数，在这个查询里指定resultType或者ResultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;entity.Role&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roleid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;rolename&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;menulist&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;roleMap&quot;</span>&gt;</span><br>  select id,name from role<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectMenu&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.mybatis.model.Menu&quot;</span>&gt;</span><br>  select m.id,m.name<br>  from menu m join roleandmenu ram on m.id=ram.menuId<br>  where ram.roleId=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mahoking/article/details/46811865">批量增删改</a></p><h4 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h4><p>mysql<a href="https://blog.csdn.net/mytt_10566/article/details/74279105">主键自增长</a>生成：使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”Employee_id”**，在SQL语句中不写自增长字段。</p><p>可以不用<a href="https://blog.csdn.net/death05/article/details/53098328?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">trim</a>，插入为空就不插入了，但是要指定jdbcType。用trim+if判断空值，不需要指定jdbcType。批量插入parameterType依然写类（类地址？）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;department_id&quot;</span>&gt;</span> <br>  insert into departments(default, department_name) values (#&#123;department_id&#125;,#&#123;department_name&#125;) <br>  // 或者insert into departments(department_name) values (#&#123;department_name, jdbcType=varchar&#125;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="update元素"><a href="#update元素" class="headerlink" title="update元素"></a>update元素</h4><p>不修改的值保持原值，传入一个对象。字符串写判断是否为空字符串或null，传入对象时要带其id</p><p><strong>基本数据类型和对象等数据只需要判断是否为null</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Employee&quot;</span>&gt;</span><br>update employee <br>  //set同样会帮我们忽略最后的“，”<br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    //注意if中的first_name是对象中，不是数据库中<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt;</span><br>      first_name = #&#123;first_name&#125;,<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary!=null &quot;</span>&gt;</span> <br>      salary = #&#123;salary&#125;, <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span> <br>  where employee_id = #&#123;employee_id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="lt-delete-gt-元素"><a href="#lt-delete-gt-元素" class="headerlink" title="&lt;delete&gt;元素"></a>&lt;delete&gt;元素</h4><p>一般使用单ID删除，可以在service层循环ID，带调用单删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parametertyep</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>delete from employee where employee_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int[]&quot;</span>&gt;</span> <br>  delete from employee where employee_id in <br>  <span class="hljs-comment">&lt;!-- collection只能写array或者list，即数组或集合，但是orderIDs --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="lt-select-gt-元素"><a href="#lt-select-gt-元素" class="headerlink" title="&lt;select&gt;元素"></a>&lt;select&gt;元素</h4><p>条件查询，用Map&lt;String, Object&gt;作为传入参数，可以不写parameter</p><p>where 1&#x3D;1？</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;mapper namespace=<span class="hljs-string">&quot;com.lee.Mapper.Employee&quot;</span>&gt;<br>  &lt;select id=<span class="hljs-string">&quot;select&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;Employee&quot;</span>&gt; <br>    select * from employee e left outer join Dept d on e.deptno=d.deptno<br>    <span class="hljs-comment">// 可以用where，mybatis会自动帮我们忽略</span><br>    &lt;trim prefix=<span class="hljs-string">&quot;where&quot;</span> prefixOverrides=<span class="hljs-string">&quot;and | or&quot;</span>&gt; <br>      &lt;!-- first_name是Map中的Key，用#&#123;first_name&#125;获取到value --&gt; <br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;first_name!=null and first_name!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> #&#123;first_name&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;job_id!=null and job_id!=&#x27;&#x27;&quot;</span>&gt; <br>        <span class="hljs-type">and</span> <span class="hljs-variable">job_id</span> <span class="hljs-operator">=</span> #&#123;job_id&#125; <br>      &lt;/<span class="hljs-keyword">if</span>&gt; <br>    &lt;/trim&gt; <br>&lt;<span class="hljs-type">if</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;index!=null&quot;</span>&gt;<br>      limit #&#123;index&#125;,#&#123;pageSize&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt; <br>  &lt;/select&gt;<br>  &lt;!-- 计数--&gt;<br>  &lt;select id=<span class="hljs-string">&quot;count&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>    select <span class="hljs-title function_">count</span><span class="hljs-params">(*)</span> from employee<br>    &lt;where&gt;<br>      &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;firstName !=null and firstname!=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">first_name</span> <span class="hljs-operator">=</span> # &#123;firstName&#125;<br>      &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>  &lt;/select&gt;<br>  <br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h4 id="SQL块"><a href="#SQL块" class="headerlink" title="SQL块"></a>SQL块</h4><p>用动态SQL块代替常用于字段，一个表中的字段可能很多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empSql&quot;</span>&gt;</span><br>  first_name,job_id,salary,department_id <br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--字段用include动态SQL块代替，类似于alias --&gt;</span><br>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empSql&quot;</span>/&gt;</span> from employe<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js的函数和方法的区别</title>
    <link href="/2021/04/12/front/3.%20js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/12/front/3.%20js%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天偶尔看到，JS中的函数和方法这两个概念竟然有些许差别😅，在我印象中，大部分编程语言里，函数和方法没有任何区别，大概的意思就是通过名字调用的一段代码，只是C&#x2F;C++中，习惯称为函数（function），Java中习惯称方法（method），而在JS中，我们知道也习惯称function，即函数。</p><p>在vue.js中，经常的一种写法就是，将函数绑定到对象上，大概就是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-attr">getMessage</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>getMessage</code>就是对象hua的一个函数，更确切的，这种<strong>绑定到对象上的函数就是方法</strong>，需要通过<code>hua.getMessage</code>或者<code>hua.getMessage()</code>去调用。ES6对于书写这种函数，推荐写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hua = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hua&quot;</span>,<br>  <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;He is cute&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈函数式编程</title>
    <link href="/2021/04/12/front/4.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/04/12/front/4.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><code>axios.get(&#39;url&#39;).then(response =&gt; (this.info = response))</code></p><p>箭头函数常用来书写匿名函数</p><p>前端异步。</p>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2021/04/12/Java/Java%20Web/"/>
    <url>/2021/04/12/Java/Java%20Web/</url>
    
    <content type="html"><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h4 id="tomcat的结构"><a href="#tomcat的结构" class="headerlink" title="tomcat的结构"></a>tomcat的结构</h4><p>tomcat里有<strong>一个server</strong>，在Tomcat的server.xml中配置server标签的信息来配置server。   </p><p>server有一个至多个service<strong>（默认一个），service的核心组件是connector和container</strong></p><p><strong>connector</strong>：解析请求，并封装request和response两个对象。（底层创建socket接收请求），默认service自带两个connector，一个解析HTTP请求，一个解析AJP请求，与Apache服务器集成时，会采用AJP解析。tomcat不设置编码时，默认编码是iso8859-1，即tomcat默认以iso8859-1编码接收get参数。在connector中可以设置tomcat服务器的编码，这样请求</p><p><strong>container</strong>：servlet容器，有四种父子关系的container。connector过来的request根据容器pipiline-valve模式下到达请求service方法。</p><p><strong>–host</strong>：存放所有web项目的文件夹，appBase属性指定哪个文件夹为host容器，默认webapps</p><h4 id="tomcat的请求过程"><a href="#tomcat的请求过程" class="headerlink" title="tomcat的请求过程"></a>tomcat的请求过程</h4><p>服务器启动后会依次初始化各容器，Context容器会读取项目中web.xml的映射来初始化wrapper。servlet的wrapper会封装一个InvokerServlet，jsp会封装JspServlet，静态资源封装一个DefaultServlet对象</p><ul><li>收到请求后，connector根据请求信息创建request和response对象</li></ul><ul><li><p>请求在container层层根据请求的信息定位到wrapper，并通过里面的Filter</p></li><li><p>访问到service方法 &#x2F; 取到静态页面</p></li></ul><p>当service方法中有输出流时，则会用response封装返回，connector发送到客户端</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>创建类并继承HttpServlet类我们就创建了一个Servlet。</p><p> 映射原则：多个URL可以映射到一个Servlet上，但一个URL只能映射一个servlet，映射路径必须是绝对路径</p><ul><li><p>@WebServlet ( name&#x3D;”testServlet”,vaule&#x3D;”&#x2F;test” loadonstart&#x3D;1 ，initparam&#x3D;@WebInitParam(name&#x3D;”name”, value&#x3D;”小明”) )</p></li><li><p>web.xml</p></li></ul> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jackson<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.oracle.servlet.TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>remoteAddress<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>202.97.233.50<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 自定义的URL  建议带/servlet/ --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>获取初始化参数，先获取<strong>ServletConfig</strong>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">servletParam</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletConfig.getInitParameter(<span class="hljs-string">&quot;servletParam&quot;</span>)<br><span class="hljs-type">String</span> <span class="hljs-variable">contextParam</span> <span class="hljs-operator">=</span> request.getServletContext().getInitParameter(<span class="hljs-string">&quot;contextParam&quot;</span>);<br></code></pre></td></tr></table></figure><p>获取session对象：HttpSession session &#x3D; request.getSession()<br>获取servletContext对象：SerlvletContext application &#x3D; request.getServletContext()、request.getSession.getServletContext()、this.getServletConfig.getServletContext()</p><h4 id="servlet跳转"><a href="#servlet跳转" class="headerlink" title="servlet跳转"></a>servlet跳转</h4><p>两种转发方式，将数据转向jsp地址</p><p>请求转发跳转：</p><ul><li>request.getRequestDispatcher(url).forward(request,response)，对应JSP动作中&lt;jsp:forward page&#x3D;””&#x2F;&gt;</li><li>request.getRequestDispatcher(url).include(request,response)，对应JSP动作&lt;jsp:include page&#x3D;””&#x2F;&gt;</li></ul><p>重定向跳转（返回301）：response.sendRedirect(request.getContextPath+”&#x2F;b.jsp”)  </p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>实现Filter接口就成为了过滤器，重写doFilter，拦截jsp和servlet请求，包括重定向请求，请求转发跳转请求</p><ul><li>使用web.xml配置，类似servlet</li><li>使用注解配置（实际开发）</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@WebFilter(&#123;<span class="hljs-string">&quot;*.jsp&quot;</span>,<span class="hljs-string">&quot;/controller/*&quot;</span>&#125;)</span><br></code></pre></td></tr></table></figure><ul><li>重写doFilter方法，filterchain.doFilter(request, response)写在最后放行，不放行，进行重定向跳转或者请求转发跳转就可以了</li></ul><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>用一个类实现这些Listener接口就生成了对应的监听器</p><ul><li>HttpSessionListener接口</li></ul><p>当服务器创建了一个Session对象，执行实现类的createSession方法。通常用来坚挺在线人数</p><p>最常见用处：<strong>统计当前在线人数</strong>，</p><p>简易统计在线人数（不太行，一般用redis计数可以）：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> sessionCreated(HttpSessionEvent httpSessionEvent) &#123;<br><span class="hljs-keyword">count</span>++;<br><span class="hljs-comment">//用这个监听器提供的event获取到session，再获取到application对象存入</span><br>httpSessonEvent.getSession().getServletContext().setAttribute(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-keyword">count</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> sessionDestroy()&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>ServletContextListener</li></ul><p>监听application对象的创建和销毁（服务器启动和销毁），服务器启动时想要启动一些多线程，放置数据，可以配置这个对象</p><ul><li>ServletContextAttributeListener</li></ul><p>监听application对象的属性操作，如新建，删除，修改一个Attribute属性触发</p><h2 id="Jsp基本语法"><a href="#Jsp基本语法" class="headerlink" title="Jsp基本语法"></a>Jsp基本语法</h2><ol><li><strong>&lt;% java %&gt; 自动放在生成servlet的service方法中</strong></li><li><strong>&lt;%! java %&gt;自动放在生成servlet中</strong> ，很少使用，因为很少定义全局变量，比如要写新的方法给service调用就写这里面，但是没必要把方法封装在jsp中，单独写一个类就行</li><li>**&lt;%&#x3D; 有返回值Java代码 %&gt;**，等于 &lt;% out.print( 返回值代码); %&gt;，将值打印到HTML中</li><li>JSP支持注释：jsp注释：&lt;%– –%&gt;、html注释（会生成到html代码中）：<!-- --></li></ol><p>Java注释（会生成在servlet中）：&#x2F;&#x2F;，&#x2F;*  *&#x2F;</p><h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><p><strong>内置对象</strong>：jsp生成的servlet中的service方法中，生成了已经赋完值的一些对象，这些变量引用的对象叫内置对象，可以在jsp的Java代码中使用，很少使用</p><p>容器对象：attribute是一个Map（String，Object）：setAttribute()、getAttribute(key)、<strong>removeAttribute(key)</strong></p><h3 id="1-response对象（HttpServletResponse）"><a href="#1-response对象（HttpServletResponse）" class="headerlink" title="1. response对象（HttpServletResponse）"></a>1. response对象（HttpServletResponse）</h3><p>返回数据、设置HTTP头，</p><p>getWriter()、getOutputStream()、setContentType()</p><p>setHeader(“Cache-Control”,”no-cache”)。SSM代替：&lt;mvc:cache-control max-age&#x3D;”3600” cache-public&#x3D;”true”&#x2F;&gt;</p><p>addCoodie( Cookie对象 )、response.setStatus(302)、response.sendError(404)：并且会向web.xml中设置的错误页面跳转</p><h3 id="2-request对象（HttpServletRequest）"><a href="#2-request对象（HttpServletRequest）" class="headerlink" title="2. request对象（HttpServletRequest）"></a>2. request对象（HttpServletRequest）</h3><p>生命周期：HTTP请求到达Servlet，就创建一个request对象，当servlet返回response时，request生命周期结束</p><p>getParameter(key) 、getParameterValues(key)、getParemeterNames()  、getParemeterMap()</p><p><strong>request.getCookies();</strong></p><p>获取请求方式：getmethod()、获取IP：getRemoteAddr()、获取客户端主机名：getRemoteHost()</p><ul><li>URL全路径（包含域名）：getRequestURL()</li><li>URI资源路径（不包含域名）：getRequestURI()，相比ServeletPath()带项目名，一般使用这个来获取</li><li>当前这个controller的路径：getServletPath()。如&#x2F;test，war包和jar包项目都一样，不带项目名字</li><li>获取ServletContext对象：getServletContext</li></ul><h3 id="3-ServletContext"><a href="#3-ServletContext" class="headerlink" title="3. ServletContext"></a>3. ServletContext</h3><ul><li>上下文路径：request.getServletContext().get<strong>ContextPath</strong>() ，一般来说就是项目名，如&#x2F;shop，为root项目时，为空</li><li>war包项目下的绝对路径：request.getServletContext().getRealPath(“&#x2F;upload”)，Springboot的jar包项目不要使用</li></ul><h3 id="4-session（HttpSession）"><a href="#4-session（HttpSession）" class="headerlink" title="4. session（HttpSession）"></a>4. session（HttpSession）</h3><p>调用request.getSession方法时生成，先通过request.getCookies获取到所有cookie，再查有没有name等于JSESSIONID并且在内存中存在的cookie，有的话，新session引用指向已存在的session（同时也会addCookie）。</p><p>不存在就新建一个session对象，设置name&#x3D;sessionID，value&#x3D;sessionID值，保存到到response中，再次访问时，通过sessionID，找到服务器中的session。维持一个状态。Cookie默认关闭浏览器就销毁（即Max-age默认为-1）。<a href="https://zhuanlan.zhihu.com/p/63061864">cookie，session，token</a></p><p>获取当前request的session里的sessionId：session.getId()</p><p>立即销毁：session.invalidate()</p><p>定时销毁：session.setMaxInactiveInterval(60 * 60 * 3)</p><p>tomcat服务器的session是对session无操作时，默认30分钟。可以通过tomcat的web.xml或者项目的web.xml配置有效期：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>application（ServletContext）、pageContext（PageContext类）</p><p>服务器可以设置cookie中的Path属性，只有当cookie访问服务器的路径为指定的时，这个cookie才有效</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul><li>out对象（JspWriter）</li></ul><p>out对象是的实例，JspWriter关联了PrintWriter对象。print()  和println() 、flush()、clearBuffer()、getBufferSize()</p><ul><li><strong>config</strong>（Servlet的配置对象）、<strong>exception</strong>（异常对象）和<strong>page</strong>（ 很少使用，就是jsp转化成servlet后的实例，this）</li></ul><h3 id="JSP三大指令元素"><a href="#JSP三大指令元素" class="headerlink" title="JSP三大指令元素"></a>JSP三大指令元素</h3><p>在页面最前面写入**&lt;%@ 指令 指令动作 %&gt;**</p><ul><li>page：指定页面级别配置，指定pageEncoding和contentType和导包</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;%@<span class="hljs-built_in"> page </span><span class="hljs-attribute">contentType</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>%&gt;<br>等同于response.setEncording();<br>&lt;%@<span class="hljs-built_in"> page </span><span class="hljs-attribute">import</span>=<span class="hljs-string">&quot;java.util.Date&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><ul><li>Taglib：主要用于导入标签库</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib uri=<span class="hljs-string">&quot;&lt;http://java.sun.com/jsp/jstl/core&gt;&quot;</span> prefix=<span class="hljs-string">&quot;c&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><ul><li>include指令：导入jsp</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>最终只会会转化成<span class="hljs-number">1</span>个servlet，和include动作相似（最常用）<br>&lt;%@ include  file=xxx.jsp&gt;<br><span class="hljs-regexp">//</span> JSP包含标签（动作），表示页面要包含的页面，会转化两个servlet，类似thymeleaf的th:include=<span class="hljs-string">&quot;&quot;</span><br>&lt;jsp:include page=<span class="hljs-string">&quot;a.jsp&quot;</span>&gt; <br><span class="hljs-regexp">//</span> JSP跳转标签（动作），相当于request.getrequestDispatcher(<span class="hljs-string">&quot;a.jsp&quot;</span>).forward(req,resp);<br>&lt;jsp:forward page=<span class="hljs-string">&quot;showUser.jsp&quot;</span>&gt;<br>&lt;jsp:param value=<span class="hljs-string">&quot;admin@test.com&quot;</span> name=<span class="hljs-string">&quot;email&quot;</span>/&gt;<br>&lt;jsp:param value=<span class="hljs-string">&quot;888888&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>/&gt;<br>&lt;/jsp:forward&gt;<br></code></pre></td></tr></table></figure><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL表达式只能在JSP中使用，不能写在jsp的Java代码中，就是为了替代&lt;%&#x3D; %&gt;或者&lt;c:out&gt; ，用EL表达式如果没取到值自动处理为空字符串，不会空指针（null）异常。</p><h3 id="1-域对象"><a href="#1-域对象" class="headerlink" title="1. 域对象"></a>1. 域对象</h3><p>有四个域范围对象，对应jsp四个域对象：pageScope、requestScope、sessionScope、applicationScope</p><ol><li>${域范围对象.username}</li><li>省略域范围对象，按顺序从page&#x2F;request&#x2F;session&#x2F;application对应的域对象</li></ol><p>如果获取到的Attribute是map集合：${ 域范围对象.key1[“key2”]}取得map中的元素</p><h3 id="2-param"><a href="#2-param" class="headerlink" title="2. param"></a>2. param</h3><p>${param.username}代表执行getParameter(“username”)，很少用</p><h3 id="3-pageContext对象"><a href="#3-pageContext对象" class="headerlink" title="3. pageContext对象"></a>3. pageContext对象</h3><p>属于page作用域名，一般用来在获取request，然后获取到项目路径：**${pageContext.request.contextPath}**或者</p><h3 id="4-EL表达式运算符"><a href="#4-EL表达式运算符" class="headerlink" title="4. EL表达式运算符"></a>4. EL表达式运算符</h3><p>jEL表达式取值以外，还可以使用EL表达式进行算术运算和逻辑运算，逻辑和比较运算符常用于&lt;c:if&gt;中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;p.age+1 &#125;</span><span class="hljs-regexp">//</span>算数运算符<br><span class="hljs-variable">$&#123;!(p.age == 1) &#125;</span><span class="hljs-regexp">//</span>比较运算符（eq）<br><span class="hljs-variable">$&#123;p.age==1 &amp;&amp; p.age==20 &#125;</span><span class="hljs-regexp">//</span>逻辑运算符（and）<br><br></code></pre></td></tr></table></figure><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>在jsp中创建的javabean对象，<strong>默认page</strong>作用域，可以指定保存其他作用域。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 用原生JSP标签生成并设置JavaBean,很少用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:useBean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lee.Person&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;request&quot;</span> <span class="hljs-attr">typeSpec</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:setProperty</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:getProperty</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;demo&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 利用JSTL的方式设置javabean的属性--&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:set</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;person&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lee&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 设置name的属性，不是新建 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:catch</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;没有name这个参数&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lee&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;request&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">c:catch</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:remove</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="forEach（迭代标签）"><a href="#forEach（迭代标签）" class="headerlink" title="forEach（迭代标签）"></a>forEach（迭代标签）</h3><p>迭代标签还有fortokens()，用分割符分割字符串再迭代输出，在forEach的每次循环中，自动先向pageContext的attribute存储本次循环的状态对象，状态对象中包含了index和count属性代表循环的索引和循环次数</p><p>items：要循环的对象，只能是Java集合或者数组、var：每个元素、begin：从哪个索引开始，默认0、end：默认size-1</p><p>step，索引增加次数， 默认是1、varstatus 获取循环索引，count数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 我们通过循环打印一个表格--&gt;</span><br>&lt;% <br>List<span class="hljs-tag">&lt;<span class="hljs-name">Employee</span>&gt;</span> empList = (List<span class="hljs-tag">&lt;<span class="hljs-name">Employee</span>&gt;</span>)request.getAttriute(&quot;empList&quot;);<br>for(Employee emp:empList) &#123; <br>%&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&lt;%= emp.getName()%&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&lt;%= emp.getNo() %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>&lt;% &#125; %&gt;<br><br><span class="hljs-comment">&lt;!-- 用EL表达式+JSTL代替--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">iterms</span>=<span class="hljs-string">&quot;$&#123;requestScope.empList&#125;&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;emp.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;emp.no&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="lt-c-if-gt-（条件标签）"><a href="#lt-c-if-gt-（条件标签）" class="headerlink" title="&lt;c:if&gt;（条件标签）"></a>&lt;c:if&gt;（条件标签）</h3><p>标签中使用test属性+EL表达式条件判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">c:if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$&#123;count==10 &#125;&quot;</span>&gt;</span><br>is ten<br><span class="hljs-tag">&lt;/<span class="hljs-name">c:if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">c:if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$&#123;count!=10 &#125;&quot;</span>&gt;</span><br>is not ten<br><span class="hljs-tag">&lt;/<span class="hljs-name">c:if</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="lt-c-choose-when-otherwise-gt"><a href="#lt-c-choose-when-otherwise-gt" class="headerlink" title="&lt;c:choose-when-otherwise&gt;"></a>&lt;c:choose-when-otherwise&gt;</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">c:choose</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">c:when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$&#123;count==5 &#125;&quot;</span>&gt;</span><br>is five<br><span class="hljs-tag">&lt;/<span class="hljs-name">c:when</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">c:when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$&#123;count==10 &#125;&quot;</span>&gt;</span><br>is ten<br><span class="hljs-tag">&lt;/<span class="hljs-name">c:when</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">c:otherwise</span>&gt;</span><br>other<br><span class="hljs-tag">&lt;/<span class="hljs-name">c:otherwise</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">c:choose</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="格式化标签库"><a href="#格式化标签库" class="headerlink" title="格式化标签库"></a>格式化标签库</h3><p>除了核心标签库，JSTL还提供了格式化标签库、SQL标签库、XML标签库和常用函数标签库等。日期对象格式化成指定对象，</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;fmt:formatDate <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;e.hireDate &#125;</span>&quot;</span> <span class="hljs-attribute">pattern</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>&gt;&lt;/fmt:formatDate&gt;<br></code></pre></td></tr></table></figure><h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><ol><li>创建处理标签的Java类，让这个类<strong>继承SimpleTagSupport</strong>，重写doTag方法，getJspContext只有继承这个类才能够使用getJspContext之类的方法</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTag</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleTagSupport</span></span>&#123;<br><span class="hljs-meta">@Override</span> <br>public void doTag() <span class="hljs-keyword">throws</span> <span class="hljs-type">JspException</span>, <span class="hljs-type">IOException</span> &#123;<br><span class="hljs-type">JspWriter</span> out = getJspContext().getOut();<br>out.println(<span class="hljs-string">&quot;Hello Custom Tag!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在WEB-INF下创建后缀是.tld的标签库描述文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tag-class</span>&gt;</span>test.TestTag<span class="hljs-tag">&lt;/<span class="hljs-name">tag-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body-content</span>&gt;</span>empty<span class="hljs-tag">&lt;/<span class="hljs-name">body-content</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attribute</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attribute</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>在其taglib中加入tag标签</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs buke">&lt;@taglib prefix=&quot;my&quot; uri=&quot;test.Tag&quot;&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>今日学习随机</title>
    <link href="/2021/03/30/front/2.%20js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/03/30/front/2.%20js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>声明变量作用域方面，var定义的变量作用域是函数级，但是代码块里声明的var变量，代码块外又允许访问（所以var有很多不合理的地方）。let是升级版的var，用来代替var，作用域为标准的代码块级。const是代码块级作用域的常量。</li><li>var能够重复声明变量，而let和const不允许被重复声明。</li><li>并且var声明的变量存在<strong>变量提升</strong>，即在用var声明变量代码之前，函数就可以调用这个变量，默认值为undefined，而let&#x2F;const声明的变量，则会提示变量not defined（let）或者error（const）。</li></ol><h2 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h2><p>在模块化出现之前，js通过script标签直接引入另一个js，引入顺序必须固定，而维护成本高，现在主要的两种js模块化规范。</p><ul><li><p>Common JS模块化规范（nodejs）：require&#x2F;exports</p></li><li><p>ES6模块化规范：<a href="https://www.jianshu.com/p/541256d8abb3">import&#x2F;export</a>。</p></li></ul><p>export你需要导出的变量或者函数，import时需要带{}，而export default导出的变量不需要带{}。export可以导出未声明变量或者函数，export default只能导出已声明的变量、函数、或者匿名模块，一个文件中只能使用一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> name;<br><span class="hljs-keyword">export</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  data : &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br>---<br>b.<span class="hljs-property">js</span><br>---<br><span class="hljs-keyword">import</span> random,&#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(random.<span class="hljs-property">data</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>在学习vue或者初次看到vue项目时，有一些疑问，比如vue组件、实例、vue文件之间的区别是什么new Vue()操作产生vue实例，组件类似于是可被Vue实例反复引用的。</p><p>vue组件是可复用的vue实例。类似于自定义标签，template属性为编写组件的必须项，props和data属性也较为常用。</p><p>注意编写vue组件时，因为html的自定义属性不能大写，会自动转化成小写，所以注册组件props中的变量，要用小写。</p><p>Vue.component()方法用于全局注册的vue组件，全局组件可以用于所有文件中的new Vue()创建的Vue根实例</p><h3 id="JS驱动vue-js"><a href="#JS驱动vue-js" class="headerlink" title="JS驱动vue.js"></a>JS驱动vue.js</h3><p>此时Vue实例用el元素直接绑定HTML。引入vue.js文件，通过js去直接驱动。用component注册全局组件，组件包含template。</p><p>template中的内容是需要有根节点的</p><h5 id="模块化驱动vue-js"><a href="#模块化驱动vue-js" class="headerlink" title="模块化驱动vue.js"></a>模块化驱动vue.js</h5><p>在js文件中可以import单Vue文件，将Vue文件渲染到的Vue实例上，挂载到指定的HTML上。一般模块化开发中我们只写一个vue根实例。</p><h5 id="单文件组件的优势"><a href="#单文件组件的优势" class="headerlink" title="单文件组件的优势"></a>单文件组件的优势</h5><p>模版语法高亮、全局定义命名不能重复、不支持CSS，而单文件的设置stype的scope属性，css只对单文件生效</p><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><ul><li>默认插槽和具名插槽</li></ul><p>将内容分发权限放到调用的父级，将复杂内容放到父级。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">--- vue 2.6之前:<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>--- vue 2.6后:<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:pre-icon</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中预设位置<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pre-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>作用域插槽</li></ul><p>让父组件访问子组件的值的一种插槽，弥补父组件无法获取到子组件变量值的情况。</p><p>（具名&#x2F;默认插槽）和（作用域插槽）是并列关系，是同时可以使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">--- 父组件从子组件中取数据，vue 2.6之前<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>--- vue 2.6后<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span><br>&#123;&#123;d.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>--- 子组件中slot绑定变量<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h5 id="compute、method、watch"><a href="#compute、method、watch" class="headerlink" title="compute、method、watch"></a>compute、method、watch</h5><p>计算属性能做的，watch都能做。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用npm和yarn遇到的问题</title>
    <link href="/2021/03/29/front/1.%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/29/front/1.%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="使用npm和yarn遇到的问题"><a href="#使用npm和yarn遇到的问题" class="headerlink" title="使用npm和yarn遇到的问题"></a>使用npm和yarn遇到的问题</h4><ol><li><p>关于包管理器npm和yarn</p><p>yarn是在npm的基础之上的包管理器，根据情况选用一个工具即可，都是去读取package.json文件，在一个项目中两者可以同时存在，但是每次构建项目后（初次npm install后），需要固定使用yarn，或者或者npm，当要切换包管理器管理项目时，需要删除node_modules文件夹。</p><p>不同版本的npm管理同一个项目，一般不会出现太大的问题，但是遇到构建问题时，也可以选择删除node_module文件夹和package-lock.json文件。</p><p>遇到一个问题，npm 7构建node旧项目时，会出现构建依赖树冲突问题。</p></li><li><p>node-sass在离线机器上的安装问题</p><p>node-sass还会绕过设置的本地仓库去GitHub去获取，获取不到时会在本地编译，本地编译在win下又依赖python和C++环境，这个问题给我整吐了，怎么也不好解决，尝试过多种方法也无济于事后，找同事在能运行的机器上，拷贝了整个项目先启动看看，后期再去解决npm install安装的问题。</p></li><li><p>vue-cli工具：vue-cli、@vue&#x2F;cli。</p><ul><li>vue init webpack demo。npm run dev</li><li>vue create demo。@vue&#x2F;cli构建的项目，会在本地加入vue-cli-serivice这样的依赖npm serve</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传下载</title>
    <link href="/2020/10/25/%E5%85%B6%E4%BB%96/4.%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2020/10/25/%E5%85%B6%E4%BB%96/4.%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>表单上传：type为file类型的input标签<strong>和enctype&#x3D;multipart&#x2F;form-data</strong>上传数据，不做处理，是同步上传。</p></li><li><p>ajax上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#myinput&quot;</span>).<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-comment">// 这两个必写</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>($(<span class="hljs-string">&#x27;#uploadForm&#x27;</span>)[<span class="hljs-number">0</span>]),<br><span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-Servlet纯流方式-x2F-SmartUpload或Apache-FileUpload"><a href="#1-Servlet纯流方式-x2F-SmartUpload或Apache-FileUpload" class="headerlink" title="1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload"></a>1. Servlet纯流方式&#x2F;. SmartUpload或Apache FileUpload</h4><p>Servlet直接读区获取字节流存储在文件夹，但是无法同时区分普通控件和上传文件</p><p>在Servlet中都能实现上传文件功能简化，实现业务数据和上传的文件同时获取，并且直接write（不需要手动outputStream）</p><p><a href="https://www.jianshu.com/p/e7837435bf4c">FileUpload文件上传参考</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">// 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isMultipart</span> <span class="hljs-operator">=</span> ServletFileUpload.isMultipartContent(req);<br>  <span class="hljs-comment">// 如果不满足要求就立即结束对该请求的处理</span><br>  <span class="hljs-keyword">if</span> (!isMultipart) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// FileItem 是表单中的每一个元素的封装</span><br>    <span class="hljs-comment">// 创建一个 FileItem 的工厂类</span><br>    <span class="hljs-type">FileItemFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskFileItemFactory</span>();<br>    <span class="hljs-comment">// 创建一个文件上传处理器（装饰设计模式）</span><br>    <span class="hljs-type">ServletFileUpload</span> <span class="hljs-variable">upload</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletFileUpload</span>(factory);<br>    <span class="hljs-comment">// 解析请求</span><br>    List&lt;FileItem&gt; items = upload.parseRequest(req);<br>    <span class="hljs-keyword">for</span> (FileItem fileItem : items) &#123;<br>      <span class="hljs-comment">// 判断空间是否是普通控件</span><br>      <span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;<br>        <span class="hljs-comment">// 普通控件</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 上传控件</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> fileItem.getContentType();<br>        <span class="hljs-keyword">if</span> (!contentType.startsWith(<span class="hljs-string">&quot;image/&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 实现简单的错误提示</span><br>          req.setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;亲，您上传的文件格式不正确，请重新上传！&quot;</span>);<br>          req.getRequestDispatcher(<span class="hljs-string">&quot;upload.jsp&quot;</span>).forward(req, resp);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果不是图片类型则不再对请求进行处理</span><br>        &#125;<br>        <span class="hljs-comment">// 随机命名文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + <span class="hljs-string">&quot;.&quot;</span> + FilenameUtils.getExtension(fileItem.getName());<br>        <span class="hljs-comment">// 将上传的文件保存到服务器</span><br>        fileItem.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:/&quot;</span>, fileName));<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件上传"><a href="#2-SpringMVC文件上传" class="headerlink" title="2. SpringMVC文件上传"></a>2. SpringMVC文件上传</h4><p>SpringMVC的上传功能封装了FileUpload组件的功能</p><ol><li>配置FileUpload和common-io的依赖、在SpringMVC配置文件中配置MultipartResover（上传解析器）</li><li>SpringMVC Controller：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span><br><span class="hljs-comment">// 使用MultipartFile类，String ename是其他控件信息，request用于获取绝对路径</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile img, Emp emp ,String ename, HttpServletRequest request)</span>&#123;<br><span class="hljs-comment">// img存储到文件夹相对路径(Web程序的部署路径)</span><br><span class="hljs-comment">//1. 获得上传文件的名字,方便在下载时还原这个名字（3.jpg）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> img.getOriginalFilename(); <br><span class="hljs-comment">//.当前应用程序的部署绝对路径下的upload文件夹</span><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-comment">// 判断文件夹是否存在</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br><span class="hljs-keyword">if</span>(!file.exists())&#123;<br>file.mkdir(); <br>  &#125;<br> <br>  <span class="hljs-comment">//3.应付存储文件的名字重复，为文件重命名</span><br>  <span class="hljs-comment">// 先获得文件的后缀名</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">extendsName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>); <br>  <span class="hljs-keyword">if</span>(index!=-<span class="hljs-number">1</span>)&#123;<br>  extendsName = name.substring(index); <br>  &#125;<br>  <span class="hljs-comment">// 生成唯一的名字</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extendsName; <br>  <br>  <span class="hljs-comment">//4.MultipartFile.transferTo方法代替流输入</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file,fileName);<br>  <span class="hljs-keyword">try</span> &#123;<br>    img.transferTo(savePath); <br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(); <br>  &#125;<br><span class="hljs-comment">// 5 存储数据库，这个照片是员工的属性</span><br>  <span class="hljs-comment">// 保存到相对路径</span><br>  emp.setFilePath(<span class="hljs-string">&quot;/upload/&quot;</span>+fileName); <br>  emp.setFileName(name);<br>empService.save(emp);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;succ&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件下载："><a href="#文件下载：" class="headerlink" title="文件下载："></a>文件下载：</h2><p>a标签在h5的download属性可以通过URL访问到，单独的用控制器下载其实比价少用，真的用的时候可以用流下载</p><p>FormData两种方式定义，append(“myimage”, $(“#myfile”).get(0).files[0]) ）<a href="https://harttle.land/2016/07/04/jquery-file-upload.html">异步上传</a></p><p>cache、processData和contentType为false，防止JQ转码</p><h4 id="1-Servlet纯流方式"><a href="#1-Servlet纯流方式" class="headerlink" title="1. Servlet纯流方式"></a>1. Servlet纯流方式</h4><p><a href="https://www.jianshu.com/p/f450da30f594">纯流文件下载参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">String dataDirectory=req.getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/data&quot;</span>);<br><span class="hljs-comment">// 通过service查询到</span><br>File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dataDirectory, <span class="hljs-string">&quot;secret.pdf&quot;</span>);<br><span class="hljs-keyword">if</span>(file.exists())&#123;<br>  resp.setContentType(<span class="hljs-string">&quot;application/pdf&quot;</span>);<br>  resp.addHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=secret.pdf&quot;</span>);<br>  <span class="hljs-type">byte</span>[] buffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>  FileInputStream fis=<span class="hljs-literal">null</span>;<br>  BufferedInputStream bis=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span>&#123;  <br>    <span class="hljs-comment">// BufferInputStream每次读一块字节相比读一个字节对于文件速度更快。</span><br>    fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>    bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    <span class="hljs-type">int</span> i=bis.read(buffer);<br>    <span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>      os.write(buffer,<span class="hljs-number">0</span>,i);<br>      i=bis.read(buffer);<br>    &#125;<br>  &#125;<span class="hljs-keyword">catch</span>(IOException ioe)&#123;<br>    System.out.println(ioe.toString());<br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-keyword">if</span>(bis!=<span class="hljs-literal">null</span>)&#123;<br>      bis.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fis!=<span class="hljs-literal">null</span>)&#123;<br>      fis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SpringMVC文件下载"><a href="#2-SpringMVC文件下载" class="headerlink" title="2. SpringMVC文件下载"></a>2. SpringMVC文件下载</h4><p> 使用spirng 自带的<strong>ResponseEntity</strong>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException&#123;<br>  <span class="hljs-comment">//获取你文件的文件夹，一般从数据库读区，这里模拟service已经取到路径</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getSession().getServletContext().getRealPath(<span class="hljs-string">&quot;/upload&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1168701023208865792.jpg&quot;</span>; <br>  <span class="hljs-comment">// 1. 获取文件路径</span><br>  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path,filename); <br>  <span class="hljs-comment">//设置header里的ContentDisposition字段，以attachment(下载框方式)打开图</span><br>  <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>(); <br>  headers.setContentDispositionFormData(<span class="hljs-string">&quot;attachment&quot;</span>, downloadFielName);<br>  <span class="hljs-comment">// 2. ResponseEntity返回，返回application/octet-stream : 二进制流数据(最常见的文件下载)。</span><br>  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-type">byte</span>[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2020/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>关于数据库中数据值使用单引号和双引号，之前一直认为是单引号和双引号没有任何区别，第一次使用Oracle时，发现不能使用双引号去表示字符串，才明白<strong>标准SQL中，使用单引号去表示字符串</strong>，MySQL也允许双引号表示字符串，但推荐使用标准的单引号。</p><p>对数据库中数据类型加不加引号也一知半解，实际上，数据库中字符类型和日期类型必需加单引号，而数值类型，如int和decimal，可加单引号也可以不加单引号，但是<strong>在实际应用中，数据库的所有数据类型的值推荐都加上单引号</strong>。</p><p>date&#x2F;datetime&#x2F;timestamp&#x2F;varchar类型都可以存储日期数据，date精度到天，datetime和timestamp精度到秒。不需要进行排序和计算时，使用varchar类型就可以。</p><p>#{ }是预编译替换，所有的的变量都会用单引号包围，${ }是字符串替换，不会加上单引号，传入字符串时，需要手动加上引号<code>&#39;$&#123;name&#125;&#39;</code>，用户指定列名时，比如order by一个输入列名，这时候我们不使用#，需要使用$。</p><h2 id="MySQL语句"><a href="#MySQL语句" class="headerlink" title="MySQL语句"></a>MySQL语句</h2><h3 id="database，schema和instance的区别"><a href="#database，schema和instance的区别" class="headerlink" title="database，schema和instance的区别"></a>database，schema和instance的区别</h3><ul><li>mysql中：database&#x3D;schema（子集为数据库对象），两个关键字同义。</li><li>oracle中：一个instance对应一个database，instance指进程，database指后台进程。某个用户下的数据库对象集合称为schema（有）。oracle创建对象必须要对应一个用户，与mysql和SQLserver不一样</li><li>SQLserver：一个instance对应多个database。服务器.数据库.Schema.对象</li></ul><h3 id="三大数据库设计范式"><a href="#三大数据库设计范式" class="headerlink" title="三大数据库设计范式"></a>三大数据库设计范式</h3><p>1NF：列的原子性。</p><p>2NF：主键依赖&#x2F;取消部分依赖，通过主键来确定唯一的一条记录。非主属性依赖主键</p><p>3NF：取消传递依赖。非主属性除了依赖主键，不互相依赖</p><h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><p>数据库字段设置AUTO_INCREMENT，当insert null或者0时，会实现自增长。</p><p>mybatis mapper.xml中配置使用**useGnerateKeys&#x3D;”true” keyproperty&#x3D;”一般是主键”**这两个属性，在SQL语句中使用default，或者不写这个自增长字段。</p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `m_function` (<br>  `ID` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `ModuleCode` <span class="hljs-type">varchar</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;模块编号&#x27;</span>,<br>  `UpdateUserId` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改人&#x27;</span>,<br>  `UpdateDate` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`ID`)<br>  <span class="hljs-keyword">constraint</span> FK_Name <span class="hljs-keyword">foreign</span> key (user_id) <span class="hljs-keyword">references</span> student(id)<br>  INDEX  index_ModuleCode (ModuleCode)<span class="hljs-comment">-----等于  KEY  index_ModuleCode (ModuleCode)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改表名：alter table emp <code>rename [TO]</code> emp1</p><p>修改表结构：alter table  tb1 add&#x2F;drop&#x2F;<code>modify/change</code></p><p>add&#x2F;drop后面不加column&#x2F;index&#x2F;constraint等修饰时，默认对表的column即列进行操作</p><p>增加索引：alter table tb1 add index idx_score (score)</p><p>添加外键：alter table tb1 add constraint fk_id foreign key(user_id) references tb2(id)</p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>distinct去重：放于select的所有字段前，只有所有列的值一样时，才算重复。</p><p>like模糊查找：<code>%</code>通配符匹配多个字符，<code>_</code>通配符只匹配一个字符。<code>like &#39;li%x_n&#39;</code></p><p><a href="https://blog.csdn.net/qmhball/article/details/7941638">having和where</a>：排先where ，再group，再having，再order by。where是对数据库中的数据筛选，having是对group by聚合后的结果筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">// 查询学生成绩表中两门科目大于80分的同学编号<br>select sno from SC where score&gt;80 group by sno having count(cno) &gt; 2<br></code></pre></td></tr></table></figure><ul><li><p>外连接</p><p>左外链接会显示一个左表的所有数据，右表是辅表，符合条件的右表记录会显示，不符合条件的右表记录将会用null显示。（右外连接相反），左表用第一条记录依次匹配右表记录，如果再右表中匹配到多条记录，则生成有序对。<strong>如果没匹配到一条记录右表记录，这条左表记录依然会显示，右表用null表示，这是外连接和内连接的唯一区别</strong></p></li><li><p>子查询</p><p>子查询条件时时，一个结果匹配用 &#x3D;，多个结果匹配使用 <code>in/exists</code></p><p>子查询大小条件时。一个结果用 &gt;或者&lt;，查询出来多个结果使用<code>&gt; any( 子查询语句 )</code>或者<code>&gt; all ( 子查询语句 )</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/10/02/%E5%85%B6%E4%BB%96/2.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/10/02/%E5%85%B6%E4%BB%96/2.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>^a以a开始</p><p>a$以a结束</p><h4 id="字符代表符号（匹配符）"><a href="#字符代表符号（匹配符）" class="headerlink" title="字符代表符号（匹配符）"></a>字符代表符号（匹配符）</h4><p>[a-z]小写字母、[a-zA-Z0-9]字母和数字</p><p>. 除换行符以外的任意单字符</p><p>\d数字。</p><p>\D非数字</p><p>\w数字，字母或下划线</p><p>\s特殊字符</p><h4 id="数量限定符"><a href="#数量限定符" class="headerlink" title="数量限定符"></a>数量限定符</h4><p>{5}： 前面的一个字符出现5次{1,}：1次以上。{1,3}：1次到3次</p><p>*前面的一个字符出现0次以上</p><p>+前面的一个字符出现1次以上</p><p>？前面的一个字符出现0次或1次</p><h3 id="前瞻和后顾"><a href="#前瞻和后顾" class="headerlink" title="前瞻和后顾"></a>前瞻和后顾</h3><p>正则表达的前后，还未解析字符的称为前面，解析过的称为后面</p><p>a(?&#x3D;b)前瞻，匹配a，且a必须在b的前面</p><p>a(?!b)负前瞻，匹配a，且a的前面不是b</p><p>(?&lt;&#x3D;b)a后顾，匹配a，且a的后面b</p><p>(?&lt;!b)a负后顾，匹配a，且a的后面不是b</p><p>|分成两段，或者</p><p>()圈定一个子串</p><h2 id="JS使用正则表达式"><a href="#JS使用正则表达式" class="headerlink" title="JS使用正则表达式"></a>JS使用正则表达式</h2><p><strong>var regexp &#x3D; &#x2F;正则表达式&#x2F;修饰符</strong>，</p><p>修饰符有i（不区分大小写）和g（全局匹配）</p><p><strong>匹配：regexp.test(str)</strong></p><h2 id="Java使用正则表达式"><a href="#Java使用正则表达式" class="headerlink" title="Java使用正则表达式"></a>Java使用正则表达式</h2><p>Pattern.complile(“”)创建正则对象</p><ul><li><p>匹配验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^[0-9a-zA-Z]\\.&#123;5,10&#125;@[0-9a-zA-z]&#123;2,7&#125;(\\.com|.cn)&quot;</span>)<br>p.matcher(str).matches() <span class="hljs-comment">//Match对象</span><br></code></pre></td></tr></table></figure></li><li><p>以一个正则表达式拆分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br>String[ ] s = p.split(str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>  System.out.print(s[i]+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>  结果为ABCDEF<br></code></pre></td></tr></table></figure></li><li><p>替换里面的字符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A1B22C333D4444E55555F&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(“\\d”);<br><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(str);<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> m.replaceAll(<span class="hljs-string">&quot;-&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本编码</title>
    <link href="/2020/10/01/%E5%85%B6%E4%BB%96/1.%20%E7%BC%96%E7%A0%81/"/>
    <url>/2020/10/01/%E5%85%B6%E4%BB%96/1.%20%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>通常所说的乱码问题，是指文本文件乱码（非二进制文件），文本乱码的本质是解析的字符编码与文本本身字符编码不匹配导致的。</p><h2 id="1-字符集和字符编码"><a href="#1-字符集和字符编码" class="headerlink" title="1. 字符集和字符编码"></a>1. 字符集和字符编码</h2><ol><li><p>文本文件：通过字符编码（如UTF-8）保存的文件，如数字64，文本文件会将64解析成’6’和’4’两个字符，再根据字符集编码，再存储到硬盘中</p></li><li><p>二进制文件（狭义上的非文本文件）：保留数据本身二进制的文件，数字64，如Java的int型数字64，直接储存64的二进制到硬盘中</p></li></ol><p>字符集规定了字符在字符表的位置，在文本文件的存储过程中，文本会依靠字符集规则转化成字符，其中最著名的就是ASCII字符集和Unicode字符集。</p><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>ASCII既是世界上第一个字符集（charset），同时又规定了字符编码（encoding）。</p><p>ASCII字符编码用一个字节（7位容器）来表示一个字符，ASCII中一共有127个字符（0-126）。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>地球上字符太多，ASCII字符集的单字节无法表示，所以出现了Unicode字符集。最初时UTF-16编码来实现Unicode字符集，用2个或4个字节来保存。</p><ul><li><p>UTF-16：用两个或者四个字节（<strong>Java char类型用的2字节的UTF-16 LE</strong>），四字节称为UTF-16 BE</p></li><li><p>UTF-32：用四个字节</p></li><li><p>UTF-8：1～4个字节，1个字节时与ASCII编码相同，常见<strong>汉字一般3字节</strong></p></li></ul><h3 id="ISO-8859-1-（Latin-1）"><a href="#ISO-8859-1-（Latin-1）" class="headerlink" title="ISO-8859-1 （Latin 1）"></a>ISO-8859-1 （Latin 1）</h3><p>同样是ASCII码的超集，用一个字节（8位容器）实现255节。在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。mysql默认就采用他</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>一般汉字2字节。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html">Java中存在的编码问题</a></p><h2 id="2-Content-Type与前后编解码"><a href="#2-Content-Type与前后编解码" class="headerlink" title="2. Content-Type与前后编解码"></a>2. Content-Type与前后编解码</h2><p>开发过程中，设定HTTP请求和返回报文中的Content-Type是保证文本不乱码正常解析的最重要保障。</p><h3 id="浏览器解码顺序："><a href="#浏览器解码顺序：" class="headerlink" title="浏览器解码顺序："></a>浏览器解码顺序：</h3><ol><li><p>根据服务器返回的Content-Type中指定的编码解码。</p></li><li><p>根据meta标签的charset。</p></li><li><p>根据浏览器设定的编码解码（跟随浏览器设定，一般中文系统为GBK）</p></li></ol><h3 id="浏览器编码顺序和Content-Type："><a href="#浏览器编码顺序和Content-Type：" class="headerlink" title="浏览器编码顺序和Content-Type："></a>浏览器编码顺序和Content-Type：</h3><ul><li><p>POST请求的编码：默认UTF-8，<strong>ajax请求强制数据为UTF-8编码，即使在contentType中设置的编码也不生效</strong>，所以对于发送ajax请求，直接写application&#x2F;json，然后设置服务器对所有请求数据使用UTF-8解析：request.setCharactorEncoding(“UTF-8”)。</p><ul><li><p>Ajax POST默认contentType: application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8。</p></li><li><p>form POST默认的contentType: application&#x2F;x-www-form-urlencoded</p><p><strong>form POST的编码也是UTF-8，但是不会在Content-Type中声明</strong></p></li></ul></li><li><p>GET请求的编码：默认UTF-8（不指定Content-Type，一般传输不了中文）</p></li></ul><h3 id="服务器解码顺序："><a href="#服务器解码顺序：" class="headerlink" title="服务器解码顺序："></a>服务器解码顺序：</h3><ol><li><p>使用requst.setCharactorEncoding( )指定的编码解码。</p></li><li><p>根据客户端发送的Content-Type中的编码解码。</p></li><li><p>使用默认的UTF-8解码</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 设置Content-Type作用与于GET请求<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">useBodyEncodingForURI</span> = <span class="hljs-string">&quot;true&quot;</span> &gt;</span> <br> // 设置GET请求使用UTF-8解码, Tomcat 8以后这个默认值已经是UTF-8，<br> // 注意：request.setCharactorEncoding对GET请求不生效。<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">URIEncoding</span> =<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span> <br></code></pre></td></tr></table></figure><h3 id="服务器编码顺序和Content-Type："><a href="#服务器编码顺序和Content-Type：" class="headerlink" title="服务器编码顺序和Content-Type："></a>服务器编码顺序和Content-Type：</h3><ol><li><p>response.setContentType(“application&#x2F;json; charset&#x3D;UTF-8”)，respnse.setCharactorEncoding()</p></li><li><p>Servlet response的默认编码是UTF-8</p></li><li><p>JSP会默认Content-Type：</p><p>JSP的编码只受到Page指令的contentType&#x2F;pageEncoding命令约束，而且这两个命令对于JSP生成的Content-Type决定权最高。</p><p>response.setCharactorEncoding方法：设置返回数据的编码</p><p>response.setContentType方法：设置Servlet返回数据的编码和返回数据的Content-Type。<strong>setContentType方法优先级最高</strong>，在此方法前后出现setCharactorEncoding()，数据会按照Content-Type编码。</p></li></ol><ul><li>注解设置注解设置：@RequestMapping(value &#x3D; “”, <strong>produces&#x3D;”application&#x2F;json;charset&#x3D;UTF-8”</strong>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乱码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
